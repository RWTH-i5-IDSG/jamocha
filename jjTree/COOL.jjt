/** Grammar to generate a CLIPS Object Oriented Language (COOL)  parser with jjTree. 
	COOL is the language used by the CLIPS Production system 
		
	This jjTree Grammar creates an abstract synatx tree, based as closely on the 'look'
	of the source code, while the grammar is as close as possible to the specifications.
	This uses lots of rules which do not create nodes...
	
	The Actions of the grammar productions make certain assumptions about the nodes created.
	The following methods should be required by the SimpleNode interface:
		-setName
		-getName
		-execute
	Constructs also have
		-setDocString
		-getDocString
	Some Nodes have additional type info
		-setType
		-getType
	-isConstant (e.g. (+ 1 2 ) is constant after one execution, peudo-constant) ??!!
	
	Created Nov. 8th, 2006, at the Agent Technologies Practical 2006 at Aachen Technical University.
	
	@author Ory Chowaw-Liebman
	@author Ulrich Loup
	@todo Finnish Grammar
	@todo Can probably be optimized a bit
*/

options {
	MULTI=true;
	STATIC=false;
	NODE_PREFIX="COOL";
	NODE_USES_PARSER=true;
}

/* Java code used for the Parser. */
PARSER_BEGIN(COOL)
/** Parser for CLIPS Object Oriented Language.<br>
 * Note: A main mehtod to test the parser on the prompt is implemented outside the parser in class "Main".
 *@author Ory Chowaw-Liebman
 *@author Ulrich Loup
 */
import java.util.Hashtable;

public class COOL
{
	/** Hashtable of global variables defined, by name
	 */
	protected Hashtable<String, CLIPSData> globals = new Hashtable<String, CLIPSData>();
	
	/** Hashtable of functions defined, by name
	 */
	protected Hashtable<String, CLIPSFunction> funcs = new Hashtable<String, CLIPSFunction>();
	
	/** Fill the hashtables and initialize the function objects.
	 */
	public void initFunctions()
	{
		funcs.put("exit", new CLIPSFuncExit());
		funcs.put("+", new CLIPSFuncPlus());
		funcs.put("*", new CLIPSFuncMul());
		funcs.put("-", new CLIPSFuncSub());
		funcs.put("/", new CLIPSFuncDiv());
		//System.out.println(funcs.toString());
	}

	/** Get the Value of a gobal Variable
	 *@param name name of the variable
	 *@return value of the variable
	 */
	public CLIPSData getGlobalVar(String name)
	{ return globals.get(name); }

	/** Get a Function for calling from AST
	 *@param name name of the function (i.e. "exit", "+", "*", "-", "/")
	 *@return reference to the specified CLIPSFunction object
	 */
	public CLIPSFunction getFunction(String name)
	{ return funcs.get(name); }
}

PARSER_END(COOL)

/**********************************************
 * Lexical Specs
 */


SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| ";;" : IN_COMMENT
}

/* COMMENTS */

< IN_COMMENT >
MORE : 
{ 
  <  ~[] >
|
  < COMMENT_TEXT: ( (["0"-"9"])|(["a"-"z"]) )+ >
}

< IN_COMMENT >
SKIP :
{
  < END_COMMENT: ("\r" | "\n" | "\r\n") > : DEFAULT
}

TOKEN :
{
  < LBRACE: "(" >
| < RBRACE: ")" >
| < GE1: ">=" >
| < INTEGER: ["0"-"9"] (["0"-"9"])* >
| < FLOAT:
        (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)?
      | "." (["0"-"9"])+ (<EXPONENT>)?
      | (["0"-"9"])+ <EXPONENT>
  >
| < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
|
  < STRING:
      ("\"" ((~["\"","\\"]) | ("\\" ( ["\\","\""] )))* "\"") |
      ("\'" ((~["\'","\\"]) | ("\\" ( ["\\","\'"] )))* "\'")
  >
  // If you think this is ugly, you are right. See CLIPS Basic Progrmmers Guide:
  // "Numbers are symbols, but treated different. Instances are symbols, but treated different." 
| < INSTANCE: "[" <SYMBOL> "]">
| < #VARSYMBOL:  ["a"-"z","A"-"Z"] (~[" ","\r","\n","\t","\"","\'","(",")","&","|","<","~",";"])>
| < SINGLEVAR: "?" <VARSYMBOL> >
| < MULTIVAR: "$?" <VARSYMBOL> >
| < GLOBALVAR: "?*" <SYMBOL> "*" >
| < DEFFACTS: "deffacts" >
| < DEFTEMPLATE: "deftemplate" >
| < DEFRULE: "defrule" >
| < DEFFUNCTION: "deffunction" >
| < DEFGENERIC: "defgeneric" >
| < DEFMETHOD: "defmethod" >
| < DEFCLASS: "defclass" >
| < DEFGLOBAL: "defglobal" >
| < DEFAULT_ATR: "default" >
| < DYNAMIC_ATR: "default-dynamic" >
| < ATR_DEFAULT: "?DEFAULT" >
| < ATR_DERIVE: "?DERIVE" >
| < ATR_NONE: "?NONE" >
| < SLOT: "slot" >
| < SINGLE_SLOT: "single-slot" >
| < MULTISLOT: "multislot" >
| < ARROW: "=>">
| < DECLARE: "declare" >
| < SALIENCE: "salience" >
| < AUTOFOCUS: "auto-focus" >
| <	TYPE: "type" >
| < TRUE: "TRUE" | "true" | "True" >
| < FALSE: "FALSE" | "false" | "False" >
| < NOT: "not" >
| < AND: "and" >
| < OR: "or" >
| < LOGICAL: "logical" >
| < TEST: "test" >
| < EXISTS: "exists" >
| < FORALL: "forall">
| < OBJECT: "object" >
| < IS_A: "is-a" >
| < NAME: "name" >
| < ASSIGN: "<-" >
| < SFWILDCARD: "?" >
| < MFWILDCARD: "$?" >
| < TILDE: "~" >
| < AMPERSAND: "&" >
| < LINE: "|" >
| < COLON: ":" >
| < EQUALS: "=" >
| < VARIABLE_TYPE: "?VARIABLE" >
| < SYMBOL_TYPE: "SYMBOL" >
| < STRING_TYPE: "STRING" >
| < LEXEME_TYPE: "LEXEME" >
| < INTEGER_TYPE: "INTEGER" >
| < FLOAT_TYPE: "FLOAT" >
| < NUMBER_TYPE: "NUMBER" >
| < INSTANCE_NAME_TYPE: "INSTANCE-NAME" >
| < INSTANCE_ADDRESS_TYPE: "INSTANCE-ADDRESS" >
| < INSTANCE_TYPE: "INSTANCE" >
| < EXTERNAL_ADDRESS_TYPE: "EXTERNAL-ADDRESS" >
| < FACT_ADDRESS_TYPE: "FACT-ADDRESS" >
| < ALLOWED_SYMBOLS: "allowed-symbols" >
| < ALLOWED_STRINGS: "allowed-strings" >
| < ALLOWED_LEXEMES: "allowed-lexemes" >
| < ALLOWED_INTEGERS: "allowed-integers" >
| < ALLOWED_FLOATS: "allowed-floats" >
| < ALLOWED_NUMBERS: "allowed-numbers" >
| < ALLOWED_INSTANCES: "allowed-instances" >
| < ALLOWED_CLASSES: "allowed-classes" >
| < ALLOWED_VALUES: "allowed-values" >
| < RANGE: "range" >
| < CARDINALITY: "cardinality" >
| < ROLE: "role" >
| < CONCRETE: "concrete" >
| < ABSTRACT: "abstract" >
| < PATTERN_MATCH: "pattern-match" >
| < REACTIVE: "reactive" >
| < NON_REACTIVE: "non-reactive" >
| < STORAGE: "storage" >
| < LOCAL: "local" >
| < SHARED: "shared" >
| < ACCESS: "access" >
| < READ_WRITE: "read-write" >
| < READ_ONLY: "read-only" >
| < READ: "read" >
| < WRITE: "write" >
| < INITIALIZE_ONLY: "initialize-only" >
| < PROPAGATION: "propagation" >
| < INHERIT: "inherit" >
| < NO_INHERIT: "no-inherit" >
| < SOURCE: "source" >
| < EXCLUSIVE: "exclusive" >
| < COMPOSITE: "composite" >
| < VISIBILITY: "visibility" >
| < PRIVATE: "private" >
| < PUBLIC: "public" >
| < CREATE_ACCESSOR: "create-accessor" >
| < OVERRIDE_MESSAGE: "override-message" >
| < MESSAGE_HANDLER: "message-handler" >
| < PRIMARY: "primary" >
| < AROUND: "around" >
| < BEFORE: "before" >
| < AFTER: "after" >
| < SYMBOL:  
	(~[" ","\r","\n","\t","\"","\'","(",")","&","|","$","?","~",";","0"-"9"])
	|(
		(~[" ","\r","\n","\t","\"","\'","(",")","&","|","?","~",";","["])
		(~[" ","\r","\n","\t","\"","\'","(",")","&","|","?","~",";","0"-"9"])*
		(~[" ","\r","\n","\t","\"","\'","(",")","&","|","<","~",";" ])*
		(~[" ","\r","\n","\t","\"","\'","(",")","&","|","$","?","~",";","]"])? 
	)
	|(
		(~[" ","\r","\n","\t","\"","\'","(",")","&","|","?","~",";"])
		(~[" ","\r","\n","\t","\"","\'","(",")","&","|","?","~",";","0"-"9"])*
		(~[" ","\r","\n","\t","\"","\'","(",")","&","|","<","~",";" ])*
		(~[" ","\r","\n","\t","\"","\'","(",")","&","|","$","?","~",";","]"])+ 
	)
  >

}

/* TODO (From Clips Manual):
Data Types:
<file-name> ::= A symbol or string which is a valid file name (including path information)
	for the operating system under which CLIPS is running
<slot-name> ::= A valid deftemplate_construct slot name
<...-name> ::= A <symbol> where the ellipsis indicate what the symbol represents.
	For example, <rule-name> is a symbol which represents the name of a rule.
*/

/**********************************************
 * Clips Grammar Specs.
 * Main grammar, contains Input function
 */

/* TODO (From Clips Manual):
Variables and Expressions
<...-expression> ::= An <expression> which returns the type indicated by the
	ellipsis. For example, <integer-expression> should return an integer.
*/

/* Constructs

Defmessage-handler Construct
<defmessage-handler-construct> 
	::= (defmessage-handler <class-name> <message-name> [<handler-type>] 
		[<comment>] (<parameter>* [<wildcard-parameter>]) <action>*)
<handler-type> ::= around | before | primary | after
<parameter> ::= <single-field-variable>
<wildcard-parameter> ::= <multifield-variable>

Definstances Construct
<definstances-construct> ::= (definstances <definstances-name> [active] [<comment>] <instance-template>*)
<instance-template> ::= (<instance-definition>)
<instance-definition> ::= <instance-name-expression> of <class-name-expression> <slot-override>*
<slot-override> ::= (<slot-name-expression> <expression>*)

Defmodule Construct
<defmodule-construct> ::= (defmodule <module-name> [<comment>] <port-specification>*)
<port-specification> ::= (export <port-item>) | (import <module-name> <port-item>)
<port-item> ::= ?ALL | ?NONE | <port-construct> ?ALL | 
	<port-construct> ?NONE | <port-construct> <construct-name>+
<port-construct> ::= deftemplate_construct | defclass | defglobal | deffunction | defgeneric
*/

/** Start rule is one construct at a time, Parser reads constructs into list.
	No need to create nodes for Start, Defcon and Funcon rule.*/
COOLStart Start() : {}
{
	( LOOKAHEAD(2)
	   Construct() | Expression()
	)
  { return jjtThis; }
}


/*
<number> ::= <float> | <integer> 
<lexeme> ::= <symbol> | <string>
<constant> ::= <symbol> | <string> | <integer> | <float> | <instance-name>
*/

void Float() : { Token t; }
{
	t = <FLOAT>
	{ jjtThis.setName(t.image); }
}


void Integer() : { Token t; }
{
	t = <INTEGER>
	{ jjtThis.setName(t.image); }
}

void Number() #void : {}
{
	Float() | Integer()
}

void Symbol() : { Token t;}
{
	t = <SYMBOL>
	{ jjtThis.setName(t.image); }
}

void String() : { Token t; }
{
	t = <STRING>
	{ jjtThis.setName(t.image); }

}

void Lexeme() #void : {}
{	String() | Symbol() }

void Instance() : { Token t; }
{
	t = <INSTANCE>
	{ jjtThis.setName(t.image); }
}

void Constant() #void:{}
{ 	Symbol() | String() | Integer() | Float() | Instance() }

void Comment() #void : {}
{	
    String()
}

/*
<function-name> ::= Any symbol which corresponds to a system or user defined function, a
	deffunction name, or a defgeneric name
	( Ory: I understand this to be a <SYMBOL> token )
<file-name> ::= A symbol or string which is a valid file name (including path information)
	for the operating system under which CLIPS is running

<variable> ::= <single-field-variable> | <multifield-variable> | <global-variable>
<function-call> ::= (<function-name> <expression>*)
<expression> ::= <constant> | <variable> | <function-call>
<action> ::= <expression>
*/

// This is used exactly then when only the variables value is needed
void SingleVariable() : { Token t; } 
{
	t = <SINGLEVAR>
	{ jjtThis.setName(t.image); }
}

// This is used exactly then when only the variables value is needed
void GlobalVariable() : { Token t; } 
{
	t = <GLOBALVAR>
	{ jjtThis.setName(t.image); }
}

// This is used exactly then when only the variables contents are needed
void MultiVariable() : { Token t; } 
{
	t = <MULTIVAR>
	{ jjtThis.setName(t.image); }
}


// This is used exactly then when only the variables value is needed
void Variable() #void : {}
{	SingleVariable() | MultiVariable() | GlobalVariable() }

void FunctionCall() : { Token t; }
{
	<LBRACE> 
		t = <SYMBOL>
		{ jjtThis.setName(t.image); }
		(Expression())*
	<RBRACE>
}

void Expression() #void : {} 
{	Constant() | Variable() | FunctionCall() }


/** Dummy Defined in CLIPS programmers guide... */
void Action() #void : {} {  Expression() }


/** Main Handler for Definition constructs.
	Note it contains the parantheses for the constructs
*/
void Construct() #void : {}
{
	<LBRACE>
	(
		DefFactsConstruct()
	|	DefTemplateConstruct()
	|	DefglobalConstruct()
	|	DefruleConstruct()
	|	DeffunctionConstruct()
	|	DefgenericConstruct() 
	|	DefmethodConstruct() 
 	|	DefclassConstruct() 
//	|	DefInstanceConstruct() 
//	|	DefMessageConstruct() 
//	|	DefModuleConstruct() 
	)
	<RBRACE>
}

/* Deffacts construct: <deffacts-construct> ::= (deffacts <deffacts-name> [<comment>] <RHS-pattern>*) */
void DefFactsConstruct() : { Token t; }
{
	<DEFFACTS>
	t = <SYMBOL>
	{ jjtThis.setName(t.image); }//name
	[
		t = <STRING>
		{ jjtThis.setDocString(t.image); }//comment
	]
	(RHSPattern())*
}

/* Deftemplate construct */

//<deftemplate-construct> ::= (deftemplate <deftemplate-name> [<comment>] <slot-definition>*)
void DefTemplateConstruct() : { Token t; }
{
        <DEFTEMPLATE>
        t = <SYMBOL>
        { jjtThis.setName(t.image); }
	    [
			t = <STRING>
			{ jjtThis.setDocString(t.image); }
		]
        (SlotDefinition())*
}

//<slot-definition> ::= <single-slot-definition> | <multislot-definition>
void SlotDefinition() #void : {}
{
    <LBRACE> ( SingleSlotDefinition() | MultislotDefinition() ) <RBRACE> 
}

//<single-slot-definition> ::= (slot <slot-name> <template-attribute>*)
void SingleSlotDefinition() : { Token t; }
{
        <SLOT>
        t = <SYMBOL>
        { jjtThis.setName(t.image); }//<slot-name>
        (TemplateAttribute())*
}

//<multislot-definition> ::= (multislot <slot-name> <template-attribute>*)
void MultislotDefinition() : { Token t; }
{
        <MULTISLOT>
        t = <SYMBOL>
        { jjtThis.setName(t.image); }//<slot-name>
        (TemplateAttribute())*
}

//<template-attribute> ::= <default-attribute> | <constraint-attribute>
void TemplateAttribute() #void : {}
{
    DefaultAttribute() | DynamicAttribute() | ConstraintAttribute()
}

//<default-attribute> ::= (default ?DERIVE | ?NONE | <expression>*) | (default-dynamic <expression>*)
/*
void DefaultAttribute() #void : {}
{
    <LBRACE> 
		(DefaultAttribute() | DynamicAttribute() ) 
     <RBRACE>
}
*/
void DefaultAttribute() : {}
{
	<DEFAULT_ATR>
	(
		<ATR_DERIVE> { jjtThis.setType(COOLDefaultAttribute.T_DERIVE); }
	|	<ATR_NONE> { jjtThis.setType(COOLDefaultAttribute.T_NONE); }
	|	(LOOKAHEAD(2) Expression())* 
	)
}

void DynamicAttribute() : {}
{	
	<DYNAMIC_ATR> 
	(LOOKAHEAD(2) Expression())* 
}

/* Fact Specification */

//<RHS-pattern> ::= <ordered-RHS-pattern> | <template-RHS-pattern>
void RHSPattern() #void : {}
{
    OrderedRHSPattern() | TemplateRHSPattern()
}

//<ordered-RHS-pattern> ::= (<symbol> <RHS-field>+)
void OrderedRHSPattern() : { Token t;}
{
    t = <SYMBOL>
    { jjtThis.setName(t.image); }
    ( LOOKAHEAD(2) Expression())+
}

//<template-RHS-pattern> ::= (<deftemplate-name> <RHS-slot>*)
void TemplateRHSPattern() : { Token t; }
{
    <LBRACE>
        t = <SYMBOL>
        { jjtThis.setName(t.image); }//name
        (RHSSlot())*
    <RBRACE>
}

//<RHS-slot> ::= <single-field-RHS-slot> | <multifield-RHS-slot>
void RHSSlot() #void : {}
{
    <LBRACE> 
		SingleFieldRHSSlot() 
	|	MultifieldRHSSlot()
    <RBRACE>
}

//<single-field-RHS-slot> ::= (<slot-name> <RHS-field>)
void SingleFieldRHSSlot() : { Token t; }
{
        t = <SYMBOL>
        { jjtThis.setName(t.image); }//slot-name
        Expression()
}

//<multifield-RHS-slot> ::= (<slot-name> <RHS-field>*)
void MultifieldRHSSlot() : { Token t; }
{
        t = <SYMBOL>
        { jjtThis.setName(t.image); }//slot-name
        (Expression())*
}

//<RHS-field> ::= <variable> | <constant> | <function-call>
// Same as expression
/*void RHSField() #void : {}
{
    Variable() | Constant() | FunctionCall()
}*/

/* Defrule Construct */

//<defrule-construct> 
//	::= (defrule <rule-name> [<comment>] [<declaration>] <conditional-element>* => <action>*)
void DefruleConstruct() : { Token t; }
{
  ( //LOOKAHEAD(3)
	<DEFRULE>
	( LOOKAHEAD(2)
		( 
			t = <SYMBOL>
			{ jjtThis.setName(t.image); }//name
		) |	(
			t = <SYMBOL>
			{ jjtThis.setName(t.image); }//name
			t = <STRING>
			{ jjtThis.setDocString(t.image); }	
		)
	)
	( LOOKAHEAD(2)
		(
			Declaration()
			CEList()
		) |
		(
			CEList()
		)
	)
	<ARROW>
	ActionList()
  )
}

// Create Dummy node to have fixed number of chlidren in Defrule
void CEList():{} { (ConditionalElement())* }

// Create Dummy node to have fixed number of chlidren in Defrule
void ActionList():{} { (Expression())* }

// Create Dummy node to have fixed number of chlidren later
void CEList2():{} { (ConditionalElement())+ }

//<declaration> ::= (declare <rule-property>+)
void Declaration() : {}
{
    <LBRACE>
        <DECLARE>
        (RuleProperty())+
    <RBRACE>
}

//<rule-property> ::= (salience <integer-expression>) | (auto-focus <boolean-symbol>)
void RuleProperty() : {}
{
    <LBRACE> (
		(  <SALIENCE>
			//todo:        <integer-expression>
			// Ory: Just use expression and check for it being an integer at runtime (it could use global variables)
			Expression()
		)
		{ // Set node type to salience, 
		}
     | 
		(  <AUTOFOCUS> BooleanSymbol() )
		{ // Set node type to auto-focus, 
		}
	) <RBRACE>
}

//<boolean-symbol> ::= TRUE | FALSE
void BooleanSymbol() : { Token t;}
{
    ( t = <TRUE> ) { jjtThis.setName(t.image); jjtThis.setToTrue();}
    |
    ( t = <FALSE> ) { jjtThis.setName(t.image); jjtThis.setToFalse(); }
}

//<conditional-element> ::= <pattern-CE> | <assigned-pattern-CE> | <not-CE> | <and-CE> | <or-CE> |
//                          <logical-CE> | <test-CE> | <exists-CE> | <forall-CE>
void ConditionalElement() #void : {}
{
	<LBRACE> 
		(
		PatternCE() | AssignedPatternCE() | 
		BooleanFunction() |LogicalCE() |
		TestCE() | ExistsCE() | ForallCE()
		)
	<RBRACE>
	
}

void BooleanFunction() : { }
{
		(	// Unary operators
			<NOT> { jjtThis.setType(COOLBooleanFunction.OP_NOT); }
			ConditionalElement() 
		)
	|	(	// non-Unary operators
			<AND> { jjtThis.setType(COOLBooleanFunction.OP_AND); }
		|	<OR> { jjtThis.setType(COOLBooleanFunction.OP_OR); }
      
			(ConditionalElement())+ 
		)
}

//<pattern-CE> ::= <ordered-pattern-CE> | <template-pattern-CE> | <object-pattern-CE>
void PatternCE() #void : {}
{
	( LOOKAHEAD(2) OrderedPatternCE() | TemplatePatternCE() | ObjectPatternCE() )
}

//<assigned-pattern-CE> ::= <single-field-variable> <- <pattern-CE>
void AssignedPatternCE() : {}
{
    SingleVariable() 
    <ASSIGN>
    PatternCE()
}


//<logical-CE> ::= (logical <conditional-element>+)
void LogicalCE() : {}
{
    <LOGICAL> (ConditionalElement())+ 
}

//<test-CE> ::= (test <function-call>)
void TestCE() : {}
{
    <TEST> FunctionCall()
}

//<exists-CE> ::= (exists <conditional-element>+)
void ExistsCE() : {}
{
    <EXISTS> (ConditionalElement())+
}

//<forall-CE> ::= (forall <conditional-element> <conditional-element>+)
void ForallCE() : {}
{
	<FORALL> ConditionalElement() CEList2()
}

//<ordered-pattern-CE> ::= (<symbol> <constraint>*)
void OrderedPatternCE() : { Token t; }
{
        t = <SYMBOL>
        { jjtThis.setName(t.image); }
        (Constraint())*
}

//<template-pattern-CE> ::= (<deftemplate-name> <LHS-slot>*)
void TemplatePatternCE() : { Token t; }
{
        t = <SYMBOL>
        { jjtThis.setName(t.image); }	//deftemplate-name
        (LHSSlot())*
}

//<object-pattern-CE> ::= (object <attribute-constraint>*)
void ObjectPatternCE() : {}
{
        <OBJECT>
        (AttributeConstraint())*
}

//<attribute-constraint> ::= (is-a <constraint>) | (name <constraint>) | (<slot-name> <constraint>*)
void AttributeConstraint() : { Token t; }
{
    <LBRACE>
        ( 
		  (	<IS_A> { jjtThis.setType(COOLAttributeConstraint.T_ISA); }
		|	<NAME> { jjtThis.setType(COOLAttributeConstraint.T_NAME); }
		  )
		  Constraint() 
		)| (
          t = <SYMBOL> { jjtThis.setType(COOLAttributeConstraint.T_SYMBOL); jjtThis.setName(t.image); }
          (Constraint())* )
    <RBRACE>
}

// Functionally identical
//<single-field-LHS-slot> ::= (<slot-name> <constraint>)
//<multifield-LHS-slot> ::= (<slot-name> <constraint>*)
//<LHS-slot> ::= <single-field-LHS-slot> | <multifield-LHS-slot>
void LHSSlot() : { Token t; }
{
    <LBRACE>
        t = <SYMBOL>
        { jjtThis.setName(t.image); }	//slot-name
		(Constraint())*

	<RBRACE>
}

//<constraint> ::= ? | $? | <connected-constraint>
void Constraint() #void : {}
{
    SingleFieldWildcard() | MultiFieldWildcard() | ConnectedConstraint()
}

void SingleFieldWildcard() : {} { <SFWILDCARD> }
void MultiFieldWildcard() : {} { <MFWILDCARD> }

//<connected-constraint>::= <single-constraint> | <single-constraint> & <connected-constraint> |
//	<single-constraint> | <connected-constraint>
void ConnectedConstraint() : {}
{
  ( 
		Term() { jjtThis.setType(COOLConnectedConstraint.T_SINGLE); }
		(	
			(( <AMPERSAND> Term()) + ) { jjtThis.setType(COOLConnectedConstraint.T_AND); } 
		|	(( <LINE> Term()) + ) { jjtThis.setType(COOLConnectedConstraint.T_OR); }
		) 
  )
}

//<term> ::= <constant> | <single-field-variable> | <multifield-variable> | 
//	:<function-call> | =<function-call>
void Term() : {}
{
/*	[	<TILDE>	{ jjtThis.setNegate(true); }
	] */
    ( LOOKAHEAD(3)
		Constant() { jjtThis.setType(COOLTerm.T_CONST); }
    |	SingleVariable() { jjtThis.setType(COOLTerm.T_SINGLE); }
    |	MultiVariable() { jjtThis.setType(COOLTerm.T_MULTI); }
    |	(<COLON> FunctionCall() ) { jjtThis.setType(COOLTerm.T_COLON); }
    |	(<EQUALS> FunctionCall() ) { jjtThis.setType(COOLTerm.T_EQ); } 
    )
}

/* Defglobal Construct */

//<defglobal-construct> ::= (defglobal [<defmodule-name>] <global-assignment>*)
void DefglobalConstruct() : { Token t; }
{
        <DEFGLOBAL>
        [ 
            t = <SYMBOL>
            { jjtThis.setName(t.image); }	//defmodule-name 
        ]
        (GlobalAssignment())*
}

//<global-assignment> ::= <global-variable> = <expression>
void GlobalAssignment() : { Token t; }
{
	t = <GLOBALVAR>
	{ jjtThis.setName(t.image); }	// Needs to access variable not just read the value
    <EQUALS>
    Expression()
}

/* Deffunction Construct */

//<deffunction-construct> 
//	::= (deffunction <name> [<comment>] (<regular-parameter>* [<wildcard-parameter>]) <action>*)
void DeffunctionConstruct() : { Token t; }
{
        <DEFFUNCTION>
        t = <SYMBOL>
        { jjtThis.setName(t.image); }//name
        [ t = <STRING> 
			{ jjtThis.setDocString(t.image); }
        ]
        <LBRACE> ParameterList() [ MultiVariable() ] <RBRACE>
        ActionList()
}

//<regular-parameter> ::= <single-field-variable>
void ParameterList() : {}
{
    (SingleVariable())*
}

/* Ignored, produces multifield variable directly
//<wildcard-parameter> ::= <multifield-variable>
void WildcardParameter()  #void : {}
{
    MultiVariable()
}
*/

/* Defgeneric Construct */

//<defgeneric-construct> ::= (defgeneric <name> [<comment>])
void DefgenericConstruct() : { Token t; }
{
        <DEFGENERIC>
        t = <SYMBOL>
        { jjtThis.setName(t.image); }	//name
        [ t = <STRING>
			{ jjtThis.setDocString(t.image); }
        ]
}

/* Defmethod Construct */

//<defmethod-construct> ::= (defmethod <name> [<index>] [<comment>] (<parameter-restriction>*
//	[<wildcard-parameter-restriction>]) <action>*)
void DefmethodConstruct() : { Token t; }
{
	<DEFMETHOD>
	t = <SYMBOL>
	{ jjtThis.setName(t.image); }//name
	[
		t = <INTEGER>
		{ jjtThis.setIndex(t.image); }//method index (cf. clipsbasic programmers guide section 8.4.2)
	]
	[
		t = <STRING>
		{ jjtThis.setDocString(t.image); }//comment
	]
	<LBRACE>
		(ParameterRestriction())*
		[ WildcardParameterRestriction() ]
	<RBRACE>
    ActionList()
}

//<parameter-restriction> ::= <single-field-variable> | (<single-field-variable> <type>* [<query>])
void ParameterRestriction() : {}
{
	( LOOKAHEAD(2)
		(
			SingleVariable()
		) |
		(
			SingleVariable()
			<LBRACE>
				SingleVariable() (Type())* [Query()]
			<RBRACE>
		)
	)
}

//<wildcard-parameter-restriction> ::= <multifield-variable> | (<multifield-variable> <type>* [<query>])
void WildcardParameterRestriction() : {}
{
	( LOOKAHEAD(2)
		(
			MultiVariable()
		) |
		(
			MultiVariable()
			<LBRACE>
				MultiVariable() (Type())* [Query()]
			<RBRACE>
		)
	)
}

//<type> ::= <class-name>
void Type() : { Token t; }
{
	t = <SYMBOL>
	{ jjtThis.setName(t.image); }//class-name
}

//<query> ::= <global-variable> | <function-call>
void Query() : { Token t; }
{
	t = <GLOBALVAR>
	{ jjtThis.setName(t.image); }//global-variable
	|
	FunctionCall()
}

/* Defclass Construct */

//<defclass-construct> ::= (defclass <name> [<comment>] (is-a <superclass-name>+)
//	[<role>] [<pattern-match-role>] <slot>* <handler-documentation>*)
void DefclassConstruct() : { Token t; }
{
	<DEFCLASS>
	t = <SYMBOL>
	{ jjtThis.setName(t.image); }//name
	[
		t = <STRING>
		{ jjtThis.setName(t.image); }//comment
	]
	<LBRACE>
		<IS_A>
		(
			t = <SYMBOL>
			{ jjtThis.addClassname(t.image); }//superclass-name
		)+
	<RBRACE>
	[ LOOKAHEAD(2) Role() ]
	[ LOOKAHEAD(2) PatternMatchRole() ]
	( LOOKAHEAD(2) Slot() )*
	( LOOKAHEAD(2) HandlerDocumentation() )*
}

//<role> ::= (role concrete | abstract)
void Role() : {}
{
	<LBRACE>
		<ROLE> <CONCRETE> | <ABSTRACT>
	<RBRACE>
}

//<pattern-match-role> ::= (pattern-match reactive | non-reactive)
void PatternMatchRole() : {}
{
	<LBRACE>
		<PATTERN_MATCH> <REACTIVE> | <NON_REACTIVE>
	<RBRACE>
}

//<slot> ::= (slot <name> <facet>*) | (single-slot <name> <facet>*) | (multislot <name> <facet>*)
void Slot() : { Token t; }
{
	<LBRACE>
		(
			<SLOT> | <SINGLE_SLOT> | <MULTISLOT>
		)
		t = <SYMBOL>
		{ jjtThis.setName(t.image); }
		( Facet() )*
	<RBRACE>
}

//<facet> ::= <default-facet> | <storage-facet> | <access-facet> | <propagation-facet> | 
//	<source-facet> | <pattern-match-facet> | <visibility-facet> | 
//	<create-accessor-facet> <override-message-facet> | <constraint-attribute>
void Facet() #void : {}
{
	<LBRACE> //facets all have brackets
		( LOOKAHEAD(2)
			DefaultFacet() | StorageFacet() | AccessFacet() | PropagationFacet() |
			SourceFacet() | PatternMatchFacet() | VisibilityFacet() |
			CreateAccessorFacet() <RBRACE> <LBRACE> OverrideMessageFacet() |
			ConstraintAttribute()
		)
	<RBRACE>
}

//<default-facet> ::= (default ?DERIVE | ?NONE | <expression>*) | (default-dynamic <expression>*)
void DefaultFacet() : {}
{
	( <DEFAULT_ATR> <ATR_DERIVE> | <ATR_NONE> | (Expression())* ) |
	( <DYNAMIC_ATR> (Expression())* )
}

//<storage-facet> ::= (storage local | shared)
void StorageFacet() : {}
{
	<STORAGE> <LOCAL> | <SHARED>
}
	
//<access-facet> ::= (access read-write | read-only | initialize-only)
void AccessFacet() : {}
{
	<ACCESS> <READ_WRITE> | <READ_ONLY> | <INITIALIZE_ONLY>
}

//<propagation-facet> ::= (propagation inherit | no-inherit)
void PropagationFacet() : {}
{
	<PROPAGATION> <INHERIT> | <NO_INHERIT>
}

//<source-facet> ::= (source exclusive | composite)
void SourceFacet() : {}
{
	<SOURCE> <EXCLUSIVE> | <COMPOSITE>
}

//<pattern-match-facet> ::= (pattern-match reactive | non-reactive)
void PatternMatchFacet() : {}
{
	<PATTERN_MATCH> <REACTIVE> | <NON_REACTIVE>
}

//<visibility-facet> ::= (visibility private | public)
void VisibilityFacet() : {}
{
	<VISIBILITY> <PRIVATE> | <PUBLIC>
}

//<create-accessor-facet> ::= (create-accessor ?NONE | read | write | read-write)
void CreateAccessorFacet() : {}
{
	<CREATE_ACCESSOR> <ATR_NONE> | <READ> | <WRITE> | <READ_WRITE>
}

//<override-message-facet> ::= (override-message ?DEFAULT | <message-name>)
void OverrideMessageFacet() : { Token t; }
{
	<OVERRIDE_MESSAGE> <ATR_DEFAULT> |
	t = <SYMBOL>
	{ jjtThis.setName(t.image); }//name
}

//<handler-documentation> ::= (message-handler <name> [<handler-type>])
void HandlerDocumentation() : { Token t; }
{
	<MESSAGE_HANDLER>
	t = <SYMBOL>
	{ jjtThis.setName(t.image); }//name
	[ HandlerType() ]
}

//<handler-type> ::= primary | around | before | after
void HandlerType() : { Token t; }
{
	<PRIMARY> | <AROUND> | <BEFORE> | <AFTER>
}

/* constraint Attributes */

//<constraint-attribute> ::= <type-attribute> | <allowed-constant-attribute> | 
//	<range-attribute> | <cardinality-attribute>
void ConstraintAttribute() : {}
{
	<LBRACE> //brackets for all productions below
	( LOOKAHEAD(2)
		TypeAttribute() | AllowedConstantAttribute() |
		RangeAttribute() | CardinalityAttribute()
	)
	<RBRACE>
}

//<type-attribute> ::= (type <type-specification>)
void TypeAttribute() : {}
{
	<TYPE> TypeSpecification()
}

//<type-specification> ::= <allowed-type>+ | ?VARIABLE
void TypeSpecification() : {}
{
		(AllowedType())+ | <VARIABLE_TYPE>
}

//<allowed-type> ::= SYMBOL | STRING | LEXEME | INTEGER | FLOAT | NUMBER |
//	INSTANCE-NAME | INSTANCE-ADDRESS | INSTANCE | EXTERNAL-ADDRESS | FACT-ADDRESS
void AllowedType() #void : {}
{
	<SYMBOL_TYPE> | <STRING_TYPE> | <LEXEME_TYPE> | <INTEGER_TYPE> | <FLOAT_TYPE> | <NUMBER_TYPE> |
	<INSTANCE_NAME_TYPE> | <INSTANCE_ADDRESS_TYPE> | <INSTANCE_TYPE> | <EXTERNAL_ADDRESS_TYPE> | <FACT_ADDRESS_TYPE>
}

//<allowed-constant-attribute> ::= (allowed-symbols <symbol-list>) | (allowed-strings <string-list>) |
//	(allowed-lexemes <lexeme-list> | (allowed-integers <integer-list>) | (allowed-floats <float-list>) |
//	(allowed-numbers <number-list>) | (allowed-instance-names <instance-list>) |
//	(allowed-classes <class-name-list>) | (allowed-values <value-list>)
void AllowedConstantAttribute() : {}
{
	(
		<ALLOWED_SYMBOLS> SymbolList()		|
		<ALLOWED_STRINGS> StringList()		|
		<ALLOWED_LEXEMES> LexemeList()		|
		<ALLOWED_INTEGERS> IntegerList()	|
		<ALLOWED_FLOATS> FloatList()		|
		<ALLOWED_NUMBERS> NumberList()		|
		<ALLOWED_INSTANCES> InstanceList()	|
		<ALLOWED_CLASSES> ClassNameList()	|
		<ALLOWED_VALUES> ValueList()		
	)
}

//<symbol-list> ::= <symbol>+ | ?VARIABLE
void SymbolList() : {}
{
	(<SYMBOL>)+ | <VARIABLE_TYPE>
}

//<string-list> ::= <string>+ | ?VARIABLE
void StringList() : {}
{
	(<STRING>)+ | <VARIABLE_TYPE>
}

//<lexeme-list> ::= <lexeme>+ | ?VARIABLE
void LexemeList() : {}
{
	(Lexeme())+ | <VARIABLE_TYPE>
}

//<integer-list> ::= <integer>+ | ?VARIABLE
void IntegerList() : {}
{
	(<INTEGER>)+ | <VARIABLE_TYPE>
}

//<float-list> ::= <float>+ | ?VARIABLE
void FloatList() : {}
{
	(<FLOAT>)+ | <VARIABLE_TYPE>
}

//<number-list> ::= <number>+ | ?VARIABLE
void NumberList() : {}
{
	(Number())+ | <VARIABLE_TYPE>
}

//<instance-name-list> ::= <instance-name>+ | ?VARIABLE
void InstanceList() : {}
{
	(<INSTANCE>)+ | <VARIABLE_TYPE>
}

//<class-name-list> ::= <class-name>+ | ?VARIABLE
void ClassNameList() : { Token t; }
{
	( 
		t = <SYMBOL>
		{ jjtThis.addClassname(t.image); }//class-name
	)+ 
	|
	<VARIABLE_TYPE>
}

//<value-list> ::= <constant>+ | ?VARIABLE
void ValueList() : {}
{
	(Constant())+ | <VARIABLE_TYPE>
}

//<range-attribute> ::= (range <range-specification> <range-specification>)
void RangeAttribute() : {}
{
	<RANGE> RangeSpecification() RangeSpecification()
}

//<range-specification> ::= <number> | ?VARIABLE
void RangeSpecification() : {}
{
	Number() | <VARIABLE_TYPE>
}

//<cardinality-attribute> ::= (cardinality <cardinality-specification> <cardinality-specification>)
void CardinalityAttribute() : {}
{
	<CARDINALITY> CardinalitySpecification() CardinalitySpecification()
}

//<cardinality-specification> ::= <integer> | ?VARIABLE
void CardinalitySpecification() : {}
{
	Integer() | <VARIABLE_TYPE>
}

