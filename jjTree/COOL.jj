/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. ./COOL.jj */
/*@egen*//** Grammar to generate a CLIPS Object Oriented Language (COOL)  parser with jjTree. 
	COOL is the language used by the CLIPS Production system 
		
	This jjTree Grammar creates an abstract synatx tree, based as closely on the 'look'
	of the source code, while the grammar is as close as possible to the specifications.
	This uses lots of rules which do not create nodes...
	
	The Actions of the grammar productions make certain assumptions about the nodes created.
	The following methods should be required by the SimpleNode interface:
		-setName
		-getName
		-execute
	Constructs also have
		-setDocString
		-getDocString
	Some Nodes have additional type info
		-setType
		-getType
	-isConstant (e.g. (+ 1 2 ) is constant after one execution, peudo-constant) ??!!
	
	Created Nov. 8th, 2006, at the Agent Technologies Practical 2006 at Aachen Technical University.
	
	@author Ory Chowaw-Liebman
	@author Ulrich Loup
	@todo Finnish Grammar
	@todo Can probably be optimized a bit
*/

options {              
	STATIC=false;                                               
}

/* Java code used for the Parser. */
PARSER_BEGIN(COOL)
/** Parser for CLIPS Object Oriented Language.<br>
 * Note: A main mehtod to test the parser on the prompt is implemented outside the parser in class "Main".
 *@author Ory Chowaw-Liebman
 *@author Ulrich Loup
 */
import java.util.Hashtable;

public class COOL/*@bgen(jjtree)*/implements COOLTreeConstants/*@egen*/
{/*@bgen(jjtree)*/
  protected JJTCOOLState jjtree = new JJTCOOLState();

/*@egen*/
	/** Hashtable of global variables defined, by name
	 */
	protected Hashtable<String, CLIPSData> globals = new Hashtable<String, CLIPSData>();
	
	/** Hashtable of functions defined, by name
	 */
	protected Hashtable<String, CLIPSFunction> funcs = new Hashtable<String, CLIPSFunction>();
	
	/** Fill the hashtables and initialize the function objects.
	 */
	public void initFunctions()
	{
		funcs.put("exit", new CLIPSFuncExit());
		funcs.put("+", new CLIPSFuncPlus());
		funcs.put("*", new CLIPSFuncMul());
		funcs.put("-", new CLIPSFuncSub());
		funcs.put("/", new CLIPSFuncDiv());
		//System.out.println(funcs.toString());
	}

	/** Get the Value of a gobal Variable
	 *@param name name of the variable
	 *@return value of the variable
	 */
	public CLIPSData getGlobalVar(String name)
	{ return globals.get(name); }

	/** Get a Function for calling from AST
	 *@param name name of the function (i.e. "exit", "+", "*", "-", "/")
	 *@return reference to the specified CLIPSFunction object
	 */
	public CLIPSFunction getFunction(String name)
	{ return funcs.get(name); }
}

PARSER_END(COOL)

/**********************************************
 * Lexical Specs
 */


SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| ";;" : IN_COMMENT
}

/* COMMENTS */

< IN_COMMENT >
MORE : 
{ 
  <  ~[] >
|
  < COMMENT_TEXT: ( (["0"-"9"])|(["a"-"z"]) )+ >
}

< IN_COMMENT >
SKIP :
{
  < END_COMMENT: ("\r" | "\n" | "\r\n") > : DEFAULT
}

TOKEN :
{
  < LBRACE: "(" >
| < RBRACE: ")" >
| < GE1: ">=" >
| < INTEGER: ["0"-"9"] (["0"-"9"])* >
| < FLOAT:
        (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)?
      | "." (["0"-"9"])+ (<EXPONENT>)?
      | (["0"-"9"])+ <EXPONENT>
  >
| < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
|
  < STRING:
      ("\"" ((~["\"","\\"]) | ("\\" ( ["\\","\""] )))* "\"") |
      ("\'" ((~["\'","\\"]) | ("\\" ( ["\\","\'"] )))* "\'")
  >
  // If you think this is ugly, you are right. See CLIPS Basic Progrmmers Guide:
  // "Numbers are symbols, but treated different. Instances are symbols, but treated different." 
| < INSTANCE: "[" <SYMBOL> "]">
| < #VARSYMBOL:  ["a"-"z","A"-"Z"] (~[" ","\r","\n","\t","\"","\'","(",")","&","|","<","~",";"])>
| < SINGLEVAR: "?" <VARSYMBOL> >
| < MULTIVAR: "$?" <VARSYMBOL> >
| < GLOBALVAR: "?*" <SYMBOL> "*" >
| < DEFFACTS: "deffacts" >
| < DEFTEMPLATE: "deftemplate" >
| < DEFRULE: "defrule" >
| < DEFFUNCTION: "deffunction" >
| < DEFGENERIC: "defgeneric" >
| < DEFMETHOD: "defmethod" >
| < DEFCLASS: "defclass" >
| < DEFGLOBAL: "defglobal" >
| < DEFAULT_ATR: "default" >
| < DYNAMIC_ATR: "default-dynamic" >
| < ATR_DEFAULT: "?DEFAULT" >
| < ATR_DERIVE: "?DERIVE" >
| < ATR_NONE: "?NONE" >
| < SLOT: "slot" >
| < SINGLE_SLOT: "single-slot" >
| < MULTISLOT: "multislot" >
| < ARROW: "=>">
| < DECLARE: "declare" >
| < SALIENCE: "salience" >
| < AUTOFOCUS: "auto-focus" >
| <	TYPE: "type" >
| < TRUE: "TRUE" | "true" | "True" >
| < FALSE: "FALSE" | "false" | "False" >
| < NOT: "not" >
| < AND: "and" >
| < OR: "or" >
| < LOGICAL: "logical" >
| < TEST: "test" >
| < EXISTS: "exists" >
| < FORALL: "forall">
| < OBJECT: "object" >
| < IS_A: "is-a" >
| < NAME: "name" >
| < ASSIGN: "<-" >
| < SFWILDCARD: "?" >
| < MFWILDCARD: "$?" >
| < TILDE: "~" >
| < AMPERSAND: "&" >
| < LINE: "|" >
| < COLON: ":" >
| < EQUALS: "=" >
| < VARIABLE_TYPE: "?VARIABLE" >
| < SYMBOL_TYPE: "SYMBOL" >
| < STRING_TYPE: "STRING" >
| < LEXEME_TYPE: "LEXEME" >
| < INTEGER_TYPE: "INTEGER" >
| < FLOAT_TYPE: "FLOAT" >
| < NUMBER_TYPE: "NUMBER" >
| < INSTANCE_NAME_TYPE: "INSTANCE-NAME" >
| < INSTANCE_ADDRESS_TYPE: "INSTANCE-ADDRESS" >
| < INSTANCE_TYPE: "INSTANCE" >
| < EXTERNAL_ADDRESS_TYPE: "EXTERNAL-ADDRESS" >
| < FACT_ADDRESS_TYPE: "FACT-ADDRESS" >
| < ALLOWED_SYMBOLS: "allowed-symbols" >
| < ALLOWED_STRINGS: "allowed-strings" >
| < ALLOWED_LEXEMES: "allowed-lexemes" >
| < ALLOWED_INTEGERS: "allowed-integers" >
| < ALLOWED_FLOATS: "allowed-floats" >
| < ALLOWED_NUMBERS: "allowed-numbers" >
| < ALLOWED_INSTANCES: "allowed-instances" >
| < ALLOWED_CLASSES: "allowed-classes" >
| < ALLOWED_VALUES: "allowed-values" >
| < RANGE: "range" >
| < CARDINALITY: "cardinality" >
| < ROLE: "role" >
| < CONCRETE: "concrete" >
| < ABSTRACT: "abstract" >
| < PATTERN_MATCH: "pattern-match" >
| < REACTIVE: "reactive" >
| < NON_REACTIVE: "non-reactive" >
| < STORAGE: "storage" >
| < LOCAL: "local" >
| < SHARED: "shared" >
| < ACCESS: "access" >
| < READ_WRITE: "read-write" >
| < READ_ONLY: "read-only" >
| < READ: "read" >
| < WRITE: "write" >
| < INITIALIZE_ONLY: "initialize-only" >
| < PROPAGATION: "propagation" >
| < INHERIT: "inherit" >
| < NO_INHERIT: "no-inherit" >
| < SOURCE: "source" >
| < EXCLUSIVE: "exclusive" >
| < COMPOSITE: "composite" >
| < VISIBILITY: "visibility" >
| < PRIVATE: "private" >
| < PUBLIC: "public" >
| < CREATE_ACCESSOR: "create-accessor" >
| < OVERRIDE_MESSAGE: "override-message" >
| < MESSAGE_HANDLER: "message-handler" >
| < PRIMARY: "primary" >
| < AROUND: "around" >
| < BEFORE: "before" >
| < AFTER: "after" >
| < SYMBOL:  
	(~[" ","\r","\n","\t","\"","\'","(",")","&","|","$","?","~",";","0"-"9"])
	|(
		(~[" ","\r","\n","\t","\"","\'","(",")","&","|","?","~",";","["])
		(~[" ","\r","\n","\t","\"","\'","(",")","&","|","?","~",";","0"-"9"])*
		(~[" ","\r","\n","\t","\"","\'","(",")","&","|","<","~",";" ])*
		(~[" ","\r","\n","\t","\"","\'","(",")","&","|","$","?","~",";","]"])? 
	)
	|(
		(~[" ","\r","\n","\t","\"","\'","(",")","&","|","?","~",";"])
		(~[" ","\r","\n","\t","\"","\'","(",")","&","|","?","~",";","0"-"9"])*
		(~[" ","\r","\n","\t","\"","\'","(",")","&","|","<","~",";" ])*
		(~[" ","\r","\n","\t","\"","\'","(",")","&","|","$","?","~",";","]"])+ 
	)
  >

}

/* TODO (From Clips Manual):
Data Types:
<file-name> ::= A symbol or string which is a valid file name (including path information)
	for the operating system under which CLIPS is running
<slot-name> ::= A valid deftemplate_construct slot name
<...-name> ::= A <symbol> where the ellipsis indicate what the symbol represents.
	For example, <rule-name> is a symbol which represents the name of a rule.
*/

/**********************************************
 * Clips Grammar Specs.
 * Main grammar, contains Input function
 */

/* TODO (From Clips Manual):
Variables and Expressions
<...-expression> ::= An <expression> which returns the type indicated by the
	ellipsis. For example, <integer-expression> should return an integer.
*/

/* Constructs

Defmessage-handler Construct
<defmessage-handler-construct> 
	::= (defmessage-handler <class-name> <message-name> [<handler-type>] 
		[<comment>] (<parameter>* [<wildcard-parameter>]) <action>*)
<handler-type> ::= around | before | primary | after
<parameter> ::= <single-field-variable>
<wildcard-parameter> ::= <multifield-variable>

Definstances Construct
<definstances-construct> ::= (definstances <definstances-name> [active] [<comment>] <instance-template>*)
<instance-template> ::= (<instance-definition>)
<instance-definition> ::= <instance-name-expression> of <class-name-expression> <slot-override>*
<slot-override> ::= (<slot-name-expression> <expression>*)

Defmodule Construct
<defmodule-construct> ::= (defmodule <module-name> [<comment>] <port-specification>*)
<port-specification> ::= (export <port-item>) | (import <module-name> <port-item>)
<port-item> ::= ?ALL | ?NONE | <port-construct> ?ALL | 
	<port-construct> ?NONE | <port-construct> <construct-name>+
<port-construct> ::= deftemplate_construct | defclass | defglobal | deffunction | defgeneric
*/

/** Start rule is one construct at a time, Parser reads constructs into list.
	No need to create nodes for Start, Defcon and Funcon rule.*/
COOLStart Start() : {/*@bgen(jjtree) Start */
  COOLStart jjtn000 = new COOLStart(this, JJTSTART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Start */
        try {
/*@egen*/
	( LOOKAHEAD(2)
	   Construct() | Expression()
	)/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


/*
<number> ::= <float> | <integer> 
<lexeme> ::= <symbol> | <string>
<constant> ::= <symbol> | <string> | <integer> | <float> | <instance-name>
*/

void Float() : {/*@bgen(jjtree) Float */
                 COOLFloat jjtn000 = new COOLFloat(this, JJTFLOAT);
                 boolean jjtc000 = true;
                 jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) Float */
        try {
/*@egen*/
	t = <FLOAT>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ jjtn000.setName(t.image); }/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


void Integer() : {/*@bgen(jjtree) Integer */
                   COOLInteger jjtn000 = new COOLInteger(this, JJTINTEGER);
                   boolean jjtc000 = true;
                   jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) Integer */
        try {
/*@egen*/
	t = <INTEGER>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ jjtn000.setName(t.image); }/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Number()       : {}
{
	Float() | Integer()
}

void Symbol() : {/*@bgen(jjtree) Symbol */
                  COOLSymbol jjtn000 = new COOLSymbol(this, JJTSYMBOL);
                  boolean jjtc000 = true;
                  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t;}
{/*@bgen(jjtree) Symbol */
        try {
/*@egen*/
	t = <SYMBOL>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ jjtn000.setName(t.image); }/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void String() : {/*@bgen(jjtree) String */
                  COOLString jjtn000 = new COOLString(this, JJTSTRING);
                  boolean jjtc000 = true;
                  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) String */
        try {
/*@egen*/
	t = <STRING>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ jjtn000.setName(t.image); }/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/

}

void Lexeme()       : {}
{	String() | Symbol() }

void Instance() : {/*@bgen(jjtree) Instance */
                    COOLInstance jjtn000 = new COOLInstance(this, JJTINSTANCE);
                    boolean jjtc000 = true;
                    jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) Instance */
        try {
/*@egen*/
	t = <INSTANCE>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ jjtn000.setName(t.image); }/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Constant()      :{}
{ 	Symbol() | String() | Integer() | Float() | Instance() }

void Comment()       : {}
{	
    String()
}

/*
<function-name> ::= Any symbol which corresponds to a system or user defined function, a
	deffunction name, or a defgeneric name
	( Ory: I understand this to be a <SYMBOL> token )
<file-name> ::= A symbol or string which is a valid file name (including path information)
	for the operating system under which CLIPS is running

<variable> ::= <single-field-variable> | <multifield-variable> | <global-variable>
<function-call> ::= (<function-name> <expression>*)
<expression> ::= <constant> | <variable> | <function-call>
<action> ::= <expression>
*/

// This is used exactly then when only the variables value is needed
void SingleVariable() : {/*@bgen(jjtree) SingleVariable */
                          COOLSingleVariable jjtn000 = new COOLSingleVariable(this, JJTSINGLEVARIABLE);
                          boolean jjtc000 = true;
                          jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; } 
{/*@bgen(jjtree) SingleVariable */
        try {
/*@egen*/
	t = <SINGLEVAR>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ jjtn000.setName(t.image); }/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

// This is used exactly then when only the variables value is needed
void GlobalVariable() : {/*@bgen(jjtree) GlobalVariable */
                          COOLGlobalVariable jjtn000 = new COOLGlobalVariable(this, JJTGLOBALVARIABLE);
                          boolean jjtc000 = true;
                          jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; } 
{/*@bgen(jjtree) GlobalVariable */
        try {
/*@egen*/
	t = <GLOBALVAR>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ jjtn000.setName(t.image); }/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

// This is used exactly then when only the variables contents are needed
void MultiVariable() : {/*@bgen(jjtree) MultiVariable */
                         COOLMultiVariable jjtn000 = new COOLMultiVariable(this, JJTMULTIVARIABLE);
                         boolean jjtc000 = true;
                         jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; } 
{/*@bgen(jjtree) MultiVariable */
        try {
/*@egen*/
	t = <MULTIVAR>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ jjtn000.setName(t.image); }/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


// This is used exactly then when only the variables value is needed
void Variable()       : {}
{	SingleVariable() | MultiVariable() | GlobalVariable() }

void FunctionCall() : {/*@bgen(jjtree) FunctionCall */
                        COOLFunctionCall jjtn000 = new COOLFunctionCall(this, JJTFUNCTIONCALL);
                        boolean jjtc000 = true;
                        jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) FunctionCall */
        try {
/*@egen*/
	<LBRACE> 
		t = <SYMBOL>
		{ jjtn000.setName(t.image); }
		(Expression())*
	<RBRACE>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Expression()       : {} 
{	Constant() | Variable() | FunctionCall() }


/** Dummy Defined in CLIPS programmers guide... */
void Action()       : {} {  Expression() }


/** Main Handler for Definition constructs.
	Note it contains the parantheses for the constructs
*/
void Construct()       : {}
{
	<LBRACE>
	(
		DefFactsConstruct()
	|	DefTemplateConstruct()
	|	DefglobalConstruct()
	|	DefruleConstruct()
	|	DeffunctionConstruct()
	|	DefgenericConstruct() 
	|	DefmethodConstruct() 
 	|	DefclassConstruct() 
//	|	DefInstanceConstruct() 
//	|	DefMessageConstruct() 
//	|	DefModuleConstruct() 
	)
	<RBRACE>
}

/* Deffacts construct: <deffacts-construct> ::= (deffacts <deffacts-name> [<comment>] <RHS-pattern>*) */
void DefFactsConstruct() : {/*@bgen(jjtree) DefFactsConstruct */
                             COOLDefFactsConstruct jjtn000 = new COOLDefFactsConstruct(this, JJTDEFFACTSCONSTRUCT);
                             boolean jjtc000 = true;
                             jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) DefFactsConstruct */
        try {
/*@egen*/
	<DEFFACTS>
	t = <SYMBOL>
	{ jjtn000.setName(t.image); }//name
	[
		t = <STRING>
		{ jjtn000.setDocString(t.image); }//comment
	]
	(RHSPattern())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/* Deftemplate construct */

//<deftemplate-construct> ::= (deftemplate <deftemplate-name> [<comment>] <slot-definition>*)
void DefTemplateConstruct() : {/*@bgen(jjtree) DefTemplateConstruct */
                                COOLDefTemplateConstruct jjtn000 = new COOLDefTemplateConstruct(this, JJTDEFTEMPLATECONSTRUCT);
                                boolean jjtc000 = true;
                                jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) DefTemplateConstruct */
        try {
/*@egen*/
        <DEFTEMPLATE>
        t = <SYMBOL>
        { jjtn000.setName(t.image); }
	    [
			t = <STRING>
			{ jjtn000.setDocString(t.image); }
		]
        (SlotDefinition())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//<slot-definition> ::= <single-slot-definition> | <multislot-definition>
void SlotDefinition()       : {}
{
    <LBRACE> ( SingleSlotDefinition() | MultislotDefinition() ) <RBRACE> 
}

//<single-slot-definition> ::= (slot <slot-name> <template-attribute>*)
void SingleSlotDefinition() : {/*@bgen(jjtree) SingleSlotDefinition */
                                COOLSingleSlotDefinition jjtn000 = new COOLSingleSlotDefinition(this, JJTSINGLESLOTDEFINITION);
                                boolean jjtc000 = true;
                                jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) SingleSlotDefinition */
        try {
/*@egen*/
        <SLOT>
        t = <SYMBOL>
        { jjtn000.setName(t.image); }//<slot-name>
        (TemplateAttribute())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//<multislot-definition> ::= (multislot <slot-name> <template-attribute>*)
void MultislotDefinition() : {/*@bgen(jjtree) MultislotDefinition */
                               COOLMultislotDefinition jjtn000 = new COOLMultislotDefinition(this, JJTMULTISLOTDEFINITION);
                               boolean jjtc000 = true;
                               jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) MultislotDefinition */
        try {
/*@egen*/
        <MULTISLOT>
        t = <SYMBOL>
        { jjtn000.setName(t.image); }//<slot-name>
        (TemplateAttribute())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//<template-attribute> ::= <default-attribute> | <constraint-attribute>
void TemplateAttribute()       : {}
{
    DefaultAttribute() | DynamicAttribute() | ConstraintAttribute()
}

//<default-attribute> ::= (default ?DERIVE | ?NONE | <expression>*) | (default-dynamic <expression>*)
/*
void DefaultAttribute() #void : {}
{
    <LBRACE> 
		(DefaultAttribute() | DynamicAttribute() ) 
     <RBRACE>
}
*/
void DefaultAttribute() : {/*@bgen(jjtree) DefaultAttribute */
  COOLDefaultAttribute jjtn000 = new COOLDefaultAttribute(this, JJTDEFAULTATTRIBUTE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) DefaultAttribute */
        try {
/*@egen*/
	<DEFAULT_ATR>
	(
		<ATR_DERIVE>/*@bgen(jjtree)*/
                             {
                               jjtree.closeNodeScope(jjtn000, true);
                               jjtc000 = false;
                             }
/*@egen*/ { jjtn000.setType(COOLDefaultAttribute.T_DERIVE); }
	|	<ATR_NONE>/*@bgen(jjtree)*/
                           {
                             jjtree.closeNodeScope(jjtn000, true);
                             jjtc000 = false;
                           }
/*@egen*/ { jjtn000.setType(COOLDefaultAttribute.T_NONE); }
	|	(LOOKAHEAD(2) Expression())* 
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void DynamicAttribute() : {/*@bgen(jjtree) DynamicAttribute */
  COOLDynamicAttribute jjtn000 = new COOLDynamicAttribute(this, JJTDYNAMICATTRIBUTE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) DynamicAttribute */
        try {
/*@egen*/	
	<DYNAMIC_ATR> 
	(LOOKAHEAD(2) Expression())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ 
}

/* Fact Specification */

//<RHS-pattern> ::= <ordered-RHS-pattern> | <template-RHS-pattern>
void RHSPattern()       : {}
{
    OrderedRHSPattern() | TemplateRHSPattern()
}

//<ordered-RHS-pattern> ::= (<symbol> <RHS-field>+)
void OrderedRHSPattern() : {/*@bgen(jjtree) OrderedRHSPattern */
                             COOLOrderedRHSPattern jjtn000 = new COOLOrderedRHSPattern(this, JJTORDEREDRHSPATTERN);
                             boolean jjtc000 = true;
                             jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t;}
{/*@bgen(jjtree) OrderedRHSPattern */
    try {
/*@egen*/
    t = <SYMBOL>
    { jjtn000.setName(t.image); }
    ( LOOKAHEAD(2) Expression())+/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

//<template-RHS-pattern> ::= (<deftemplate-name> <RHS-slot>*)
void TemplateRHSPattern() : {/*@bgen(jjtree) TemplateRHSPattern */
                              COOLTemplateRHSPattern jjtn000 = new COOLTemplateRHSPattern(this, JJTTEMPLATERHSPATTERN);
                              boolean jjtc000 = true;
                              jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) TemplateRHSPattern */
    try {
/*@egen*/
    <LBRACE>
        t = <SYMBOL>
        { jjtn000.setName(t.image); }//name
        (RHSSlot())*
    <RBRACE>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

//<RHS-slot> ::= <single-field-RHS-slot> | <multifield-RHS-slot>
void RHSSlot()       : {}
{
    <LBRACE> 
		SingleFieldRHSSlot() 
	|	MultifieldRHSSlot()
    <RBRACE>
}

//<single-field-RHS-slot> ::= (<slot-name> <RHS-field>)
void SingleFieldRHSSlot() : {/*@bgen(jjtree) SingleFieldRHSSlot */
                              COOLSingleFieldRHSSlot jjtn000 = new COOLSingleFieldRHSSlot(this, JJTSINGLEFIELDRHSSLOT);
                              boolean jjtc000 = true;
                              jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) SingleFieldRHSSlot */
        try {
/*@egen*/
        t = <SYMBOL>
        { jjtn000.setName(t.image); }//slot-name
        Expression()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//<multifield-RHS-slot> ::= (<slot-name> <RHS-field>*)
void MultifieldRHSSlot() : {/*@bgen(jjtree) MultifieldRHSSlot */
                             COOLMultifieldRHSSlot jjtn000 = new COOLMultifieldRHSSlot(this, JJTMULTIFIELDRHSSLOT);
                             boolean jjtc000 = true;
                             jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) MultifieldRHSSlot */
        try {
/*@egen*/
        t = <SYMBOL>
        { jjtn000.setName(t.image); }//slot-name
        (Expression())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//<RHS-field> ::= <variable> | <constant> | <function-call>
// Same as expression
/*void RHSField() #void : {}
{
    Variable() | Constant() | FunctionCall()
}*/

/* Defrule Construct */

//<defrule-construct> 
//	::= (defrule <rule-name> [<comment>] [<declaration>] <conditional-element>* => <action>*)
void DefruleConstruct() : {/*@bgen(jjtree) DefruleConstruct */
                            COOLDefruleConstruct jjtn000 = new COOLDefruleConstruct(this, JJTDEFRULECONSTRUCT);
                            boolean jjtc000 = true;
                            jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) DefruleConstruct */
  try {
/*@egen*/
  ( //LOOKAHEAD(3)
	<DEFRULE>
	( LOOKAHEAD(2)
		( 
			t = <SYMBOL>
			{ jjtn000.setName(t.image); }//name
		) |	(
			t = <SYMBOL>
			{ jjtn000.setName(t.image); }//name
			t = <STRING>
			{ jjtn000.setDocString(t.image); }	
		)
	)
	( LOOKAHEAD(2)
		(
			Declaration()
			CEList()
		) |
		(
			CEList()
		)
	)
	<ARROW>
	ActionList()
  )/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

// Create Dummy node to have fixed number of chlidren in Defrule
void CEList():{/*@bgen(jjtree) CEList */
  COOLCEList jjtn000 = new COOLCEList(this, JJTCELIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) CEList */
                   try {
/*@egen*/ (ConditionalElement())*/*@bgen(jjtree)*/
                   } catch (Throwable jjte000) {
                     if (jjtc000) {
                       jjtree.clearNodeScope(jjtn000);
                       jjtc000 = false;
                     } else {
                       jjtree.popNode();
                     }
                     if (jjte000 instanceof RuntimeException) {
                       throw (RuntimeException)jjte000;
                     }
                     if (jjte000 instanceof ParseException) {
                       throw (ParseException)jjte000;
                     }
                     throw (Error)jjte000;
                   } finally {
                     if (jjtc000) {
                       jjtree.closeNodeScope(jjtn000, true);
                     }
                   }
/*@egen*/ }

// Create Dummy node to have fixed number of chlidren in Defrule
void ActionList():{/*@bgen(jjtree) ActionList */
  COOLActionList jjtn000 = new COOLActionList(this, JJTACTIONLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) ActionList */
                       try {
/*@egen*/ (Expression())*/*@bgen(jjtree)*/
                       } catch (Throwable jjte000) {
                         if (jjtc000) {
                           jjtree.clearNodeScope(jjtn000);
                           jjtc000 = false;
                         } else {
                           jjtree.popNode();
                         }
                         if (jjte000 instanceof RuntimeException) {
                           throw (RuntimeException)jjte000;
                         }
                         if (jjte000 instanceof ParseException) {
                           throw (ParseException)jjte000;
                         }
                         throw (Error)jjte000;
                       } finally {
                         if (jjtc000) {
                           jjtree.closeNodeScope(jjtn000, true);
                         }
                       }
/*@egen*/ }

// Create Dummy node to have fixed number of chlidren later
void CEList2():{/*@bgen(jjtree) CEList2 */
  COOLCEList2 jjtn000 = new COOLCEList2(this, JJTCELIST2);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) CEList2 */
                    try {
/*@egen*/ (ConditionalElement())+/*@bgen(jjtree)*/
                    } catch (Throwable jjte000) {
                      if (jjtc000) {
                        jjtree.clearNodeScope(jjtn000);
                        jjtc000 = false;
                      } else {
                        jjtree.popNode();
                      }
                      if (jjte000 instanceof RuntimeException) {
                        throw (RuntimeException)jjte000;
                      }
                      if (jjte000 instanceof ParseException) {
                        throw (ParseException)jjte000;
                      }
                      throw (Error)jjte000;
                    } finally {
                      if (jjtc000) {
                        jjtree.closeNodeScope(jjtn000, true);
                      }
                    }
/*@egen*/ }

//<declaration> ::= (declare <rule-property>+)
void Declaration() : {/*@bgen(jjtree) Declaration */
  COOLDeclaration jjtn000 = new COOLDeclaration(this, JJTDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Declaration */
    try {
/*@egen*/
    <LBRACE>
        <DECLARE>
        (RuleProperty())+
    <RBRACE>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

//<rule-property> ::= (salience <integer-expression>) | (auto-focus <boolean-symbol>)
void RuleProperty() : {/*@bgen(jjtree) RuleProperty */
  COOLRuleProperty jjtn000 = new COOLRuleProperty(this, JJTRULEPROPERTY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) RuleProperty */
    try {
/*@egen*/
    <LBRACE> (
		(  <SALIENCE>
			//todo:        <integer-expression>
			// Ory: Just use expression and check for it being an integer at runtime (it could use global variables)
			Expression()
		)
		{ // Set node type to salience, 
		}
     | 
		(  <AUTOFOCUS> BooleanSymbol() )
		{ // Set node type to auto-focus, 
		}
	) <RBRACE>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

//<boolean-symbol> ::= TRUE | FALSE
void BooleanSymbol() : {/*@bgen(jjtree) BooleanSymbol */
                         COOLBooleanSymbol jjtn000 = new COOLBooleanSymbol(this, JJTBOOLEANSYMBOL);
                         boolean jjtc000 = true;
                         jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t;}
{/*@bgen(jjtree) BooleanSymbol */
    try {
/*@egen*/
    ( t = <TRUE> )/*@bgen(jjtree)*/
                   {
                     jjtree.closeNodeScope(jjtn000, true);
                     jjtc000 = false;
                   }
/*@egen*/ { jjtn000.setName(t.image); jjtn000.setToTrue();}
    |
    ( t = <FALSE> )/*@bgen(jjtree)*/
                    {
                      jjtree.closeNodeScope(jjtn000, true);
                      jjtc000 = false;
                    }
/*@egen*/ { jjtn000.setName(t.image); jjtn000.setToFalse(); }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

//<conditional-element> ::= <pattern-CE> | <assigned-pattern-CE> | <not-CE> | <and-CE> | <or-CE> |
//                          <logical-CE> | <test-CE> | <exists-CE> | <forall-CE>
void ConditionalElement()       : {}
{
	<LBRACE> 
		(
		PatternCE() | AssignedPatternCE() | 
		BooleanFunction() |LogicalCE() |
		TestCE() | ExistsCE() | ForallCE()
		)
	<RBRACE>
	
}

void BooleanFunction() : {/*@bgen(jjtree) BooleanFunction */
  COOLBooleanFunction jjtn000 = new COOLBooleanFunction(this, JJTBOOLEANFUNCTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) BooleanFunction */
                try {
/*@egen*/
		(	// Unary operators
			<NOT> { jjtn000.setType(COOLBooleanFunction.OP_NOT); }
			ConditionalElement() 
		)
	|	(	// non-Unary operators
			<AND>/*@bgen(jjtree)*/
                              {
                                jjtree.closeNodeScope(jjtn000, true);
                                jjtc000 = false;
                              }
/*@egen*/ { jjtn000.setType(COOLBooleanFunction.OP_AND); }
		|	<OR> { jjtn000.setType(COOLBooleanFunction.OP_OR); }
      
			(ConditionalElement())+ 
		)/*@bgen(jjtree)*/
                } catch (Throwable jjte000) {
                  if (jjtc000) {
                    jjtree.clearNodeScope(jjtn000);
                    jjtc000 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte000 instanceof RuntimeException) {
                    throw (RuntimeException)jjte000;
                  }
                  if (jjte000 instanceof ParseException) {
                    throw (ParseException)jjte000;
                  }
                  throw (Error)jjte000;
                } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                  }
                }
/*@egen*/
}

//<pattern-CE> ::= <ordered-pattern-CE> | <template-pattern-CE> | <object-pattern-CE>
void PatternCE()       : {}
{
	( LOOKAHEAD(2) OrderedPatternCE() | TemplatePatternCE() | ObjectPatternCE() )
}

//<assigned-pattern-CE> ::= <single-field-variable> <- <pattern-CE>
void AssignedPatternCE() : {/*@bgen(jjtree) AssignedPatternCE */
  COOLAssignedPatternCE jjtn000 = new COOLAssignedPatternCE(this, JJTASSIGNEDPATTERNCE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) AssignedPatternCE */
    try {
/*@egen*/
    SingleVariable() 
    <ASSIGN>
    PatternCE()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}


//<logical-CE> ::= (logical <conditional-element>+)
void LogicalCE() : {/*@bgen(jjtree) LogicalCE */
  COOLLogicalCE jjtn000 = new COOLLogicalCE(this, JJTLOGICALCE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) LogicalCE */
    try {
/*@egen*/
    <LOGICAL> (ConditionalElement())+/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/ 
}

//<test-CE> ::= (test <function-call>)
void TestCE() : {/*@bgen(jjtree) TestCE */
  COOLTestCE jjtn000 = new COOLTestCE(this, JJTTESTCE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) TestCE */
    try {
/*@egen*/
    <TEST> FunctionCall()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

//<exists-CE> ::= (exists <conditional-element>+)
void ExistsCE() : {/*@bgen(jjtree) ExistsCE */
  COOLExistsCE jjtn000 = new COOLExistsCE(this, JJTEXISTSCE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ExistsCE */
    try {
/*@egen*/
    <EXISTS> (ConditionalElement())+/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

//<forall-CE> ::= (forall <conditional-element> <conditional-element>+)
void ForallCE() : {/*@bgen(jjtree) ForallCE */
  COOLForallCE jjtn000 = new COOLForallCE(this, JJTFORALLCE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ForallCE */
        try {
/*@egen*/
	<FORALL> ConditionalElement() CEList2()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//<ordered-pattern-CE> ::= (<symbol> <constraint>*)
void OrderedPatternCE() : {/*@bgen(jjtree) OrderedPatternCE */
                            COOLOrderedPatternCE jjtn000 = new COOLOrderedPatternCE(this, JJTORDEREDPATTERNCE);
                            boolean jjtc000 = true;
                            jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) OrderedPatternCE */
        try {
/*@egen*/
        t = <SYMBOL>
        { jjtn000.setName(t.image); }
        (Constraint())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//<template-pattern-CE> ::= (<deftemplate-name> <LHS-slot>*)
void TemplatePatternCE() : {/*@bgen(jjtree) TemplatePatternCE */
                             COOLTemplatePatternCE jjtn000 = new COOLTemplatePatternCE(this, JJTTEMPLATEPATTERNCE);
                             boolean jjtc000 = true;
                             jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) TemplatePatternCE */
        try {
/*@egen*/
        t = <SYMBOL>
        { jjtn000.setName(t.image); }	//deftemplate-name
        (LHSSlot())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//<object-pattern-CE> ::= (object <attribute-constraint>*)
void ObjectPatternCE() : {/*@bgen(jjtree) ObjectPatternCE */
  COOLObjectPatternCE jjtn000 = new COOLObjectPatternCE(this, JJTOBJECTPATTERNCE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ObjectPatternCE */
        try {
/*@egen*/
        <OBJECT>
        (AttributeConstraint())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//<attribute-constraint> ::= (is-a <constraint>) | (name <constraint>) | (<slot-name> <constraint>*)
void AttributeConstraint() : {/*@bgen(jjtree) AttributeConstraint */
                               COOLAttributeConstraint jjtn000 = new COOLAttributeConstraint(this, JJTATTRIBUTECONSTRAINT);
                               boolean jjtc000 = true;
                               jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) AttributeConstraint */
    try {
/*@egen*/
    <LBRACE>
        ( 
		  (	<IS_A> { jjtn000.setType(COOLAttributeConstraint.T_ISA); }
		|	<NAME> { jjtn000.setType(COOLAttributeConstraint.T_NAME); }
		  )
		  Constraint() 
		)| (
          t = <SYMBOL> { jjtn000.setType(COOLAttributeConstraint.T_SYMBOL); jjtn000.setName(t.image); }
          (Constraint())* )
    <RBRACE>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

// Functionally identical
//<single-field-LHS-slot> ::= (<slot-name> <constraint>)
//<multifield-LHS-slot> ::= (<slot-name> <constraint>*)
//<LHS-slot> ::= <single-field-LHS-slot> | <multifield-LHS-slot>
void LHSSlot() : {/*@bgen(jjtree) LHSSlot */
                   COOLLHSSlot jjtn000 = new COOLLHSSlot(this, JJTLHSSLOT);
                   boolean jjtc000 = true;
                   jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) LHSSlot */
    try {
/*@egen*/
    <LBRACE>
        t = <SYMBOL>
        { jjtn000.setName(t.image); }	//slot-name
		(Constraint())*

	<RBRACE>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

//<constraint> ::= ? | $? | <connected-constraint>
void Constraint()       : {}
{
    SingleFieldWildcard() | MultiFieldWildcard() | ConnectedConstraint()
}

void SingleFieldWildcard() : {/*@bgen(jjtree) SingleFieldWildcard */
  COOLSingleFieldWildcard jjtn000 = new COOLSingleFieldWildcard(this, JJTSINGLEFIELDWILDCARD);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) SingleFieldWildcard */
                                  try {
/*@egen*/ <SFWILDCARD>/*@bgen(jjtree)*/
                                  } finally {
                                    if (jjtc000) {
                                      jjtree.closeNodeScope(jjtn000, true);
                                    }
                                  }
/*@egen*/ }
void MultiFieldWildcard() : {/*@bgen(jjtree) MultiFieldWildcard */
  COOLMultiFieldWildcard jjtn000 = new COOLMultiFieldWildcard(this, JJTMULTIFIELDWILDCARD);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) MultiFieldWildcard */
                                 try {
/*@egen*/ <MFWILDCARD>/*@bgen(jjtree)*/
                                 } finally {
                                   if (jjtc000) {
                                     jjtree.closeNodeScope(jjtn000, true);
                                   }
                                 }
/*@egen*/ }

//<connected-constraint>::= <single-constraint> | <single-constraint> & <connected-constraint> |
//	<single-constraint> | <connected-constraint>
void ConnectedConstraint() : {/*@bgen(jjtree) ConnectedConstraint */
  COOLConnectedConstraint jjtn000 = new COOLConnectedConstraint(this, JJTCONNECTEDCONSTRAINT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ConnectedConstraint */
  try {
/*@egen*/
  ( 
		Term() { jjtn000.setType(COOLConnectedConstraint.T_SINGLE); }
		(	
			(( <AMPERSAND> Term()) + )/*@bgen(jjtree)*/
                                                   {
                                                     jjtree.closeNodeScope(jjtn000, true);
                                                     jjtc000 = false;
                                                   }
/*@egen*/ { jjtn000.setType(COOLConnectedConstraint.T_AND); } 
		|	(( <LINE> Term()) + )/*@bgen(jjtree)*/
                                              {
                                                jjtree.closeNodeScope(jjtn000, true);
                                                jjtc000 = false;
                                              }
/*@egen*/ { jjtn000.setType(COOLConnectedConstraint.T_OR); }
		) 
  )/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

//<term> ::= <constant> | <single-field-variable> | <multifield-variable> | 
//	:<function-call> | =<function-call>
void Term() : {/*@bgen(jjtree) Term */
  COOLTerm jjtn000 = new COOLTerm(this, JJTTERM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Term */
    try {
/*@egen*/
/*	[	<TILDE>	{ jjtThis.setNegate(true); }
	] */
    ( LOOKAHEAD(3)
		Constant()/*@bgen(jjtree)*/
                           {
                             jjtree.closeNodeScope(jjtn000, true);
                             jjtc000 = false;
                           }
/*@egen*/ { jjtn000.setType(COOLTerm.T_CONST); }
    |	SingleVariable()/*@bgen(jjtree)*/
                         {
                           jjtree.closeNodeScope(jjtn000, true);
                           jjtc000 = false;
                         }
/*@egen*/ { jjtn000.setType(COOLTerm.T_SINGLE); }
    |	MultiVariable()/*@bgen(jjtree)*/
                        {
                          jjtree.closeNodeScope(jjtn000, true);
                          jjtc000 = false;
                        }
/*@egen*/ { jjtn000.setType(COOLTerm.T_MULTI); }
    |	(<COLON> FunctionCall() )/*@bgen(jjtree)*/
                                  {
                                    jjtree.closeNodeScope(jjtn000, true);
                                    jjtc000 = false;
                                  }
/*@egen*/ { jjtn000.setType(COOLTerm.T_COLON); }
    |	(<EQUALS> FunctionCall() )/*@bgen(jjtree)*/
                                   {
                                     jjtree.closeNodeScope(jjtn000, true);
                                     jjtc000 = false;
                                   }
/*@egen*/ { jjtn000.setType(COOLTerm.T_EQ); } 
    )/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/* Defglobal Construct */

//<defglobal-construct> ::= (defglobal [<defmodule-name>] <global-assignment>*)
void DefglobalConstruct() : {/*@bgen(jjtree) DefglobalConstruct */
                              COOLDefglobalConstruct jjtn000 = new COOLDefglobalConstruct(this, JJTDEFGLOBALCONSTRUCT);
                              boolean jjtc000 = true;
                              jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) DefglobalConstruct */
        try {
/*@egen*/
        <DEFGLOBAL>
        [ 
            t = <SYMBOL>
            { jjtn000.setName(t.image); }	//defmodule-name 
        ]
        (GlobalAssignment())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//<global-assignment> ::= <global-variable> = <expression>
void GlobalAssignment() : {/*@bgen(jjtree) GlobalAssignment */
                            COOLGlobalAssignment jjtn000 = new COOLGlobalAssignment(this, JJTGLOBALASSIGNMENT);
                            boolean jjtc000 = true;
                            jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) GlobalAssignment */
        try {
/*@egen*/
	t = <GLOBALVAR>
	{ jjtn000.setName(t.image); }	// Needs to access variable not just read the value
    <EQUALS>
    Expression()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/* Deffunction Construct */

//<deffunction-construct> 
//	::= (deffunction <name> [<comment>] (<regular-parameter>* [<wildcard-parameter>]) <action>*)
void DeffunctionConstruct() : {/*@bgen(jjtree) DeffunctionConstruct */
                                COOLDeffunctionConstruct jjtn000 = new COOLDeffunctionConstruct(this, JJTDEFFUNCTIONCONSTRUCT);
                                boolean jjtc000 = true;
                                jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) DeffunctionConstruct */
        try {
/*@egen*/
        <DEFFUNCTION>
        t = <SYMBOL>
        { jjtn000.setName(t.image); }//name
        [ t = <STRING> 
			{ jjtn000.setDocString(t.image); }
        ]
        <LBRACE> ParameterList() [ MultiVariable() ] <RBRACE>
        ActionList()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//<regular-parameter> ::= <single-field-variable>
void ParameterList() : {/*@bgen(jjtree) ParameterList */
  COOLParameterList jjtn000 = new COOLParameterList(this, JJTPARAMETERLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ParameterList */
    try {
/*@egen*/
    (SingleVariable())*/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/* Ignored, produces multifield variable directly
//<wildcard-parameter> ::= <multifield-variable>
void WildcardParameter()  #void : {}
{
    MultiVariable()
}
*/

/* Defgeneric Construct */

//<defgeneric-construct> ::= (defgeneric <name> [<comment>])
void DefgenericConstruct() : {/*@bgen(jjtree) DefgenericConstruct */
                               COOLDefgenericConstruct jjtn000 = new COOLDefgenericConstruct(this, JJTDEFGENERICCONSTRUCT);
                               boolean jjtc000 = true;
                               jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) DefgenericConstruct */
        try {
/*@egen*/
        <DEFGENERIC>
        t = <SYMBOL>
        { jjtn000.setName(t.image); }	//name
        [ t = <STRING>
			{ jjtn000.setDocString(t.image); }
        ]/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/* Defmethod Construct */

//<defmethod-construct> ::= (defmethod <name> [<index>] [<comment>] (<parameter-restriction>*
//	[<wildcard-parameter-restriction>]) <action>*)
void DefmethodConstruct() : {/*@bgen(jjtree) DefmethodConstruct */
                              COOLDefmethodConstruct jjtn000 = new COOLDefmethodConstruct(this, JJTDEFMETHODCONSTRUCT);
                              boolean jjtc000 = true;
                              jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) DefmethodConstruct */
        try {
/*@egen*/
	<DEFMETHOD>
	t = <SYMBOL>
	{ jjtn000.setName(t.image); }//name
	[
		t = <INTEGER>
		{ jjtn000.setIndex(t.image); }//method index (cf. clipsbasic programmers guide section 8.4.2)
	]
	[
		t = <STRING>
		{ jjtn000.setDocString(t.image); }//comment
	]
	<LBRACE>
		(ParameterRestriction())*
		[ WildcardParameterRestriction() ]
	<RBRACE>
    ActionList()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//<parameter-restriction> ::= <single-field-variable> | (<single-field-variable> <type>* [<query>])
void ParameterRestriction() : {/*@bgen(jjtree) ParameterRestriction */
  COOLParameterRestriction jjtn000 = new COOLParameterRestriction(this, JJTPARAMETERRESTRICTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ParameterRestriction */
        try {
/*@egen*/
	( LOOKAHEAD(2)
		(
			SingleVariable()
		) |
		(
			SingleVariable()
			<LBRACE>
				SingleVariable() (Type())* [Query()]
			<RBRACE>
		)
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//<wildcard-parameter-restriction> ::= <multifield-variable> | (<multifield-variable> <type>* [<query>])
void WildcardParameterRestriction() : {/*@bgen(jjtree) WildcardParameterRestriction */
  COOLWildcardParameterRestriction jjtn000 = new COOLWildcardParameterRestriction(this, JJTWILDCARDPARAMETERRESTRICTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) WildcardParameterRestriction */
        try {
/*@egen*/
	( LOOKAHEAD(2)
		(
			MultiVariable()
		) |
		(
			MultiVariable()
			<LBRACE>
				MultiVariable() (Type())* [Query()]
			<RBRACE>
		)
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//<type> ::= <class-name>
void Type() : {/*@bgen(jjtree) Type */
                COOLType jjtn000 = new COOLType(this, JJTTYPE);
                boolean jjtc000 = true;
                jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) Type */
        try {
/*@egen*/
	t = <SYMBOL>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ jjtn000.setName(t.image); }/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*///class-name
}

//<query> ::= <global-variable> | <function-call>
void Query() : {/*@bgen(jjtree) Query */
                 COOLQuery jjtn000 = new COOLQuery(this, JJTQUERY);
                 boolean jjtc000 = true;
                 jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) Query */
        try {
/*@egen*/
	t = <GLOBALVAR>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ jjtn000.setName(t.image); }//global-variable
	|
	FunctionCall()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/* Defclass Construct */

//<defclass-construct> ::= (defclass <name> [<comment>] (is-a <superclass-name>+)
//	[<role>] [<pattern-match-role>] <slot>* <handler-documentation>*)
void DefclassConstruct() : {/*@bgen(jjtree) DefclassConstruct */
                             COOLDefclassConstruct jjtn000 = new COOLDefclassConstruct(this, JJTDEFCLASSCONSTRUCT);
                             boolean jjtc000 = true;
                             jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) DefclassConstruct */
        try {
/*@egen*/
	<DEFCLASS>
	t = <SYMBOL>
	{ jjtn000.setName(t.image); }//name
	[
		t = <STRING>
		{ jjtn000.setName(t.image); }//comment
	]
	<LBRACE>
		<IS_A>
		(
			t = <SYMBOL>
			{ jjtn000.addClassname(t.image); }//superclass-name
		)+
	<RBRACE>
	[ LOOKAHEAD(2) Role() ]
	[ LOOKAHEAD(2) PatternMatchRole() ]
	( LOOKAHEAD(2) Slot() )*
	( LOOKAHEAD(2) HandlerDocumentation() )*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//<role> ::= (role concrete | abstract)
void Role() : {/*@bgen(jjtree) Role */
  COOLRole jjtn000 = new COOLRole(this, JJTROLE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Role */
        try {
/*@egen*/
	<LBRACE>
		<ROLE> <CONCRETE> | <ABSTRACT>
	<RBRACE>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//<pattern-match-role> ::= (pattern-match reactive | non-reactive)
void PatternMatchRole() : {/*@bgen(jjtree) PatternMatchRole */
  COOLPatternMatchRole jjtn000 = new COOLPatternMatchRole(this, JJTPATTERNMATCHROLE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) PatternMatchRole */
        try {
/*@egen*/
	<LBRACE>
		<PATTERN_MATCH> <REACTIVE> | <NON_REACTIVE>
	<RBRACE>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//<slot> ::= (slot <name> <facet>*) | (single-slot <name> <facet>*) | (multislot <name> <facet>*)
void Slot() : {/*@bgen(jjtree) Slot */
                COOLSlot jjtn000 = new COOLSlot(this, JJTSLOT);
                boolean jjtc000 = true;
                jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) Slot */
        try {
/*@egen*/
	<LBRACE>
		(
			<SLOT> | <SINGLE_SLOT> | <MULTISLOT>
		)
		t = <SYMBOL>
		{ jjtn000.setName(t.image); }
		( Facet() )*
	<RBRACE>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//<facet> ::= <default-facet> | <storage-facet> | <access-facet> | <propagation-facet> | 
//	<source-facet> | <pattern-match-facet> | <visibility-facet> | 
//	<create-accessor-facet> <override-message-facet> | <constraint-attribute>
void Facet()       : {}
{
	<LBRACE> //facets all have brackets
		( LOOKAHEAD(2)
			DefaultFacet() | StorageFacet() | AccessFacet() | PropagationFacet() |
			SourceFacet() | PatternMatchFacet() | VisibilityFacet() |
			CreateAccessorFacet() <RBRACE> <LBRACE> OverrideMessageFacet() |
			ConstraintAttribute()
		)
	<RBRACE>
}

//<default-facet> ::= (default ?DERIVE | ?NONE | <expression>*) | (default-dynamic <expression>*)
void DefaultFacet() : {/*@bgen(jjtree) DefaultFacet */
  COOLDefaultFacet jjtn000 = new COOLDefaultFacet(this, JJTDEFAULTFACET);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) DefaultFacet */
        try {
/*@egen*/
	( <DEFAULT_ATR> <ATR_DERIVE> | <ATR_NONE> | (Expression())* ) |
	( <DYNAMIC_ATR> (Expression())* )/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//<storage-facet> ::= (storage local | shared)
void StorageFacet() : {/*@bgen(jjtree) StorageFacet */
  COOLStorageFacet jjtn000 = new COOLStorageFacet(this, JJTSTORAGEFACET);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) StorageFacet */
        try {
/*@egen*/
	<STORAGE> <LOCAL> | <SHARED>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}
	
//<access-facet> ::= (access read-write | read-only | initialize-only)
void AccessFacet() : {/*@bgen(jjtree) AccessFacet */
  COOLAccessFacet jjtn000 = new COOLAccessFacet(this, JJTACCESSFACET);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) AccessFacet */
        try {
/*@egen*/
	<ACCESS> <READ_WRITE> | <READ_ONLY> | <INITIALIZE_ONLY>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//<propagation-facet> ::= (propagation inherit | no-inherit)
void PropagationFacet() : {/*@bgen(jjtree) PropagationFacet */
  COOLPropagationFacet jjtn000 = new COOLPropagationFacet(this, JJTPROPAGATIONFACET);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) PropagationFacet */
        try {
/*@egen*/
	<PROPAGATION> <INHERIT> | <NO_INHERIT>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//<source-facet> ::= (source exclusive | composite)
void SourceFacet() : {/*@bgen(jjtree) SourceFacet */
  COOLSourceFacet jjtn000 = new COOLSourceFacet(this, JJTSOURCEFACET);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) SourceFacet */
        try {
/*@egen*/
	<SOURCE> <EXCLUSIVE> | <COMPOSITE>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//<pattern-match-facet> ::= (pattern-match reactive | non-reactive)
void PatternMatchFacet() : {/*@bgen(jjtree) PatternMatchFacet */
  COOLPatternMatchFacet jjtn000 = new COOLPatternMatchFacet(this, JJTPATTERNMATCHFACET);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) PatternMatchFacet */
        try {
/*@egen*/
	<PATTERN_MATCH> <REACTIVE> | <NON_REACTIVE>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//<visibility-facet> ::= (visibility private | public)
void VisibilityFacet() : {/*@bgen(jjtree) VisibilityFacet */
  COOLVisibilityFacet jjtn000 = new COOLVisibilityFacet(this, JJTVISIBILITYFACET);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) VisibilityFacet */
        try {
/*@egen*/
	<VISIBILITY> <PRIVATE> | <PUBLIC>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//<create-accessor-facet> ::= (create-accessor ?NONE | read | write | read-write)
void CreateAccessorFacet() : {/*@bgen(jjtree) CreateAccessorFacet */
  COOLCreateAccessorFacet jjtn000 = new COOLCreateAccessorFacet(this, JJTCREATEACCESSORFACET);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) CreateAccessorFacet */
        try {
/*@egen*/
	<CREATE_ACCESSOR> <ATR_NONE> | <READ> | <WRITE> | <READ_WRITE>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//<override-message-facet> ::= (override-message ?DEFAULT | <message-name>)
void OverrideMessageFacet() : {/*@bgen(jjtree) OverrideMessageFacet */
                                COOLOverrideMessageFacet jjtn000 = new COOLOverrideMessageFacet(this, JJTOVERRIDEMESSAGEFACET);
                                boolean jjtc000 = true;
                                jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) OverrideMessageFacet */
        try {
/*@egen*/
	<OVERRIDE_MESSAGE> <ATR_DEFAULT> |
	t = <SYMBOL>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ jjtn000.setName(t.image); }/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*///name
}

//<handler-documentation> ::= (message-handler <name> [<handler-type>])
void HandlerDocumentation() : {/*@bgen(jjtree) HandlerDocumentation */
                                COOLHandlerDocumentation jjtn000 = new COOLHandlerDocumentation(this, JJTHANDLERDOCUMENTATION);
                                boolean jjtc000 = true;
                                jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) HandlerDocumentation */
        try {
/*@egen*/
	<MESSAGE_HANDLER>
	t = <SYMBOL>
	{ jjtn000.setName(t.image); }//name
	[ HandlerType() ]/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//<handler-type> ::= primary | around | before | after
void HandlerType() : {/*@bgen(jjtree) HandlerType */
                       COOLHandlerType jjtn000 = new COOLHandlerType(this, JJTHANDLERTYPE);
                       boolean jjtc000 = true;
                       jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) HandlerType */
        try {
/*@egen*/
	<PRIMARY> | <AROUND> | <BEFORE> | <AFTER>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/* constraint Attributes */

//<constraint-attribute> ::= <type-attribute> | <allowed-constant-attribute> | 
//	<range-attribute> | <cardinality-attribute>
void ConstraintAttribute() : {/*@bgen(jjtree) ConstraintAttribute */
  COOLConstraintAttribute jjtn000 = new COOLConstraintAttribute(this, JJTCONSTRAINTATTRIBUTE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ConstraintAttribute */
        try {
/*@egen*/
	<LBRACE> //brackets for all productions below
	( LOOKAHEAD(2)
		TypeAttribute() | AllowedConstantAttribute() |
		RangeAttribute() | CardinalityAttribute()
	)
	<RBRACE>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//<type-attribute> ::= (type <type-specification>)
void TypeAttribute() : {/*@bgen(jjtree) TypeAttribute */
  COOLTypeAttribute jjtn000 = new COOLTypeAttribute(this, JJTTYPEATTRIBUTE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) TypeAttribute */
        try {
/*@egen*/
	<TYPE> TypeSpecification()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//<type-specification> ::= <allowed-type>+ | ?VARIABLE
void TypeSpecification() : {/*@bgen(jjtree) TypeSpecification */
  COOLTypeSpecification jjtn000 = new COOLTypeSpecification(this, JJTTYPESPECIFICATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) TypeSpecification */
                try {
/*@egen*/
		(AllowedType())+ | <VARIABLE_TYPE>/*@bgen(jjtree)*/
                } catch (Throwable jjte000) {
                  if (jjtc000) {
                    jjtree.clearNodeScope(jjtn000);
                    jjtc000 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte000 instanceof RuntimeException) {
                    throw (RuntimeException)jjte000;
                  }
                  if (jjte000 instanceof ParseException) {
                    throw (ParseException)jjte000;
                  }
                  throw (Error)jjte000;
                } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                  }
                }
/*@egen*/
}

//<allowed-type> ::= SYMBOL | STRING | LEXEME | INTEGER | FLOAT | NUMBER |
//	INSTANCE-NAME | INSTANCE-ADDRESS | INSTANCE | EXTERNAL-ADDRESS | FACT-ADDRESS
void AllowedType()       : {}
{
	<SYMBOL_TYPE> | <STRING_TYPE> | <LEXEME_TYPE> | <INTEGER_TYPE> | <FLOAT_TYPE> | <NUMBER_TYPE> |
	<INSTANCE_NAME_TYPE> | <INSTANCE_ADDRESS_TYPE> | <INSTANCE_TYPE> | <EXTERNAL_ADDRESS_TYPE> | <FACT_ADDRESS_TYPE>
}

//<allowed-constant-attribute> ::= (allowed-symbols <symbol-list>) | (allowed-strings <string-list>) |
//	(allowed-lexemes <lexeme-list> | (allowed-integers <integer-list>) | (allowed-floats <float-list>) |
//	(allowed-numbers <number-list>) | (allowed-instance-names <instance-list>) |
//	(allowed-classes <class-name-list>) | (allowed-values <value-list>)
void AllowedConstantAttribute() : {/*@bgen(jjtree) AllowedConstantAttribute */
  COOLAllowedConstantAttribute jjtn000 = new COOLAllowedConstantAttribute(this, JJTALLOWEDCONSTANTATTRIBUTE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) AllowedConstantAttribute */
        try {
/*@egen*/
	(
		<ALLOWED_SYMBOLS> SymbolList()		|
		<ALLOWED_STRINGS> StringList()		|
		<ALLOWED_LEXEMES> LexemeList()		|
		<ALLOWED_INTEGERS> IntegerList()	|
		<ALLOWED_FLOATS> FloatList()		|
		<ALLOWED_NUMBERS> NumberList()		|
		<ALLOWED_INSTANCES> InstanceList()	|
		<ALLOWED_CLASSES> ClassNameList()	|
		<ALLOWED_VALUES> ValueList()		
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//<symbol-list> ::= <symbol>+ | ?VARIABLE
void SymbolList() : {/*@bgen(jjtree) SymbolList */
  COOLSymbolList jjtn000 = new COOLSymbolList(this, JJTSYMBOLLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) SymbolList */
        try {
/*@egen*/
	(<SYMBOL>)+ | <VARIABLE_TYPE>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//<string-list> ::= <string>+ | ?VARIABLE
void StringList() : {/*@bgen(jjtree) StringList */
  COOLStringList jjtn000 = new COOLStringList(this, JJTSTRINGLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) StringList */
        try {
/*@egen*/
	(<STRING>)+ | <VARIABLE_TYPE>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//<lexeme-list> ::= <lexeme>+ | ?VARIABLE
void LexemeList() : {/*@bgen(jjtree) LexemeList */
  COOLLexemeList jjtn000 = new COOLLexemeList(this, JJTLEXEMELIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) LexemeList */
        try {
/*@egen*/
	(Lexeme())+ | <VARIABLE_TYPE>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//<integer-list> ::= <integer>+ | ?VARIABLE
void IntegerList() : {/*@bgen(jjtree) IntegerList */
  COOLIntegerList jjtn000 = new COOLIntegerList(this, JJTINTEGERLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) IntegerList */
        try {
/*@egen*/
	(<INTEGER>)+ | <VARIABLE_TYPE>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//<float-list> ::= <float>+ | ?VARIABLE
void FloatList() : {/*@bgen(jjtree) FloatList */
  COOLFloatList jjtn000 = new COOLFloatList(this, JJTFLOATLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) FloatList */
        try {
/*@egen*/
	(<FLOAT>)+ | <VARIABLE_TYPE>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//<number-list> ::= <number>+ | ?VARIABLE
void NumberList() : {/*@bgen(jjtree) NumberList */
  COOLNumberList jjtn000 = new COOLNumberList(this, JJTNUMBERLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) NumberList */
        try {
/*@egen*/
	(Number())+ | <VARIABLE_TYPE>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//<instance-name-list> ::= <instance-name>+ | ?VARIABLE
void InstanceList() : {/*@bgen(jjtree) InstanceList */
  COOLInstanceList jjtn000 = new COOLInstanceList(this, JJTINSTANCELIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) InstanceList */
        try {
/*@egen*/
	(<INSTANCE>)+ | <VARIABLE_TYPE>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//<class-name-list> ::= <class-name>+ | ?VARIABLE
void ClassNameList() : {/*@bgen(jjtree) ClassNameList */
                         COOLClassNameList jjtn000 = new COOLClassNameList(this, JJTCLASSNAMELIST);
                         boolean jjtc000 = true;
                         jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) ClassNameList */
        try {
/*@egen*/
	( 
		t = <SYMBOL>
		{ jjtn000.addClassname(t.image); }//class-name
	)+ 
	|
	<VARIABLE_TYPE>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//<value-list> ::= <constant>+ | ?VARIABLE
void ValueList() : {/*@bgen(jjtree) ValueList */
  COOLValueList jjtn000 = new COOLValueList(this, JJTVALUELIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ValueList */
        try {
/*@egen*/
	(Constant())+ | <VARIABLE_TYPE>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//<range-attribute> ::= (range <range-specification> <range-specification>)
void RangeAttribute() : {/*@bgen(jjtree) RangeAttribute */
  COOLRangeAttribute jjtn000 = new COOLRangeAttribute(this, JJTRANGEATTRIBUTE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) RangeAttribute */
        try {
/*@egen*/
	<RANGE> RangeSpecification() RangeSpecification()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//<range-specification> ::= <number> | ?VARIABLE
void RangeSpecification() : {/*@bgen(jjtree) RangeSpecification */
  COOLRangeSpecification jjtn000 = new COOLRangeSpecification(this, JJTRANGESPECIFICATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) RangeSpecification */
        try {
/*@egen*/
	Number() | <VARIABLE_TYPE>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//<cardinality-attribute> ::= (cardinality <cardinality-specification> <cardinality-specification>)
void CardinalityAttribute() : {/*@bgen(jjtree) CardinalityAttribute */
  COOLCardinalityAttribute jjtn000 = new COOLCardinalityAttribute(this, JJTCARDINALITYATTRIBUTE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) CardinalityAttribute */
        try {
/*@egen*/
	<CARDINALITY> CardinalitySpecification() CardinalitySpecification()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//<cardinality-specification> ::= <integer> | ?VARIABLE
void CardinalitySpecification() : {/*@bgen(jjtree) CardinalitySpecification */
  COOLCardinalitySpecification jjtn000 = new COOLCardinalitySpecification(this, JJTCARDINALITYSPECIFICATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) CardinalitySpecification */
        try {
/*@egen*/
	Integer() | <VARIABLE_TYPE>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

