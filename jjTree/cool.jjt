/** Grammar to generate a CLIPS Object Oriented Language (COOL)  parser with jjTree. 
	COOL is the language used by the CLIPS Production system 
		
	This jjTree Grammar creates an abstract synatx tree, based as closely on the 'look'
	of the source code, while the grammar is as close as possible to the specifications.
	This uses lots of rules which do not create nodes...
	
	The Actions of the grammar productions make certain assumptions about the nodes created.
	The following methods should be required by the SimpleNode interface:
		-setName
		-getName
		-execute
	Constructs also have
		-setDocString
		-getDocString
	
	Some Rules do not create Nodes, but instead directly produce data compatible
	with the engine. [ e.g. (autofocus true) is two nodes for 1 bit of information).
	
	Created Nov. 8th, 2006, at the Agent Technologies Practical 2006 at Aachen Technical University.
	
	@author Ory Chowaw-Liebman
	@author Ulrich Loup
	@todo Can probably be optimized a bit
*/

options {
	MULTI=true;
	STATIC=false;
	NODE_PREFIX="COOL";
	NODE_USES_PARSER=true;
}

/* Java code used for the Parser. */
PARSER_BEGIN(COOL)

import java.util.Hashtable;
import java.util.Iterator;


import org.jamocha.parser.JamochaValue;
import org.jamocha.parser.JamochaType;

import org.jamocha.rete.Rete;
import org.jamocha.rete.Slot;
import org.jamocha.rete.MultiSlot;
import org.jamocha.rete.AbstractSlot;
import org.jamocha.rete.Function;

import org.jamocha.rule.*;

public class COOL {

	private Rete engine = new Rete();
	
	/// Get the Value of a gobal Variable
	public JamochaValue getGlobalVar(String name)
	{
		return  engine.getBinding(name);
	}
	
	// Set a Global Variable
	public void setGlobalVar(String name,JamochaValue value)
	{
		engine.setBinding(name,value);
	}

	/// Get a Function for calling from AST
	public Function getFunction(String name)
	{ return engine.findFunction(name); }

	/// Set a Function for calling from AST
	public void setFunction(Function func)
	{ engine.declareFunction(func); }

	/// Forced by engine
	public Rete getRete()
	{ return engine; }
}

PARSER_END(COOL)

/**********************************************
 * Lexical Specs
 */


SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| ";" : IN_COMMENT
}

/* COMMENTS */

< IN_COMMENT >
MORE : 
{ 
  <  ~[] >
|
  < COMMENT_TEXT: ( (["0"-"9"])|(["a"-"z"]) )+ >
}

< IN_COMMENT >
SKIP :
{
  < END_COMMENT: ("\r" | "\n" | "\r\n") > : DEFAULT
}

TOKEN :
{
  < LBRACE: "(" >
| < RBRACE: ")" >| < GE1: ">=" >
| < INTEGER: ["0"-"9"] (["0"-"9"])* >
|
  < FLOAT:
        (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)?
      | "." (["0"-"9"])+ (<EXPONENT>)?
      | (["0"-"9"])+ <EXPONENT>
  >
| < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
|
  < STRING:
      ("\"" ((~["\"","\\"]) | ("\\" ( ["\\","\""] )))* "\"") |
      ("\'" ((~["\'","\\"]) | ("\\" ( ["\\","\'"] )))* "\'")
  >
  // If you think this is ugly, you are right. See CLIPS Basic Progrmmers Guide:
  // "Numbers are symbols, but treated different. Instances are symbols, but treated different." 
| < INSTANCE: "[" <SYMBOL> "]">
| < #VARSYMBOL:  ["a"-"z","A"-"Z"] (~[" ","\r","\n","\t","\"","\'","(",")","&","|","<","~",";"])>
| < SINGLEVAR: "?" <VARSYMBOL> >
| < MULTIVAR: "$?" <VARSYMBOL> >
| < GLOBALVAR: "?*" <SYMBOL> "*" >
| < DEFFACTS: "deffacts" >
| < DEFTEMPLATE: "deftemplate" >
| < DEFTEMPLATE_CONSTRUCT: "deftemplate_construct" >
| < DEFRULE: "defrule" >
| < DEFFUNCTION: "deffunction" >
| < DEFGENERIC: "defgeneric" >
| < DEFMETHOD: "defmethod" >
| < DEFCLASS: "defclass" >
| < DEFMESSAGEHANDLER: "defmessage-handler" >
| < DEFINSTANCES: "definstances" >
| < DEFMODULE: "defmodule" >
| < DEFGLOBAL: "defglobal" >
| < DEFAULT_ATR: "default" >
| < DYNAMIC_ATR: "default-dynamic" >
| < ATR_DEFAULT: "?DEFAULT" >
| < ATR_DERIVE: "?DERIVE" >
| < ATR_NONE: "?NONE" >
| < ATR_ALL: "?ALL" >
| < SLOT: "slot" >
| < SINGLE_SLOT: "single-slot" >
| < MULTISLOT: "multislot" >
| < ARROW: "=>">
| < DECLARE: "declare" >
| < SALIENCE: "salience" >
| < AUTOFOCUS: "auto-focus" >
| < EXPORT: "export" >
| < IMPORT: "import" >
| <	TYPE: "type" >
| < TRUE: "TRUE" | "true" | "True" >
| < FALSE: "FALSE" | "false" | "False" >
| < NOT: "not" >
| < AND: "and" >
| < OR: "or" >
| < OF: "of" >
| < LOGICAL: "logical" >
| < TEST: "test" >
| < EXISTS: "exists" >
| < FORALL: "forall">
| < OBJECT: "object" >
| < IS_A: "is-a" >
| < NAME: "name" >
| < ASSIGN: "<-" >
| < SFWILDCARD: "?" >
| < MFWILDCARD: "$?" >
| < TILDE: "~" >
| < AMPERSAND: "&" >
| < LINE: "|" >
| < COLON: ":" >
| < EQUALS: "=" >
| < VARIABLE_TYPE: "?VARIABLE" >
| < SYMBOL_TYPE: "SYMBOL" >
| < STRING_TYPE: "STRING" >
| < LEXEME_TYPE: "LEXEME" >
| < INTEGER_TYPE: "INTEGER" >
| < FLOAT_TYPE: "FLOAT" >
| < NUMBER_TYPE: "NUMBER" >
| < INSTANCE_NAME_TYPE: "INSTANCE-NAME" >
| < INSTANCE_ADDRESS_TYPE: "INSTANCE-ADDRESS" >
| < INSTANCE_TYPE: "INSTANCE" >
| < EXTERNAL_ADDRESS_TYPE: "EXTERNAL-ADDRESS" >
| < FACT_ADDRESS_TYPE: "FACT-ADDRESS" >
| < ALLOWED_SYMBOLS: "allowed-symbols" >
| < ALLOWED_STRINGS: "allowed-strings" >
| < ALLOWED_LEXEMES: "allowed-lexemes" >
| < ALLOWED_INTEGERS: "allowed-integers" >
| < ALLOWED_FLOATS: "allowed-floats" >
| < ALLOWED_NUMBERS: "allowed-numbers" >
| < ALLOWED_INSTANCES: "allowed-instances" >
| < ALLOWED_CLASSES: "allowed-classes" >
| < ALLOWED_VALUES: "allowed-values" >
| < RANGE: "range" >
| < CARDINALITY: "cardinality" >
| < ROLE: "role" >
| < CONCRETE: "concrete" >
| < ABSTRACT: "abstract" >
| < PATTERN_MATCH: "pattern-match" >
| < REACTIVE: "reactive" >
| < NON_REACTIVE: "non-reactive" >
| < ACTIVE: "active" >
| < STORAGE: "storage" >
| < LOCAL: "local" >
| < SHARED: "shared" >
| < ACCESS: "access" >
| < READ_WRITE: "read-write" >
| < READ_ONLY: "read-only" >
| < READ: "read" >
| < WRITE: "write" >
| < INITIALIZE_ONLY: "initialize-only" >
| < PROPAGATION: "propagation" >
| < INHERIT: "inherit" >
| < NO_INHERIT: "no-inherit" >
| < SOURCE: "source" >
| < EXCLUSIVE: "exclusive" >
| < COMPOSITE: "composite" >
| < VISIBILITY: "visibility" >
| < PRIVATE: "private" >
| < PUBLIC: "public" >
| < CREATE_ACCESSOR: "create-accessor" >
| < OVERRIDE_MESSAGE: "override-message" >
| < MESSAGE_HANDLER: "message-handler" >
| < PRIMARY: "primary" >
| < AROUND: "around" >
| < BEFORE: "before" >
| < AFTER: "after" >
| < SYMBOL:  
	(~[" ","\r","\n","\t","\"","\'","(",")","&","|","$","?","~",";","0"-"9"])
	|(
		(~[" ","\r","\n","\t","\"","\'","(",")","&","|","?","~",";","["])
		(~[" ","\r","\n","\t","\"","\'","(",")","&","|","?","~",";","0"-"9"])*
		(~[" ","\r","\n","\t","\"","\'","(",")","&","|","<","~",";" ])*
		(~[" ","\r","\n","\t","\"","\'","(",")","&","|","$","?","~",";","]"])? 
	)
	|(
		(~[" ","\r","\n","\t","\"","\'","(",")","&","|","?","~",";"])
		(~[" ","\r","\n","\t","\"","\'","(",")","&","|","?","~",";","0"-"9"])*
		(~[" ","\r","\n","\t","\"","\'","(",")","&","|","<","~",";" ])*
		(~[" ","\r","\n","\t","\"","\'","(",")","&","|","$","?","~",";","]"])+ 
	)
  >

}

/* TODO (From Clips Manual):
Data Types:
<file-name> ::= A symbol or string which is a valid file name (including path information)
	for the operating system under which CLIPS is running
<slot-name> ::= A valid deftemplate_construct slot name
<...-name> ::= A <symbol> where the ellipsis indicate what the symbol represents.
	For example, <rule-name> is a symbol which represents the name of a rule.
*/

/**********************************************
 * Cool Grammar Specs.
 */

/** Start rule is one construct at a time, Parser reads constructs into list.
	No need to create nodes for Start, Defcon and Funcon rule.*/
COOLStart Start() : {}
{
	
   ( LOOKAHEAD(2)
	Construct() | Expression()
	
	) { return jjtThis; }
	| <EOF> { return null; }
}


/*
<number> ::= <float> | <integer> 
<lexeme> ::= <symbol> | <string>
<constant> ::= <symbol> | <string> | <integer> | <float> | <instance-name>
*/

Node Float() : { Token t; }
{
	t=<FLOAT>
	{
		jjtThis.setName(t.image); 
		return jjtThis;
	}
}


Node Integer() : { Token t; }
{
	t=<INTEGER>
	{
		jjtThis.setName(t.image); 
		return jjtThis;
	}
}

Node Number() #void : { Node n; }
{	
	(	n=Float()
	|	n=Integer() 
	) { return n; }
}

Node Symbol() : { Token t;}
{
	t=<SYMBOL>
	{
		jjtThis.setName(t.image); 
		return jjtThis;
	}
}

Node String() : { Token t; }
{
	t=<STRING>
	{
		jjtThis.setName(t.image); 
		return jjtThis;
	}

}

Node Lexeme() #void : { Node n; }
{	
	(	n=String()
	|	n=Symbol() 
	) { return n; }
}

Node Instance() : { Token t; }
{
	t=<INSTANCE>
	{ 
		jjtThis.setName(t.image);
		return jjtThis;
	}
}

Node Constant() #void:{ Node n; }
{ 	
	(	n=Symbol()
	|	n=String()
	|	n=Integer()
	|	n=Float()
	|	n=Instance() 
	) { return n; }
}

void Comment() #void : {}
{	
    String()
}

/*
<function-name> ::= Any symbol which corresponds to a system or user defined function, a
	deffunction name, or a defgeneric name
	( Ory: I understand this to be a <SYMBOL> token )
<file-name> ::= A symbol or string which is a valid file name (including path information)
	for the operating system under which CLIPS is running

<variable> ::= <single-field-variable> | <multifield-variable> | <global-variable>
<function-call> ::= (<function-name> <expression>*)
<expression> ::= <constant> | <variable> | <function-call>
<action> ::= <expression>
*/

// This is used exactly then when only the variables value is needed
Node SingleVariable() : { Token t; } 
{
	t=<SINGLEVAR>
	{ jjtThis.setName(t.image); return jjtThis;}
}

// This is used exactly then when only the variables value is needed
Node GlobalVariable() : { Token t; } 
{
	t=<GLOBALVAR>
	{ jjtThis.setName(t.image); return jjtThis;}
}

// This is used exactly then when only the variables contents are needed
Node MultiVariable() : { Token t; } 
{
	t=<MULTIVAR>
	{ jjtThis.setName(t.image); return jjtThis;}
}

// This is used exactly then when only the variables value is needed
Node Variable() #void : { Node n; }
{	
	(	n=SingleVariable()
	|	n=MultiVariable()
	|	n=GlobalVariable() 
	) { return n;}
	}

Node FunctionCall() :{ Token t; }
{
	( "(" 
	t=<SYMBOL> 
	{ jjtThis.setName(t.image); }
	(Expression())* 
	")" ) { return jjtThis; }
}

Node Expression() #void : { Node n; } 
{	
	(	n=Constant()
	|	n=Variable()
	|	n=FunctionCall() 
	) { return n; }
}


/** Dummy Defined in CLIPS programmers guide... */
void Action() #void : {} {  Expression() }


/** Main Handler for Definition constructs.
	Note it contains the parantheses for the constructs
*/
void Construct() #void : {}
{
	"("
	( LOOKAHEAD(2)
		DeffactsConstruct()
	|	DeftemplateConstruct()
	|	DefglobalConstruct()
	|	DefruleConstruct()
	|	DeffunctionConstruct()
	|	DefgenericConstruct()
	|	DefmethodConstruct()
 	|	DefclassConstruct()
	|	DefmessageHandlerConstruct()
	|	DefinstancesConstruct()
	|	DefmoduleConstruct()
	)
	")"
}

/* Deffacts construct: 
	<deffacts-construct> ::= (deffacts <deffacts-name> [<comment>] <RHS-pattern>*) 
*/
void DeffactsConstruct() :{ Token t; }
{
      <DEFFACTS>
      t = <SYMBOL>
      { jjtThis.setName(t.image); }
      [
		t=<STRING>
		{ jjtThis.setDocString(t.image); }
	  ]
      (RHSPattern())*
}

/* Deftemplate construct
<deftemplate-construct> ::= (deftemplate <deftemplate-name> [<comment>] <slot-definition>*)
<slot-definition> ::= <single-slot-definition> | <multislot-definition> 
<single-slot-definition> ::= (slot <slot-name> <template-attribute>*)
<multislot-definition> ::= (multislot <slot-name> <template-attribute>*)
<template-attribute> ::= <default-attribute> | <constraint-attribute>
<default-attribute> ::= (default ?DERIVE | ?NONE | <expression>*) | (default-dynamic <expression>*)
*/
void DeftemplateConstruct() :{ Token t; AbstractSlot s;}
{
        <DEFTEMPLATE>
        t = <SYMBOL>
        { jjtThis.setName(t.image); }
	    [
			t=<STRING>
			{ jjtThis.setDocString(t.image); }
		]
        (
			s=SlotDefinition() { jjtThis.addSlot(s); }
        )*
}

//<slot-definition> ::= <single-slot-definition> | <multislot-definition>
AbstractSlot SlotDefinition() #void : { AbstractSlot ret;}
{
    ( 
		"(" ( ret=SingleSlotDefinition() | ret=MultislotDefinition() ) ")" 
    )	{ return ret; }
}

//<single-slot-definition> ::= (slot <slot-name> <template-attribute>*)
AbstractSlot SingleSlotDefinition() #void :
{ 
	Token t;
	Slot s=new Slot();
}
{
       <SLOT>
        t = <SYMBOL>
        { 
			s.setName(t.image); //<slot-name>
        }
        (
			TemplateAttribute()
//			{ if (a!=null) s.addAttribue(a); };
		)*
		{ return s; }
}

//<multislot-definition> ::= (multislot <slot-name> <template-attribute>*)
AbstractSlot MultislotDefinition() #void :
{ 
	Token t; 
	MultiSlot s=new MultiSlot();
}
{
        <MULTISLOT>
        t = <SYMBOL>
        { s.setName(t.image); }//<slot-name>
        (
			TemplateAttribute()
//			{ if (a!=null) s.addAttribue(a); };
		)*
		{ return s; }
}

//<template-attribute> ::= <default-attribute> | <constraint-attribute>
SlotAttrib TemplateAttribute() #void : { SlotAttrib s=null;}
{
	(	s=DefaultAttribute() 
	| 	s=DynamicAttribute()
	|	ConstraintAttribute()
	) { return s; }
}

//<default-attribute> ::= (default ?DERIVE | ?NONE | <expression>*) | (default-dynamic <expression>*)
//<default-attribute> ::= (default ?DERIVE | ?NONE | <expression>*) | (default-dynamic <expression>*)

SlotAttrib DefaultAttribute() #void : { SlotAttrib s=new SlotAttrib(); Node n;}
{
	<DEFAULT_ATR>
	(	
		<ATR_DERIVE> { s.setDefaultDerive(); }
	|	<ATR_NONE> { s.setDefaultNone(); }
	|	n=ActionList() { s.setDefaultAction(n); }
	)
	{ return s; }
}

SlotAttrib DynamicAttribute() #void : { SlotAttrib s=new SlotAttrib(); Node n;}
{	
	(	<DYNAMIC_ATR> 
		n=ActionList() { s.setDynamic(n); }
	)	{ return s; }
	
}

/* Fact Specification
<RHS-pattern> ::= <ordered-RHS-pattern> | <template-RHS-pattern>
<ordered-RHS-pattern> ::= (<symbol> <RHS-field>+)
<template-RHS-pattern> ::= (<deftemplate-name> <RHS-slot>*)
<RHS-slot> ::= <single-field-RHS-slot> | <multifield-RHS-slot>
<single-field-RHS-slot> ::= (<slot-name> <RHS-field>)
<multifield-RHS-slot> ::= (<slot-name> <RHS-field>*)
<RHS-field> ::= <variable> | <constant> | <function-call>
*/
void RHSPattern() #void : {}
{
    "(" 
    (
    	OrderedRHSPattern() 
    |	TemplateRHSPattern() 
    ) ")"
}

//<ordered-RHS-pattern> ::= (<symbol> <RHS-field>+)
void OrderedRHSPattern() : { Token t;}
{
    t=<SYMBOL>
    { jjtThis.setName(t.image); }
    ( LOOKAHEAD(2) Expression())+
}

//<template-RHS-pattern> ::= (<deftemplate-name> <RHS-slot>*)
void TemplateRHSPattern() :{ Token t; }
{
    
    "("
        t = <SYMBOL>
        { jjtThis.setName(t.image); }
        (RHSSlot())*
    ")"
}

//<RHS-slot> ::= <single-field-RHS-slot> | <multifield-RHS-slot>
void RHSSlot() #void : {}
{
    "(" 
		SingleFieldRHSSlot() 
	|	MultifieldRHSSlot()
    ")"
}

//<single-field-RHS-slot> ::= (<slot-name> <RHS-field>)
void SingleFieldRHSSlot() :{ Token t; }
{
        t = <SYMBOL>
        { jjtThis.setName(t.image); }//slot-name
        Expression()
}

//<multifield-RHS-slot> ::= (<slot-name> <RHS-field>*)
void MultifieldRHSSlot() :{ Token t; }
{
        t = <SYMBOL>
        { jjtThis.setName(t.image); }//slot-name
        (Expression())*
}

//<RHS-field> ::= <variable> | <constant> | <function-call>
// Same as expression
/*void RHSField() #void : {}
{
    Variable() | Constant() | FunctionCall()
}*/

/* Defrule Construct
<defrule-construct> 
	::= (defrule <rule-name> [<comment>] [<declaration>] <conditional-element>* => <action>*) 
<declaration> ::= (declare <rule-property>+)
<rule-property> ::= (salience <integer-expression>) | (auto-focus <boolean-symbol>)
<boolean-symbol> ::= TRUE | FALSE
<conditional-element> ::= <pattern-CE> | <assigned-pattern-CE> | <not-CE> | <and-CE> | <or-CE> |
	<logical-CE> | <test-CE> | <exists-CE> | <forall-CE>
<pattern-CE> ::= <ordered-pattern-CE> | <template-pattern-CE> | <object-pattern-CE>
<assigned-pattern-CE> ::= <single-field-variable> <- <pattern-CE>
<not-CE> ::= (not <conditional-element>)
<and-CE> ::= (and <conditional-element>+)
<or-CE> ::= (or <conditional-element>+)
<logical-CE> ::= (logical <conditional-element>+)
<test-CE> ::= (test <function-call>)
<exists-CE> ::= (exists <conditional-element>+)
<forall-CE> ::= (forall <conditional-element> <conditional-element>+)
<ordered-pattern-CE> ::= (<symbol> <constraint>*)
<template-pattern-CE> ::= (<deftemplate-name> <LHS-slot>*)
<object-pattern-CE> ::= (object <attribute-constraint>*)
<attribute-constraint> ::= (is-a <constraint>) | (name <constraint>) | (<slot-name> <constraint>*)
<LHS-slot> ::= <single-field-LHS-slot> | <multifield-LHS-slot>
<single-field-LHS-slot> ::= (<slot-name> <constraint>)
<multifield-LHS-slot> ::= (<slot-name> <constraint>*)
<constraint> ::= ? | $? | <connected-constraint>
<connected-constraint>::= <single-constraint> | <single-constraint> & <connected-constraint> |
	<single-constraint> | <connected-constraint>
<single-constraint> ::= <term> | ~<term>
<term> ::= <constant> | <single-field-variable> | <multifield-variable> | 
	:<function-call> | =<function-call>
*/
void DefruleConstruct() :{ Token t; Node n; Condition ce; }
{
  ( <DEFRULE>
//	( LOOKAHEAD(3)
//		( 
//			t=<SYMBOL>
//			{ jjtThis.setName(t.image); }//name
//		) |	(
			t=<SYMBOL>
			{ jjtThis.setName(t.image); }//name
			[ t=<STRING> { jjtThis.setDocString(t.image); }	]
//		)
//	)
	( LOOKAHEAD(3)
		(
			Declaration(jjtThis)
			(
				ce=ConditionalElement()
			)* 
		) |
		(
			(
				ce=ConditionalElement()
				{  jjtThis.addCondition(ce); }
			)* 
		)
	)
	<ARROW>
	n=ActionList() { jjtThis.setRuleActions(n); }
  )
}

////////////////////////////
// Conditional elements should not produce nodes, 
// but conditions as in package org.jamocha.rule

// Create Dummy node to have fixed number of chlidren in Defrule
/*Node CEList():{} 
{ 
	(ConditionalElement())* {}
	{ return jjtThis; }
}
*/

// Create Dummy node to have fixed number of chlidren in Defrule
Node ActionList():{} 
{ 
	(Expression())* 
	{ return jjtThis; }
}

/*
// Create Dummy node to have fixed number of chlidren later
Node CEList2():{} 
{ 
	(ConditionalElement())+ 
	{ return jjtThis; }
}
*/

//<declaration> ::= (declare <rule-property>+)
void Declaration(COOLDefruleConstruct r) #void : {}
{
    "("
        <DECLARE>
        (RuleProperty(r))+
    ")"
}

//<rule-property> ::= (salience <integer-expression>) | (auto-focus <boolean-symbol>)
void RuleProperty(COOLDefruleConstruct r) #void: { Node n; }
{
    "(" (
		(  <SALIENCE>
			//todo:        <integer-expression>
			// Ory: Just use expression and check for it being an integer at runtime (it could use global variables)
			// Need to determine salience at runtime!!
			n=Expression() { r.setSalienceExpression(n); }
		)
		{ // Set node type to salience, 
		}
     | (	<AUTOFOCUS> 
		(	<TRUE> { r.setAutoFocus(true); }
		|	<FALSE> { r.setAutoFocus(false); } 
		)
	)) ")"
}

//<boolean-symbol> ::= TRUE | FALSE
void BooleanSymbol() : { Token t;}
{
    ( t=<TRUE> ) { jjtThis.setName(t.image); jjtThis.setToTrue();}
    |
    ( t=<FALSE> ) { jjtThis.setName(t.image); jjtThis.setToFalse(); }
}

//<conditional-element> ::= <pattern-CE> | <assigned-pattern-CE> | <not-CE> | <and-CE> | <or-CE> |
//                          <logical-CE> | <test-CE> | <exists-CE> | <forall-CE>
Condition ConditionalElement() #void : { Condition ce; }
{
	"(" 
		(
			ce=PatternCE() 
		|	ce=AssignedPatternCE() 
		|	ce=BooleanFunction() 
		|	ce=LogicalCE() 
		|	ce=TestCE()
		|	ce=ExistsCE()
		|	ce=ForallCE()
		)
	")"
	{ return ce; }	
}

// Create and return conditions
Condition BooleanFunction() #void : { Condition ce=null,child; }
{
	(	(	// Unary operators
			// No not condition and no condition negation ==> can't implement yet
			<NOT> {  }
			child=ConditionalElement() { /*not_ce.addNestedConditionElement(child);*/ }
		)
	|	(	// non-Unary operators
			(
				<AND> { ce=new AndCondition(); }
      			(
					child=ConditionalElement() { /*and_ce.addNestedConditionElement(child); */} 
				)+
			)
		|	(	// No Or condition and no condition negation ==> can't implement yet
				<OR> { ce=new AndCondition(); }
      			(
					child=ConditionalElement() { /*or_ce.addNestedConditionElement(child); */ } 
				)+
			) 
		)
	)	{ return ce; }
		
}

//<pattern-CE> ::= <ordered-pattern-CE> | <template-pattern-CE> | <object-pattern-CE>
// Create and return conditions
Condition  PatternCE() #void : { Condition ce;}
{
	( LOOKAHEAD(2) 
		ce=OrderedPatternCE() 
	|	ce=TemplatePatternCE() 
	|	ce=ObjectPatternCE() 
	) { return ce; }
}

//<assigned-pattern-CE> ::= <single-field-variable> <- <pattern-CE>
// Create and return conditions 	--	NOT IMPLEMENTED!!
Condition AssignedPatternCE() #void : {}
{
	(
		SingleVariable() 
		<ASSIGN>
		PatternCE()
    ) { return null; }
}


//<logical-CE> ::= (logical <conditional-element>+)
// Create and return conditions	--	NOT IMPLEMENTED!!
Condition LogicalCE() #void : {}
{
    <LOGICAL> 
    (
		ConditionalElement()
    )+ 
    { return null; }
}

//<test-CE> ::= (test <function-call>)
// Create and return conditions (needs to initialize function 
// before execution, thus it gets a node
Condition TestCE() : { TestCondition ce=new TestCondition(); Token t;}
{
    ( 
		<TEST>
		t=<SYMBOL> { jjtThis.setName(t.image); jjtThis.setCondition(ce); }
	) { return ce; }
}

//<exists-CE> ::= (exists <conditional-element>+)
// Create and return conditions
Condition ExistsCE() #void : 
{
	Condition child;
	ExistCondition ce=new ExistCondition();
}
{
    <EXISTS> 
    (
		child=ConditionalElement() { ce.addNestedConditionElement(child); }
    )+
    { return ce; }
}

//<forall-CE> ::= (forall <conditional-element> <conditional-element>+)
// Create and return conditions	--	NOT IMPLEMENTED!!
Condition ForallCE() #void : {}
{
	(	<FORALL> 
	ConditionalElement() 
	(ConditionalElement())+
	)	{return null; }
}

//<ordered-pattern-CE> ::= (<symbol> <constraint>*)
Condition OrderedPatternCE() : 
{ 	
	Token t; 
	Condition ce=null;	// NOT IMPLEMENTED
}
{
        (	
			t=<SYMBOL>
			{ jjtThis.setName(t.image); }
			(Constraint())*
		)	{ return ce; }
}

//<template-pattern-CE> ::= (<deftemplate-name> <LHS-slot>*)
Condition TemplatePatternCE() : 
{ 
	Token t; 
	Condition ce=null;
}
{
		(
			t=<SYMBOL>
			{  }	//deftemplate-name
			(LHSSlot())*
        )	{ return ce; }
}

//<object-pattern-CE> ::= (object <attribute-constraint>*)
// Create and return conditions (use exist condition!!)
Condition ObjectPatternCE() #void : 
{ 
	ObjectCondition ce=new ObjectCondition();
	Constraint c;
}
{
        (	<OBJECT>
        (
			c=AttributeConstraint() 
			{ ce.addConstraint(c); }
		)*
		)	{ return ce; }
}

//<attribute-constraint> ::= (is-a <constraint>) | (name <constraint>) | (<slot-name> <constraint>*)
// Create and return conditions (Are these implemented??)
Constraint AttributeConstraint()  #void :
{ 
	Token t;
	Constraint c=null;
}
{
    "("
        ( 
		  (	<IS_A> {  }
		|	<NAME> {  }
		  )
		  Constraint() 
		)| (
          t=<SYMBOL> {  }
          (Constraint())* )
    ")" { return c; }
}

// Functionally identical !?
//<single-field-LHS-slot> ::= (<slot-name> <constraint>)
//<multifield-LHS-slot> ::= (<slot-name> <constraint>*)
//<LHS-slot> ::= <single-field-LHS-slot> | <multifield-LHS-slot>
void LHSSlot()  : { Token t; }
{
        t=<SYMBOL>
        { jjtThis.setName(t.image); }	//slot-name
		(Constraint())*

}

//<constraint> ::= ? | $? | <connected-constraint>
void Constraint() #void : {}
{
    SingleFieldWildcard() | MultiFieldWildcard() | ConnectedConstraint()
}

void SingleFieldWildcard() : {} { <SFWILDCARD> }
void MultiFieldWildcard() : {} { <MFWILDCARD> }

//<connected-constraint>::= <single-constraint> | <single-constraint> & <connected-constraint> |
//	<single-constraint> | <connected-constraint>

// THIS IS WRONG: Ampersands and lines can be mixed!!
void ConnectedConstraint() : {}
{
		Term() 
	[ 
		( <AMPERSAND> ConnectedConstraint() { jjtThis.setTypeAnd(); } )
	|	( <LINE> ConnectedConstraint() { jjtThis.setTypeOr(); } )
	]
}

//<term> ::= <constant> | <single-field-variable> | <multifield-variable> | 
//	:<function-call> | =<function-call>
void Term()  : {}
{
	[	<TILDE>	{ jjtThis.setNegate(true); }
	] 
    ( LOOKAHEAD(3)
		Constant() { jjtThis.setType(COOLTerm.T_CONST); }
    |	SingleVariable() { jjtThis.setType(COOLTerm.T_SINGLE); }
    |	MultiVariable() { jjtThis.setType(COOLTerm.T_MULTI); }
    |	(<COLON> FunctionCall() ) { jjtThis.setType(COOLTerm.T_COLON); }
    |	(<EQUALS> FunctionCall() ) { jjtThis.setType(COOLTerm.T_EQ); } 
    )
}

/* Defglobal Construct
<defglobal-construct> ::= (defglobal [<defmodule-name>] <global-assignment>*)
<global-assignment> ::= <global-variable> = <expression>
<global-variable> ::= ?*<symbol>*
*/

//<defglobal-construct> ::= (defglobal [<defmodule-name>] <global-assignment>*)
void DefglobalConstruct()  :{ Token t; }
{
        <DEFGLOBAL>
        [ 
            t=<SYMBOL>
            { jjtThis.setName(t.image); }	//defmodule-name 
        ]
        (GlobalAssignment())*
}

//<global-assignment> ::= <global-variable> = <expression>
void GlobalAssignment()  : { Token t; }
{
	t=<GLOBALVAR>
	{ jjtThis.setName(t.image); }	// Needs to access variable not just read the value
    <EQUALS>
    Expression()
}

/* Deffunction Construct
<deffunction-construct> 
	::= (deffunction <name> [<comment>] (<regular-parameter>* [<wildcard-parameter>]) <action>*)
<regular-parameter> ::= <single-field-variable>
<wildcard-parameter> ::= <multifield-variable>
*/

//<deffunction-construct> 
//	::= (deffunction <name> [<comment>] (<regular-parameter>* [<wildcard-parameter>]) <action>*)
void DeffunctionConstruct()  :{ Token t; Node n; }
{
        <DEFFUNCTION>
        t=<SYMBOL>
        { jjtThis.setName(t.image); }//name
        [ t=<STRING> 
			{ jjtThis.setDocString(t.image); }
        ]
        "(" ParameterList() [ MultiVariable() ] ")"
        n=ActionList()
        { jjtThis.setFunctionActions(n); }
}

//<regular-parameter> ::= <single-field-variable>
void ParameterList() #void : {}
{
    (
		<SINGLEVAR>	{}	// Should add strings or such to a java list here
	)*
}

/* Ignored, produces multifield variable directly
//<wildcard-parameter> ::= <multifield-variable>
void WildcardParameter()  #void : {}
{
    <MULTIVAR>
}
*/

/* Defgeneric Construct
<defgeneric-construct> ::= (defgeneric <name> [<comment>])
*/
void DefgenericConstruct()  :{ Token t; }
{
        <DEFGENERIC>
        t=<SYMBOL>
        { jjtThis.setName(t.image); }	//name
        [ t=<STRING>
			{ jjtThis.setDocString(t.image); }
        ]
}

/* Defmethod Construct
<defmethod-construct> ::= (defmethod <name> [<index>] [<comment>] (<parameter-restriction>*
	[<wildcard-parameter-restriction>]) <action>*)
<parameter-restriction> ::= <single-field-variable> | (<single-field-variable> <type>* [<query>])
<wildcard-parameter-restriction> ::= <multifield-variable> | (<multifield-variable> <type>* [<query>])
<type> ::= <class-name>
<query> ::= <global-variable> | <function-call>
*/

/////////////////////////////////////

void DefmethodConstruct() : { Token t; }
{
	<DEFMETHOD>
	t = <SYMBOL>
	{ jjtThis.setName(t.image); }//name
	[
		t = <INTEGER>
		{ jjtThis.setIndex(t.image); }//method index (cf. clipsbasic programmers guide section 8.4.2)
	]
	[
		t = <STRING>
		{ jjtThis.setDocString(t.image); }//comment
	]
	<LBRACE>
		(ParameterRestriction())*
		[ WildcardParameterRestriction() ]
	<RBRACE>
	// This should be the nodes only subtree
    ActionList()
}

//<parameter-restriction> ::= <single-field-variable> | (<single-field-variable> <type>* [<query>])
void ParameterRestriction() : {}
{
	( LOOKAHEAD(2)
		(
			<SINGLEVAR>
		) |
		(
			<LBRACE>
				<SINGLEVAR> 
				(Type())* 
				[Query()]
			<RBRACE>
		)
	)
}

//<wildcard-parameter-restriction> ::= <multifield-variable> | (<multifield-variable> <type>* [<query>])
void WildcardParameterRestriction() : {}
{
	( LOOKAHEAD(2)
		(
			<MULTIVAR>
		) |
		(
			<LBRACE>
				<MULTIVAR> 
				(Type())* 
				[Query()]
			<RBRACE>
		)
	)
}

//<type> ::= <class-name>
void Type() : { Token t; }
{
	t = <SYMBOL>
	{ jjtThis.setName(t.image); }//class-name
}

//<query> ::= <global-variable> | <function-call>
void Query() : { Token t; }
{
		GlobalVariable()
	|	FunctionCall()
}

/*	Defclass Construct
<defclass-construct> ::= (defclass <name> [<comment>] (is-a <superclass-name>+)
	[<role>] [<pattern-match-role>] <slot>* <handler-documentation>*)
<role> ::= (role concrete | abstract)
<pattern-match-role> ::= (pattern-match reactive | non-reactive)
<slot> ::= (slot <name> <facet>*) | (single-slot <name> <facet>*) | (multislot <name> <facet>*)
<facet> ::= <default-facet> | <storage-facet> | <access-facet> | <propagation-facet> | 
	<source-facet> | <pattern-match-facet> | <visibility-facet> | 
	<create-accessor-facet> <override-message-facet> | <constraint-attribute>
<default-facet> ::= (default ?DERIVE | ?NONE | <expression>*) | (default-dynamic <expression>*)
<storage-facet> ::= (storage local | shared) 
<access-facet> ::= (access read-write | read-only | initialize-only) 
<propagation-facet> ::= (propagation inherit | no-inherit)
<source-facet> ::= (source exclusive | composite)
<pattern-match-facet> ::= (pattern-match reactive | non-reactive)
<visibility-facet> ::= (visibility private | public)
<create-accessor-facet> ::= (create-accessor ?NONE | read | write | read-write)
<override-message-facet> ::= (override-message ?DEFAULT | <message-name>)
<handler-documentation> ::= (message-handler <name> [<handler-type>])
<handler-type> ::= primary | around | before | after
*/
//<defclass-construct> ::= (defclass <name> [<comment>] (is-a <superclass-name>+)
//	[<role>] [<pattern-match-role>] <slot>* <handler-documentation>*)
void DefclassConstruct() : { Token t; }
{
	<DEFCLASS>
	t = <SYMBOL>
	{ jjtThis.setName(t.image); }//name
	[
		t = <STRING>
		{ jjtThis.setDocString(t.image); }//comment
	]
	<LBRACE>
		<IS_A>
		(
			t = <SYMBOL>
		)+
	<RBRACE>
	[ LOOKAHEAD(2) Role(jjtThis) ]
	[ LOOKAHEAD(2) PatternMatchRole(jjtThis) ]
	( LOOKAHEAD(2) Slot() )*
	( LOOKAHEAD(2) HandlerDocumentation() )*
}


// JUST SET ATTRIBUTE
//<role> ::= (role concrete | abstract)
void Role(COOLDefclassConstruct c) #void : {}
{
	<LBRACE>
		<ROLE> 
		(	<CONCRETE> { c.setConcrete(); }
		|	<ABSTRACT> { c.setAbstract(); }
		)
	<RBRACE>
}

// JUST SET ATTRIBUTE
//<pattern-match-role> ::= (pattern-match reactive | non-reactive)
void PatternMatchRole(COOLDefclassConstruct c) #void : {}
{
	<LBRACE>
		<PATTERN_MATCH> 
		(	<REACTIVE> { c.setReactive(); }
		|	<NON_REACTIVE> { c.setNonReactive(); }
		)
	<RBRACE>
}


// JUST SET RULE ATTRIBUTE?
//<slot> ::= (slot <name> <facet>*) | (single-slot <name> <facet>*) | (multislot <name> <facet>*)
ClassFacet Slot() #void : { Token t; ClassFacet cf=new ClassFacet();}
{
	<LBRACE>
		(
			<SLOT> 
		|	<SINGLE_SLOT>
		|	<MULTISLOT>
		)
		t = <SYMBOL>
//		{ jjtThis.setName(t.image); }
		( Facet(cf) )*
	<RBRACE>
	{ return cf; }
}

//<facet> ::= <default-facet> | <storage-facet> | <access-facet> | <propagation-facet> | 
//	<source-facet> | <pattern-match-facet> | <visibility-facet> | 
//	<create-accessor-facet> <override-message-facet> | <constraint-attribute>
void Facet(ClassFacet cf) #void : {}
{
	<LBRACE> //facets all have brackets
		( LOOKAHEAD(2)
			DefaultFacet(cf)
		| 	StorageFacet(cf)
		|	AccessFacet(cf)
		|	PropagationFacet(cf)
		|	SourceFacet(cf)
		|	PatternMatchFacet(cf)
		|	VisibilityFacet(cf)
		|	CreateAccessorFacet(cf)
		|	OverrideMessageFacet(cf)
		|	ConstraintAttribute()
		)
	<RBRACE>
}

//<default-facet> ::= (default ?DERIVE | ?NONE | <expression>*) | (default-dynamic <expression>*)
void DefaultFacet(ClassFacet cf) #void : { Node n; }
{
	( 	<DEFAULT_ATR> { cf.setDynamic(false); }
		(	<ATR_DERIVE> { cf.setDefaultDerive(); }
		|	<ATR_NONE> { cf.setDefaultNone(); }
		|	n=ActionList() { cf.setDefaultAction(n); }
		) 
	) 
	|	
	( 	<DYNAMIC_ATR> n=ActionList() { cf.setDefaultAction(n); }
	)
}


// JUST SET RULE ATTRIBUTE
//<storage-facet> ::= (storage local | shared)
void StorageFacet(ClassFacet cf) #void  : {}
{
	<STORAGE> 
	(	<LOCAL> { cf.setStorageLocal(true); }
	|	<SHARED> { cf.setStorageLocal(false); }
	)
}
	

// JUST SET RULE ATTRIBUTE
//<access-facet> ::= (access read-write | read-only | initialize-only)
void AccessFacet(ClassFacet cf) #void : {}
{
	<ACCESS> 
	(	<READ_WRITE> { cf.setAccessReadWrite(); }
	|	<READ_ONLY>	{ cf.setAccessRead(); }
	|	<INITIALIZE_ONLY> { cf.setAccessInitialize(); }
	)
}


// JUST SET ATTRIBUTE
//<propagation-facet> ::= (propagation inherit | no-inherit)
void PropagationFacet(ClassFacet cf) #void : {}
{
	<PROPAGATION> 
	(	<INHERIT> { cf.setInherit(true); }
	| 	<NO_INHERIT> { cf.setInherit(false); }
	)
}


// JUST SET ATTRIBUTE
//<source-facet> ::= (source exclusive | composite)
void SourceFacet(ClassFacet cf) #void : {}
{
	<SOURCE> <EXCLUSIVE> | <COMPOSITE>
}


// JUST SET ATTRIBUTE
//<pattern-match-facet> ::= (pattern-match reactive | non-reactive)
void PatternMatchFacet(ClassFacet cf)  #void : {}
{
	<PATTERN_MATCH> 
	(	<REACTIVE>	{ cf.setMatchReactive(true); }
	|	<NON_REACTIVE> { cf.setMatchReactive(false); }
	)
}


// JUST SET RULE ATTRIBUTE
//<visibility-facet> ::= (visibility private | public)
void VisibilityFacet(ClassFacet cf) #void : {}
{
	<VISIBILITY> 
	(	<PRIVATE> { cf.setPublic(false); }
	|	<PUBLIC> { cf.setPublic(true); }
	)
}


// JUST SET RULE ATTRIBUTE
//<create-accessor-facet> ::= (create-accessor ?NONE | read | write | read-write)
void CreateAccessorFacet(ClassFacet cf) #void : {}
{
	<CREATE_ACCESSOR> 
	(	<ATR_NONE> 
	|	<READ> 
	|	<WRITE> 
	|	<READ_WRITE>
	)
}


// JUST SET RULE ATTRIBUTE
//<override-message-facet> ::= (override-message ?DEFAULT | <message-name>)
void OverrideMessageFacet(ClassFacet cf) #void : { Token t; }
{
	<OVERRIDE_MESSAGE> 
	(	<ATR_DEFAULT> { cf.setMessageDefault(); }
	|	t = <STRING> { cf.setMessageName(t.image); }
	)
}


//<handler-documentation> ::= (message-handler <name> [<handler-type>])
void HandlerDocumentation() #void : { Token t; int i=-1; }
{
	(
		<MESSAGE_HANDLER>
		t = <SYMBOL>
		[ i=HandlerType() ]
	) 
	
}

// JUST RETURN TYPE
//<handler-type> ::= primary | around | before | after
int HandlerType() #void : { int i=-1; }
{
	(	<PRIMARY>	{ i=0; }
	|	<AROUND>	{ i=1; }
	|	<BEFORE>	{ i=2; }
	|	<AFTER>		{ i=3; }
	)
	{ return i; }
}

/* 	Defmessage-handler Construct
	<defmessage-handler-construct> 
		::= (defmessage-handler <class-name> <message-name> [<handler-type>] 
			[<comment>] (<parameter>* [<wildcard-parameter>]) <action>*)
	<handler-type> ::= around | before | primary | after
	<parameter> ::= <single-field-variable>
	<wildcard-parameter> ::= <multifield-variable>
*/

//<defmessage-handler-construct> 
//	::= (defmessage-handler <class-name> <message-name> [<handler-type>] 
//		[<comment>] (<parameter>* [<wildcard-parameter>]) <action>*)
void DefmessageHandlerConstruct() : { Token t; }
{
	<DEFMESSAGEHANDLER>
	t = <SYMBOL>
	{ jjtThis.setClassName(t.image); }//name
	t = <SYMBOL>
	{ jjtThis.setName(t.image); }//name 2
	[ HandlerType() ]
	[
		t = <STRING>
		{ jjtThis.setDocString(t.image); }//comment
	]
	<LBRACE>
		(SingleVariable())* //parameter
		[MultiVariable()]
	<RBRACE>
	(ActionList())
}

/*	Definstances Construct
	<definstances-construct> ::= (definstances <definstances-name> [active] [<comment>] <instance-template>*)
	<instance-template> ::= (<instance-definition>)
	<instance-definition> ::= <instance-name-expression> of <class-name-expression> <slot-override>*
	<slot-override> ::= (<slot-name-expression> <expression>*)
*/

//<definstances-construct> ::= (definstances <definstances-name> [active] [<comment>] <instance-template>*)
void DefinstancesConstruct() : { Token t; }
{
	<DEFINSTANCES>
	t = <SYMBOL>
	{ jjtThis.setName(t.image); }//name
	[ <ACTIVE> ]
	[
		t = <STRING>
		{ jjtThis.setDocString(t.image); }//comment
	]
	(LOOKAHEAD(2) InstanceTemplate())*
}

//<instance-template> ::= (<instance-definition>)
void InstanceTemplate() #void : {}
{
	<LBRACE>
		InstanceDefinition()
	<RBRACE>
}

//<instance-definition> ::= <instance-name-expression> of <class-name-expression> <slot-override>*
void InstanceDefinition() #void : { Token t; }
{
	// Should have two expressions returning the correct types, not symbols!!
	t = <SYMBOL>
//	{ jjtThis.setCLIPSName(t.image); }//instance-name
	<OF>
	t = <SYMBOL>
//	{ jjtThis.setCLIPSName2(t.image); }//class-name
	(SlotOverride())*
}

//<slot-override> ::= (<slot-name-expression> <expression>*)
void SlotOverride() #void : { Token t; }
{
	<LBRACE>
	t = <SYMBOL>	// Should be an expression returning a slot name
//	{ jjtThis.setName(t.image); }//slot-name
	ActionList()
	<RBRACE>
}

/*	Defmodule Construct
	<defmodule-construct> ::= (defmodule <module-name> [<comment>] <port-specification>*)
	<port-specification> ::= (export <port-item>) | (import <module-name> <port-item>)
	<port-item> ::= ?ALL | ?NONE | <port-construct> ?ALL | 
		<port-construct> ?NONE | <port-construct> <construct-name>+
	<port-construct> ::= deftemplate_construct | defclass | defglobal | deffunction | defgeneric
*/

//<defmodule-construct> ::= (defmodule <module-name> [<comment>] <port-specification>*)
void DefmoduleConstruct() : { Token t; }
{
	<DEFMODULE>
	t = <SYMBOL>
	{ jjtThis.setName(t.image); }//name
	[
		t = <SYMBOL>
		{ jjtThis.setDocString(t.image); }//comment
	]
	(PortSpecification())*
}

//<port-specification> ::= (export <port-item>) | (import <module-name> <port-item>)
void PortSpecification() : { Token t; }
{
	<LBRACE>
	(
		<EXPORT>
		PortItem()
	) |
	(
		<IMPORT>
		t = <SYMBOL>
		{ jjtThis.setName(t.image); }//name
		PortItem()
	)
	<RBRACE>
}

//			(
//				t = <SYMBOL>
//				{ jjtThis.addCLIPSPortname(t.image); }
//			)+

//<port-item> ::= ?ALL | ?NONE | <port-construct> ?ALL | 
//	<port-construct> ?NONE | <port-construct> <construct-name>+
void PortItem() : { Token t; }
{
	(	<ATR_ALL> 
	| 	<ATR_NONE> 
	| 	( 
			PortConstruct() 
			(	<ATR_ALL> 
			|	<ATR_NONE> 
			|	(ConstructName())*
			)
		)
	)
}

void ConstructName() : { Token t;}
{
	(	t=<SYMBOL> 
	|	t=<INSTANCE> 
	) { jjtThis.setName(t.image); }
}

//<port-construct> ::= deftemplate_construct | defclass | defglobal | deffunction | defgeneric
void PortConstruct() #void : {}
{
	( LOOKAHEAD(2) <DEFTEMPLATE_CONSTRUCT> | <DEFCLASS> | <DEFGLOBAL> | <DEFFUNCTION> | <DEFGENERIC> )
}

/* constraint Attributes */

//<constraint-attribute> ::= <type-attribute> | <allowed-constant-attribute> | 
//	<range-attribute> | <cardinality-attribute>
void ConstraintAttribute() #void : { }
{
	<LBRACE> //brackets for all productions below
	( LOOKAHEAD(2)
		TypeAttribute()
	|	AllowedConstantAttribute()
	|	RangeAttribute()
	|	CardinalityAttribute()
	)
	<RBRACE>//
}

//<type-attribute> ::= (type <type-specification>)
void TypeAttribute() #void : { }
{
	<TYPE> TypeSpecification()
}

///////////////////
// Use EnumSets here

//<type-specification> ::= <allowed-type>+ | ?VARIABLE
void TypeSpecification()  #void : {}
{
	(AllowedType())+ | <VARIABLE_TYPE>
}

//<allowed-type> ::= SYMBOL | STRING | LEXEME | INTEGER | FLOAT | NUMBER |
//	INSTANCE-NAME | INSTANCE-ADDRESS | INSTANCE | EXTERNAL-ADDRESS | FACT-ADDRESS
void AllowedType()  #void : {}
{
	(	<SYMBOL_TYPE>
	|	<STRING_TYPE>
	|	<LEXEME_TYPE>
	| 	<INTEGER_TYPE>
	| 	<FLOAT_TYPE>
	|	<NUMBER_TYPE> 
	|	<INSTANCE_NAME_TYPE>
	| 	<INSTANCE_ADDRESS_TYPE>
	|	<INSTANCE_TYPE>
	|	<EXTERNAL_ADDRESS_TYPE>
	|	<FACT_ADDRESS_TYPE>
	)
}

// <allowed-constant-attribute> ::= (allowed-symbols <symbol-list>) | (allowed-strings <string-list>) |
//	(allowed-lexemes <lexeme-list> | (allowed-integers <integer-list>) | (allowed-floats <float-list>) |
//	(allowed-numbers <number-list>) | (allowed-instance-names <instance-list>) |
//	(allowed-classes <class-name-list>) | (allowed-values <value-list>)
void AllowedConstantAttribute() #void : {}
{
	(
		<ALLOWED_SYMBOLS> SymbolList()		|
		<ALLOWED_STRINGS> StringList()		|
		<ALLOWED_LEXEMES> LexemeList()		|
		<ALLOWED_INTEGERS> IntegerList()	|
		<ALLOWED_FLOATS> FloatList()		|
		<ALLOWED_NUMBERS> NumberList()		|
		<ALLOWED_INSTANCES> InstanceList()	|
		<ALLOWED_CLASSES> ClassNameList()	|
		<ALLOWED_VALUES> ValueList()		
	)
}

//<symbol-list> ::= <symbol>+ | ?VARIABLE
void SymbolList() #void : {}
{
	(<SYMBOL>)+ | <VARIABLE_TYPE>
}

//<string-list> ::= <string>+ | ?VARIABLE
void StringList() #void : {}
{
	(<STRING>)+ | <VARIABLE_TYPE>
}

//<lexeme-list> ::= <lexeme>+ | ?VARIABLE
void LexemeList() #void : {}
{
	(Lexeme())+ | <VARIABLE_TYPE>
}

//<integer-list> ::= <integer>+ | ?VARIABLE
void IntegerList() #void : {}
{
	(<INTEGER>)+ | <VARIABLE_TYPE>
}

//<float-list> ::= <float>+ | ?VARIABLE
void FloatList() #void : {}
{
	(<FLOAT>)+ | <VARIABLE_TYPE>
}

//<number-list> ::= <number>+ | ?VARIABLE
void NumberList() #void : {}
{
	(Number())+ | <VARIABLE_TYPE>
}

//<instance-name-list> ::= <instance-name>+ | ?VARIABLE
void InstanceList() #void : {}
{
	(<INSTANCE>)+ | <VARIABLE_TYPE>
}

//<class-name-list> ::= <class-name>+ | ?VARIABLE
void ClassNameList() #void : { Token t; }
{
	( 
		t = <SYMBOL>
	)+ 
	|
	<VARIABLE_TYPE>
}

//<value-list> ::= <constant>+ | ?VARIABLE
void ValueList() #void : {}
{
	(Constant())+ | <VARIABLE_TYPE>
}

//<range-attribute> ::= (range <range-specification> <range-specification>)
void RangeAttribute() #void : {}
{
	<RANGE> RangeSpecification() RangeSpecification()
}

//<range-specification> ::= <number> | ?VARIABLE
void RangeSpecification()  #void : {}
{
	Number() | <VARIABLE_TYPE>
}

//<cardinality-attribute> ::= (cardinality <cardinality-specification> <cardinality-specification>)
void CardinalityAttribute()  #void : {}
{
	<CARDINALITY> CardinalitySpecification() CardinalitySpecification()
}

//<cardinality-specification> ::= <integer> | ?VARIABLE
void CardinalitySpecification() #void: {}
{
	Integer() | <VARIABLE_TYPE>
}

