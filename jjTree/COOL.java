/* Generated By:JJTree&JavaCC: Do not edit this line. COOL.java */
import java.util.Hashtable;
import java.util.Iterator;


import org.jamocha.parser.JamochaValue;
import org.jamocha.parser.JamochaType;

import org.jamocha.rete.Rete;
import org.jamocha.rete.Slot;
import org.jamocha.rete.MultiSlot;
import org.jamocha.rete.AbstractSlot;
import org.jamocha.rete.Function;

import org.jamocha.rule.*;

public class COOL/*@bgen(jjtree)*/implements COOLTreeConstants, COOLConstants {/*@bgen(jjtree)*/
  protected JJTCOOLState jjtree = new JJTCOOLState();
        private Rete engine = new Rete();

        /// Get the Value of a gobal Variable
        public JamochaValue getGlobalVar(String name)
        {
                return  engine.getBinding(name);
        }

        // Set a Global Variable
        public void setGlobalVar(String name,JamochaValue value)
        {
                engine.setBinding(name,value);
        }

        /// Get a Function for calling from AST
        public Function getFunction(String name)
        { return engine.findFunction(name); }

        /// Set a Function for calling from AST
        public void setFunction(Function func)
        { engine.declareFunction(func); }

        /// Forced by engine
        public Rete getRete()
        { return engine; }

/* TODO (From Clips Manual):
Data Types:
<file-name> ::= A symbol or string which is a valid file name (including path information)
	for the operating system under which CLIPS is running
<slot-name> ::= A valid deftemplate_construct slot name
<...-name> ::= A <symbol> where the ellipsis indicate what the symbol represents.
	For example, <rule-name> is a symbol which represents the name of a rule.
*/

/**********************************************
 * Cool Grammar Specs.
 */

/** Start rule is one construct at a time, Parser reads constructs into list.
	No need to create nodes for Start, Defcon and Funcon rule.*/
  final public COOLStart Start() throws ParseException {
                     /*@bgen(jjtree) Start */
  COOLStart jjtn000 = new COOLStart(this, JJTSTART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACE:
      case INTEGER:
      case FLOAT:
      case STRING:
      case INSTANCE:
      case SINGLEVAR:
      case MULTIVAR:
      case GLOBALVAR:
      case SYMBOL:
        if (jj_2_1(2)) {
          Construct();
        } else {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case LBRACE:
          case INTEGER:
          case FLOAT:
          case STRING:
          case INSTANCE:
          case SINGLEVAR:
          case MULTIVAR:
          case GLOBALVAR:
          case SYMBOL:
            Expression();
            break;
          default:
            jj_la1[0] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
            jjtree.closeNodeScope(jjtn000, true);
            jjtc000 = false;
            {if (true) return jjtn000;}
        break;
      case 0:
        jj_consume_token(0);
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                  {if (true) return null;}
        break;
      default:
        jj_la1[1] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       {if (true) throw (RuntimeException)jjte000;}
     }
     if (jjte000 instanceof ParseException) {
       {if (true) throw (ParseException)jjte000;}
     }
     {if (true) throw (Error)jjte000;}
    } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
    }
    throw new Error("Missing return statement in function");
  }

/*
<number> ::= <float> | <integer> 
<lexeme> ::= <symbol> | <string>
<constant> ::= <symbol> | <string> | <integer> | <float> | <instance-name>
*/
  final public Node Float() throws ParseException {
                /*@bgen(jjtree) Float */
                 COOLFloat jjtn000 = new COOLFloat(this, JJTFLOAT);
                 boolean jjtc000 = true;
                 jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(FLOAT);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                jjtn000.setName(t.image);
                {if (true) return jjtn000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public Node Integer() throws ParseException {
                  /*@bgen(jjtree) Integer */
                   COOLInteger jjtn000 = new COOLInteger(this, JJTINTEGER);
                   boolean jjtc000 = true;
                   jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(INTEGER);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                jjtn000.setName(t.image);
                {if (true) return jjtn000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public Node Number() throws ParseException {
                        Node n;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FLOAT:
      n = Float();
      break;
    case INTEGER:
      n = Integer();
      break;
    default:
      jj_la1[2] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
            {if (true) return n;}
    throw new Error("Missing return statement in function");
  }

  final public Node Symbol() throws ParseException {
                 /*@bgen(jjtree) Symbol */
                  COOLSymbol jjtn000 = new COOLSymbol(this, JJTSYMBOL);
                  boolean jjtc000 = true;
                  jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(SYMBOL);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                jjtn000.setName(t.image);
                {if (true) return jjtn000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public Node String() throws ParseException {
                 /*@bgen(jjtree) String */
                  COOLString jjtn000 = new COOLString(this, JJTSTRING);
                  boolean jjtc000 = true;
                  jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(STRING);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                jjtn000.setName(t.image);
                {if (true) return jjtn000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public Node Lexeme() throws ParseException {
                        Node n;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case STRING:
      n = String();
      break;
    case SYMBOL:
      n = Symbol();
      break;
    default:
      jj_la1[3] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
            {if (true) return n;}
    throw new Error("Missing return statement in function");
  }

  final public Node Instance() throws ParseException {
                   /*@bgen(jjtree) Instance */
                    COOLInstance jjtn000 = new COOLInstance(this, JJTINSTANCE);
                    boolean jjtc000 = true;
                    jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(INSTANCE);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                jjtn000.setName(t.image);
                {if (true) return jjtn000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public Node Constant() throws ParseException {
                        Node n;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SYMBOL:
      n = Symbol();
      break;
    case STRING:
      n = String();
      break;
    case INTEGER:
      n = Integer();
      break;
    case FLOAT:
      n = Float();
      break;
    case INSTANCE:
      n = Instance();
      break;
    default:
      jj_la1[4] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
            {if (true) return n;}
    throw new Error("Missing return statement in function");
  }

  final public void Comment() throws ParseException {
    String();
  }

/*
<function-name> ::= Any symbol which corresponds to a system or user defined function, a
	deffunction name, or a defgeneric name
	( Ory: I understand this to be a <SYMBOL> token )
<file-name> ::= A symbol or string which is a valid file name (including path information)
	for the operating system under which CLIPS is running

<variable> ::= <single-field-variable> | <multifield-variable> | <global-variable>
<function-call> ::= (<function-name> <expression>*)
<expression> ::= <constant> | <variable> | <function-call>
<action> ::= <expression>
*/

// This is used exactly then when only the variables value is needed
  final public Node SingleVariable() throws ParseException {
                         /*@bgen(jjtree) SingleVariable */
                          COOLSingleVariable jjtn000 = new COOLSingleVariable(this, JJTSINGLEVARIABLE);
                          boolean jjtc000 = true;
                          jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(SINGLEVAR);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtn000.setName(t.image); {if (true) return jjtn000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

// This is used exactly then when only the variables value is needed
  final public Node GlobalVariable() throws ParseException {
                         /*@bgen(jjtree) GlobalVariable */
                          COOLGlobalVariable jjtn000 = new COOLGlobalVariable(this, JJTGLOBALVARIABLE);
                          boolean jjtc000 = true;
                          jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(GLOBALVAR);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtn000.setName(t.image); {if (true) return jjtn000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

// This is used exactly then when only the variables contents are needed
  final public Node MultiVariable() throws ParseException {
                        /*@bgen(jjtree) MultiVariable */
                         COOLMultiVariable jjtn000 = new COOLMultiVariable(this, JJTMULTIVARIABLE);
                         boolean jjtc000 = true;
                         jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(MULTIVAR);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtn000.setName(t.image); {if (true) return jjtn000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

// This is used exactly then when only the variables value is needed
  final public Node Variable() throws ParseException {
                          Node n;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SINGLEVAR:
      n = SingleVariable();
      break;
    case MULTIVAR:
      n = MultiVariable();
      break;
    case GLOBALVAR:
      n = GlobalVariable();
      break;
    default:
      jj_la1[5] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
            {if (true) return n;}
    throw new Error("Missing return statement in function");
  }

  final public Node FunctionCall() throws ParseException {
                      /*@bgen(jjtree) FunctionCall */
                       COOLFunctionCall jjtn000 = new COOLFunctionCall(this, JJTFUNCTIONCALL);
                       boolean jjtc000 = true;
                       jjtree.openNodeScope(jjtn000);Token t;
    try {
      jj_consume_token(LBRACE);
      t = jj_consume_token(SYMBOL);
          jjtn000.setName(t.image);
      label_1:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LBRACE:
        case INTEGER:
        case FLOAT:
        case STRING:
        case INSTANCE:
        case SINGLEVAR:
        case MULTIVAR:
        case GLOBALVAR:
        case SYMBOL:
          ;
          break;
        default:
          jj_la1[6] = jj_gen;
          break label_1;
        }
        Expression();
      }
      jj_consume_token(RBRACE);
                jjtree.closeNodeScope(jjtn000, true);
                jjtc000 = false;
                {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public Node Expression() throws ParseException {
                            Node n;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER:
    case FLOAT:
    case STRING:
    case INSTANCE:
    case SYMBOL:
      n = Constant();
      break;
    case SINGLEVAR:
    case MULTIVAR:
    case GLOBALVAR:
      n = Variable();
      break;
    case LBRACE:
      n = FunctionCall();
      break;
    default:
      jj_la1[7] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
            {if (true) return n;}
    throw new Error("Missing return statement in function");
  }

/** Dummy Defined in CLIPS programmers guide... */
  final public void Action() throws ParseException {
    Expression();
  }

/** Main Handler for Definition constructs.
	Note it contains the parantheses for the constructs
*/
  final public void Construct() throws ParseException {
    jj_consume_token(LBRACE);
    if (jj_2_2(2)) {
      DeffactsConstruct();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DEFTEMPLATE:
        DeftemplateConstruct();
        break;
      case DEFGLOBAL:
        DefglobalConstruct();
        break;
      case DEFRULE:
        DefruleConstruct();
        break;
      case DEFFUNCTION:
        DeffunctionConstruct();
        break;
      case DEFGENERIC:
        DefgenericConstruct();
        break;
      case DEFMETHOD:
        DefmethodConstruct();
        break;
      case DEFCLASS:
        DefclassConstruct();
        break;
      case DEFMESSAGEHANDLER:
        DefmessageHandlerConstruct();
        break;
      case DEFINSTANCES:
        DefinstancesConstruct();
        break;
      case DEFMODULE:
        DefmoduleConstruct();
        break;
      default:
        jj_la1[8] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    jj_consume_token(RBRACE);
  }

/* Deffacts construct: 
	<deffacts-construct> ::= (deffacts <deffacts-name> [<comment>] <RHS-pattern>*) 
*/
  final public void DeffactsConstruct() throws ParseException {
                           /*@bgen(jjtree) DeffactsConstruct */
                            COOLDeffactsConstruct jjtn000 = new COOLDeffactsConstruct(this, JJTDEFFACTSCONSTRUCT);
                            boolean jjtc000 = true;
                            jjtree.openNodeScope(jjtn000);Token t;
    try {
      jj_consume_token(DEFFACTS);
      t = jj_consume_token(SYMBOL);
        jjtn000.setName(t.image);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STRING:
        t = jj_consume_token(STRING);
                  jjtn000.setDocString(t.image);
        break;
      default:
        jj_la1[9] = jj_gen;
        ;
      }
      label_2:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LBRACE:
          ;
          break;
        default:
          jj_la1[10] = jj_gen;
          break label_2;
        }
        RHSPattern();
      }
    } catch (Throwable jjte000) {
        if (jjtc000) {
          jjtree.clearNodeScope(jjtn000);
          jjtc000 = false;
        } else {
          jjtree.popNode();
        }
        if (jjte000 instanceof RuntimeException) {
          {if (true) throw (RuntimeException)jjte000;}
        }
        if (jjte000 instanceof ParseException) {
          {if (true) throw (ParseException)jjte000;}
        }
        {if (true) throw (Error)jjte000;}
    } finally {
        if (jjtc000) {
          jjtree.closeNodeScope(jjtn000, true);
        }
    }
  }

/* Deftemplate construct
<deftemplate-construct> ::= (deftemplate <deftemplate-name> [<comment>] <slot-definition>*)
<slot-definition> ::= <single-slot-definition> | <multislot-definition> 
<single-slot-definition> ::= (slot <slot-name> <template-attribute>*)
<multislot-definition> ::= (multislot <slot-name> <template-attribute>*)
<template-attribute> ::= <default-attribute> | <constraint-attribute>
<default-attribute> ::= (default ?DERIVE | ?NONE | <expression>*) | (default-dynamic <expression>*)
*/
  final public void DeftemplateConstruct() throws ParseException {
                              /*@bgen(jjtree) DeftemplateConstruct */
                               COOLDeftemplateConstruct jjtn000 = new COOLDeftemplateConstruct(this, JJTDEFTEMPLATECONSTRUCT);
                               boolean jjtc000 = true;
                               jjtree.openNodeScope(jjtn000);Token t; AbstractSlot s;
    try {
      jj_consume_token(DEFTEMPLATE);
      t = jj_consume_token(SYMBOL);
          jjtn000.setName(t.image);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STRING:
        t = jj_consume_token(STRING);
                          jjtn000.setDocString(t.image);
        break;
      default:
        jj_la1[11] = jj_gen;
        ;
      }
      label_3:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LBRACE:
          ;
          break;
        default:
          jj_la1[12] = jj_gen;
          break label_3;
        }
        s = SlotDefinition();
                                             jjtn000.addSlot(s);
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

//<slot-definition> ::= <single-slot-definition> | <multislot-definition>
  final public AbstractSlot SlotDefinition() throws ParseException {
                                        AbstractSlot ret;
    jj_consume_token(LBRACE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SLOT:
      ret = SingleSlotDefinition();
      break;
    case MULTISLOT:
      ret = MultislotDefinition();
      break;
    default:
      jj_la1[13] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(RBRACE);
          {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

//<single-slot-definition> ::= (slot <slot-name> <template-attribute>*)
  final public AbstractSlot SingleSlotDefinition() throws ParseException {
        Token t;
        Slot s=new Slot();
    jj_consume_token(SLOT);
    t = jj_consume_token(SYMBOL);
                        s.setName(t.image); //<slot-name>

    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACE:
      case DEFAULT_ATR:
      case DYNAMIC_ATR:
        ;
        break;
      default:
        jj_la1[14] = jj_gen;
        break label_4;
      }
      TemplateAttribute();
    }
                  {if (true) return s;}
    throw new Error("Missing return statement in function");
  }

//<multislot-definition> ::= (multislot <slot-name> <template-attribute>*)
  final public AbstractSlot MultislotDefinition() throws ParseException {
        Token t;
        MultiSlot s=new MultiSlot();
    jj_consume_token(MULTISLOT);
    t = jj_consume_token(SYMBOL);
          s.setName(t.image);
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACE:
      case DEFAULT_ATR:
      case DYNAMIC_ATR:
        ;
        break;
      default:
        jj_la1[15] = jj_gen;
        break label_5;
      }
      TemplateAttribute();
    }
                  {if (true) return s;}
    throw new Error("Missing return statement in function");
  }

//<template-attribute> ::= <default-attribute> | <constraint-attribute>
  final public SlotAttrib TemplateAttribute() throws ParseException {
                                         SlotAttrib s=null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DEFAULT_ATR:
      s = DefaultAttribute();
      break;
    case DYNAMIC_ATR:
      s = DynamicAttribute();
      break;
    case LBRACE:
      ConstraintAttribute();
      break;
    default:
      jj_la1[16] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
            {if (true) return s;}
    throw new Error("Missing return statement in function");
  }

//<default-attribute> ::= (default ?DERIVE | ?NONE | <expression>*) | (default-dynamic <expression>*)
//<default-attribute> ::= (default ?DERIVE | ?NONE | <expression>*) | (default-dynamic <expression>*)
  final public SlotAttrib DefaultAttribute() throws ParseException {
                                        SlotAttrib s=new SlotAttrib(); Node n;
    jj_consume_token(DEFAULT_ATR);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ATR_DERIVE:
      jj_consume_token(ATR_DERIVE);
                               s.setDefaultDerive();
      break;
    case ATR_NONE:
      jj_consume_token(ATR_NONE);
                             s.setDefaultNone();
      break;
    default:
      jj_la1[17] = jj_gen;
      n = ActionList();
                                 s.setDefaultAction(n);
    }
          {if (true) return s;}
    throw new Error("Missing return statement in function");
  }

  final public SlotAttrib DynamicAttribute() throws ParseException {
                                        SlotAttrib s=new SlotAttrib(); Node n;
    jj_consume_token(DYNAMIC_ATR);
    n = ActionList();
                                 s.setDynamic(n);
                  {if (true) return s;}
    throw new Error("Missing return statement in function");
  }

/* Fact Specification
<RHS-pattern> ::= <ordered-RHS-pattern> | <template-RHS-pattern>
<ordered-RHS-pattern> ::= (<symbol> <RHS-field>+)
<template-RHS-pattern> ::= (<deftemplate-name> <RHS-slot>*)
<RHS-slot> ::= <single-field-RHS-slot> | <multifield-RHS-slot>
<single-field-RHS-slot> ::= (<slot-name> <RHS-field>)
<multifield-RHS-slot> ::= (<slot-name> <RHS-field>*)
<RHS-field> ::= <variable> | <constant> | <function-call>
*/
  final public void RHSPattern() throws ParseException {
    jj_consume_token(LBRACE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SYMBOL:
      OrderedRHSPattern();
      break;
    case LBRACE:
      TemplateRHSPattern();
      break;
    default:
      jj_la1[18] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(RBRACE);
  }

//<ordered-RHS-pattern> ::= (<symbol> <RHS-field>+)
  final public void OrderedRHSPattern() throws ParseException {
                            /*@bgen(jjtree) OrderedRHSPattern */
                             COOLOrderedRHSPattern jjtn000 = new COOLOrderedRHSPattern(this, JJTORDEREDRHSPATTERN);
                             boolean jjtc000 = true;
                             jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(SYMBOL);
      jjtn000.setName(t.image);
      label_6:
      while (true) {
        Expression();
        if (jj_2_3(2)) {
          ;
        } else {
          break label_6;
        }
      }
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

//<template-RHS-pattern> ::= (<deftemplate-name> <RHS-slot>*)
  final public void TemplateRHSPattern() throws ParseException {
                            /*@bgen(jjtree) TemplateRHSPattern */
                             COOLTemplateRHSPattern jjtn000 = new COOLTemplateRHSPattern(this, JJTTEMPLATERHSPATTERN);
                             boolean jjtc000 = true;
                             jjtree.openNodeScope(jjtn000);Token t;
    try {
      jj_consume_token(LBRACE);
      t = jj_consume_token(SYMBOL);
          jjtn000.setName(t.image);
      label_7:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LBRACE:
        case SYMBOL:
          ;
          break;
        default:
          jj_la1[19] = jj_gen;
          break label_7;
        }
        RHSSlot();
      }
      jj_consume_token(RBRACE);
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

//<RHS-slot> ::= <single-field-RHS-slot> | <multifield-RHS-slot>
  final public void RHSSlot() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LBRACE:
      jj_consume_token(LBRACE);
      SingleFieldRHSSlot();
      break;
    case SYMBOL:
      MultifieldRHSSlot();
      jj_consume_token(RBRACE);
      break;
    default:
      jj_la1[20] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

//<single-field-RHS-slot> ::= (<slot-name> <RHS-field>)
  final public void SingleFieldRHSSlot() throws ParseException {
                            /*@bgen(jjtree) SingleFieldRHSSlot */
                             COOLSingleFieldRHSSlot jjtn000 = new COOLSingleFieldRHSSlot(this, JJTSINGLEFIELDRHSSLOT);
                             boolean jjtc000 = true;
                             jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(SYMBOL);
          jjtn000.setName(t.image);
      Expression();
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

//<multifield-RHS-slot> ::= (<slot-name> <RHS-field>*)
  final public void MultifieldRHSSlot() throws ParseException {
                           /*@bgen(jjtree) MultifieldRHSSlot */
                            COOLMultifieldRHSSlot jjtn000 = new COOLMultifieldRHSSlot(this, JJTMULTIFIELDRHSSLOT);
                            boolean jjtc000 = true;
                            jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(SYMBOL);
          jjtn000.setName(t.image);
      label_8:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LBRACE:
        case INTEGER:
        case FLOAT:
        case STRING:
        case INSTANCE:
        case SINGLEVAR:
        case MULTIVAR:
        case GLOBALVAR:
        case SYMBOL:
          ;
          break;
        default:
          jj_la1[21] = jj_gen;
          break label_8;
        }
        Expression();
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

//<RHS-field> ::= <variable> | <constant> | <function-call>
// Same as expression
/*void RHSField() #void : {}
{
    Variable() | Constant() | FunctionCall()
}*/

/* Defrule Construct
<defrule-construct> 
	::= (defrule <rule-name> [<comment>] [<declaration>] <conditional-element>* => <action>*) 
<declaration> ::= (declare <rule-property>+)
<rule-property> ::= (salience <integer-expression>) | (auto-focus <boolean-symbol>)
<boolean-symbol> ::= TRUE | FALSE
<conditional-element> ::= <pattern-CE> | <assigned-pattern-CE> | <not-CE> | <and-CE> | <or-CE> |
	<logical-CE> | <test-CE> | <exists-CE> | <forall-CE>
<pattern-CE> ::= <ordered-pattern-CE> | <template-pattern-CE> | <object-pattern-CE>
<assigned-pattern-CE> ::= <single-field-variable> <- <pattern-CE>
<not-CE> ::= (not <conditional-element>)
<and-CE> ::= (and <conditional-element>+)
<or-CE> ::= (or <conditional-element>+)
<logical-CE> ::= (logical <conditional-element>+)
<test-CE> ::= (test <function-call>)
<exists-CE> ::= (exists <conditional-element>+)
<forall-CE> ::= (forall <conditional-element> <conditional-element>+)
<ordered-pattern-CE> ::= (<symbol> <constraint>*)
<template-pattern-CE> ::= (<deftemplate-name> <LHS-slot>*)
<object-pattern-CE> ::= (object <attribute-constraint>*)
<attribute-constraint> ::= (is-a <constraint>) | (name <constraint>) | (<slot-name> <constraint>*)
<LHS-slot> ::= <single-field-LHS-slot> | <multifield-LHS-slot>
<single-field-LHS-slot> ::= (<slot-name> <constraint>)
<multifield-LHS-slot> ::= (<slot-name> <constraint>*)
<constraint> ::= ? | $? | <connected-constraint>
<connected-constraint>::= <single-constraint> | <single-constraint> & <connected-constraint> |
	<single-constraint> | <connected-constraint>
<single-constraint> ::= <term> | ~<term>
<term> ::= <constant> | <single-field-variable> | <multifield-variable> | 
	:<function-call> | =<function-call>
*/
  final public void DefruleConstruct() throws ParseException {
                          /*@bgen(jjtree) DefruleConstruct */
                           COOLDefruleConstruct jjtn000 = new COOLDefruleConstruct(this, JJTDEFRULECONSTRUCT);
                           boolean jjtc000 = true;
                           jjtree.openNodeScope(jjtn000);Token t; Node n; Condition ce;
    try {
      jj_consume_token(DEFRULE);
      //	( LOOKAHEAD(3)
      //		( 
      //			t=<SYMBOL>
      //			{ jjtThis.setName(t.image); }//name
      //		) |	(
                              t = jj_consume_token(SYMBOL);
                          jjtn000.setName(t.image);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STRING:
        t = jj_consume_token(STRING);
                                       jjtn000.setDocString(t.image);
        break;
      default:
        jj_la1[22] = jj_gen;
        ;
      }
      if (jj_2_4(3)) {
        Declaration(jjtn000);
        label_9:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case LBRACE:
            ;
            break;
          default:
            jj_la1[23] = jj_gen;
            break label_9;
          }
          ce = ConditionalElement();
        }
      } else {
        label_10:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case LBRACE:
            ;
            break;
          default:
            jj_la1[24] = jj_gen;
            break label_10;
          }
          ce = ConditionalElement();
                                   jjtn000.addCondition(ce);
        }
      }
      jj_consume_token(ARROW);
      n = ActionList();
                         jjtree.closeNodeScope(jjtn000, true);
                         jjtc000 = false;
                         jjtn000.setRuleActions(n);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

////////////////////////////
// Conditional elements should not produce nodes, 
// but conditions as in package org.jamocha.rule

// Create Dummy node to have fixed number of chlidren in Defrule
/*Node CEList():{} 
{ 
	(ConditionalElement())* {}
	{ return jjtThis; }
}
*/

// Create Dummy node to have fixed number of chlidren in Defrule
  final public Node ActionList() throws ParseException {
                   /*@bgen(jjtree) ActionList */
  COOLActionList jjtn000 = new COOLActionList(this, JJTACTIONLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      label_11:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LBRACE:
        case INTEGER:
        case FLOAT:
        case STRING:
        case INSTANCE:
        case SINGLEVAR:
        case MULTIVAR:
        case GLOBALVAR:
        case SYMBOL:
          ;
          break;
        default:
          jj_la1[25] = jj_gen;
          break label_11;
        }
        Expression();
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

/*
// Create Dummy node to have fixed number of chlidren later
Node CEList2():{} 
{ 
	(ConditionalElement())+ 
	{ return jjtThis; }
}
*/

//<declaration> ::= (declare <rule-property>+)
  final public void Declaration(COOLDefruleConstruct r) throws ParseException {
    jj_consume_token(LBRACE);
    jj_consume_token(DECLARE);
    label_12:
    while (true) {
      RuleProperty(r);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACE:
        ;
        break;
      default:
        jj_la1[26] = jj_gen;
        break label_12;
      }
    }
    jj_consume_token(RBRACE);
  }

//<rule-property> ::= (salience <integer-expression>) | (auto-focus <boolean-symbol>)
  final public void RuleProperty(COOLDefruleConstruct r) throws ParseException {
                                                   Node n;
    jj_consume_token(LBRACE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SALIENCE:
      jj_consume_token(SALIENCE);
      //todo:        <integer-expression>
                              // Ory: Just use expression and check for it being an integer at runtime (it could use global variables)
                              // Need to determine salience at runtime!!
                              n = Expression();
                                         r.setSalienceExpression(n);

      break;
    case AUTOFOCUS:
      jj_consume_token(AUTOFOCUS);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TRUE:
        jj_consume_token(TRUE);
                                 r.setAutoFocus(true);
        break;
      case FALSE:
        jj_consume_token(FALSE);
                                  r.setAutoFocus(false);
        break;
      default:
        jj_la1[27] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[28] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(RBRACE);
  }

//<boolean-symbol> ::= TRUE | FALSE
  final public void BooleanSymbol() throws ParseException {
                        /*@bgen(jjtree) BooleanSymbol */
                         COOLBooleanSymbol jjtn000 = new COOLBooleanSymbol(this, JJTBOOLEANSYMBOL);
                         boolean jjtc000 = true;
                         jjtree.openNodeScope(jjtn000);Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TRUE:
        t = jj_consume_token(TRUE);
                   jjtree.closeNodeScope(jjtn000, true);
                   jjtc000 = false;
                   jjtn000.setName(t.image); jjtn000.setToTrue();
        break;
      case FALSE:
        t = jj_consume_token(FALSE);
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                    jjtn000.setName(t.image); jjtn000.setToFalse();
        break;
      default:
        jj_la1[29] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

//<conditional-element> ::= <pattern-CE> | <assigned-pattern-CE> | <not-CE> | <and-CE> | <or-CE> |
//                          <logical-CE> | <test-CE> | <exists-CE> | <forall-CE>
  final public Condition ConditionalElement() throws ParseException {
                                         Condition ce;
    jj_consume_token(LBRACE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OBJECT:
    case SYMBOL:
      ce = PatternCE();
      break;
    case SINGLEVAR:
      ce = AssignedPatternCE();
      break;
    case NOT:
    case AND:
    case OR:
      ce = BooleanFunction();
      break;
    case LOGICAL:
      ce = LogicalCE();
      break;
    case TEST:
      ce = TestCE();
      break;
    case EXISTS:
      ce = ExistsCE();
      break;
    case FORALL:
      ce = ForallCE();
      break;
    default:
      jj_la1[30] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(RBRACE);
          {if (true) return ce;}
    throw new Error("Missing return statement in function");
  }

// Create and return conditions
  final public Condition BooleanFunction() throws ParseException {
                                      Condition ce=null,child;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NOT:
      jj_consume_token(NOT);

      child = ConditionalElement();

      break;
    case AND:
    case OR:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AND:
        jj_consume_token(AND);
                                        ce=new AndCondition();
        label_13:
        while (true) {
          child = ConditionalElement();

          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case LBRACE:
            ;
            break;
          default:
            jj_la1[31] = jj_gen;
            break label_13;
          }
        }
        break;
      case OR:
        jj_consume_token(OR);
                                       ce=new AndCondition();
        label_14:
        while (true) {
          child = ConditionalElement();

          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case LBRACE:
            ;
            break;
          default:
            jj_la1[32] = jj_gen;
            break label_14;
          }
        }
        break;
      default:
        jj_la1[33] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[34] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                  {if (true) return ce;}
    throw new Error("Missing return statement in function");
  }

//<pattern-CE> ::= <ordered-pattern-CE> | <template-pattern-CE> | <object-pattern-CE>
// Create and return conditions
  final public Condition PatternCE() throws ParseException {
                                 Condition ce;
    if (jj_2_5(2)) {
      ce = OrderedPatternCE();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SYMBOL:
        ce = TemplatePatternCE();
        break;
      case OBJECT:
        ce = ObjectPatternCE();
        break;
      default:
        jj_la1[35] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
            {if (true) return ce;}
    throw new Error("Missing return statement in function");
  }

//<assigned-pattern-CE> ::= <single-field-variable> <- <pattern-CE>
// Create and return conditions 	--	NOT IMPLEMENTED!!
  final public Condition AssignedPatternCE() throws ParseException {
    SingleVariable();
    jj_consume_token(ASSIGN);
    PatternCE();
        {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

//<logical-CE> ::= (logical <conditional-element>+)
// Create and return conditions	--	NOT IMPLEMENTED!!
  final public Condition LogicalCE() throws ParseException {
    jj_consume_token(LOGICAL);
    label_15:
    while (true) {
      ConditionalElement();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACE:
        ;
        break;
      default:
        jj_la1[36] = jj_gen;
        break label_15;
      }
    }
      {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

//<test-CE> ::= (test <function-call>)
// Create and return conditions (needs to initialize function 
// before execution, thus it gets a node
  final public Condition TestCE() throws ParseException {
                      /*@bgen(jjtree) TestCE */
                       COOLTestCE jjtn000 = new COOLTestCE(this, JJTTESTCE);
                       boolean jjtc000 = true;
                       jjtree.openNodeScope(jjtn000);TestCondition ce=new TestCondition(); Token t;
    try {
      jj_consume_token(TEST);
      t = jj_consume_token(SYMBOL);
                             jjtn000.setName(t.image); jjtn000.setCondition(ce);
            jjtree.closeNodeScope(jjtn000, true);
            jjtc000 = false;
            {if (true) return ce;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

//<exists-CE> ::= (exists <conditional-element>+)
// Create and return conditions
  final public Condition ExistsCE() throws ParseException {
        Condition child;
        ExistCondition ce=new ExistCondition();
    jj_consume_token(EXISTS);
    label_16:
    while (true) {
      child = ConditionalElement();
                                             ce.addNestedConditionElement(child);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACE:
        ;
        break;
      default:
        jj_la1[37] = jj_gen;
        break label_16;
      }
    }
      {if (true) return ce;}
    throw new Error("Missing return statement in function");
  }

//<forall-CE> ::= (forall <conditional-element> <conditional-element>+)
// Create and return conditions	--	NOT IMPLEMENTED!!
  final public Condition ForallCE() throws ParseException {
    jj_consume_token(FORALL);
    ConditionalElement();
    label_17:
    while (true) {
      ConditionalElement();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACE:
        ;
        break;
      default:
        jj_la1[38] = jj_gen;
        break label_17;
      }
    }
                 {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

//<ordered-pattern-CE> ::= (<symbol> <constraint>*)
  final public Condition OrderedPatternCE() throws ParseException {
 /*@bgen(jjtree) OrderedPatternCE */
        COOLOrderedPatternCE jjtn000 = new COOLOrderedPatternCE(this, JJTORDEREDPATTERNCE);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);Token t;
        Condition ce=null;
    try {
      t = jj_consume_token(SYMBOL);
                          jjtn000.setName(t.image);
      label_18:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case INTEGER:
        case FLOAT:
        case STRING:
        case INSTANCE:
        case SINGLEVAR:
        case MULTIVAR:
        case SFWILDCARD:
        case MFWILDCARD:
        case TILDE:
        case COLON:
        case EQUALS:
        case SYMBOL:
          ;
          break;
        default:
          jj_la1[39] = jj_gen;
          break label_18;
        }
        Constraint();
      }
                          jjtree.closeNodeScope(jjtn000, true);
                          jjtc000 = false;
                    {if (true) return ce;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

//<template-pattern-CE> ::= (<deftemplate-name> <LHS-slot>*)
  final public Condition TemplatePatternCE() throws ParseException {
 /*@bgen(jjtree) TemplatePatternCE */
        COOLTemplatePatternCE jjtn000 = new COOLTemplatePatternCE(this, JJTTEMPLATEPATTERNCE);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);Token t;
        Condition ce=null;
    try {
      t = jj_consume_token(SYMBOL);

      label_19:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SYMBOL:
          ;
          break;
        default:
          jj_la1[40] = jj_gen;
          break label_19;
        }
        LHSSlot();
      }
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
            {if (true) return ce;}
    } catch (Throwable jjte000) {
                  if (jjtc000) {
                    jjtree.clearNodeScope(jjtn000);
                    jjtc000 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte000 instanceof RuntimeException) {
                    {if (true) throw (RuntimeException)jjte000;}
                  }
                  if (jjte000 instanceof ParseException) {
                    {if (true) throw (ParseException)jjte000;}
                  }
                  {if (true) throw (Error)jjte000;}
    } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                  }
    }
    throw new Error("Missing return statement in function");
  }

//<object-pattern-CE> ::= (object <attribute-constraint>*)
// Create and return conditions (use exist condition!!)
  final public Condition ObjectPatternCE() throws ParseException {
        ObjectCondition ce=new ObjectCondition();
        Constraint c;
    jj_consume_token(OBJECT);
    label_20:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACE:
      case SYMBOL:
        ;
        break;
      default:
        jj_la1[41] = jj_gen;
        break label_20;
      }
      c = AttributeConstraint();
                          ce.addConstraint(c);
    }
                          {if (true) return ce;}
    throw new Error("Missing return statement in function");
  }

//<attribute-constraint> ::= (is-a <constraint>) | (name <constraint>) | (<slot-name> <constraint>*)
// Create and return conditions (Are these implemented??)
  final public Constraint AttributeConstraint() throws ParseException {
        Token t;
        Constraint c=null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LBRACE:
      jj_consume_token(LBRACE);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IS_A:
        jj_consume_token(IS_A);

        break;
      case NAME:
        jj_consume_token(NAME);

        break;
      default:
        jj_la1[42] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      Constraint();
      break;
    case SYMBOL:
      t = jj_consume_token(SYMBOL);

      label_21:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case INTEGER:
        case FLOAT:
        case STRING:
        case INSTANCE:
        case SINGLEVAR:
        case MULTIVAR:
        case SFWILDCARD:
        case MFWILDCARD:
        case TILDE:
        case COLON:
        case EQUALS:
        case SYMBOL:
          ;
          break;
        default:
          jj_la1[43] = jj_gen;
          break label_21;
        }
        Constraint();
      }
      jj_consume_token(RBRACE);
          {if (true) return c;}
      break;
    default:
      jj_la1[44] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

// Functionally identical !?
//<single-field-LHS-slot> ::= (<slot-name> <constraint>)
//<multifield-LHS-slot> ::= (<slot-name> <constraint>*)
//<LHS-slot> ::= <single-field-LHS-slot> | <multifield-LHS-slot>
  final public void LHSSlot() throws ParseException {
                   /*@bgen(jjtree) LHSSlot */
                    COOLLHSSlot jjtn000 = new COOLLHSSlot(this, JJTLHSSLOT);
                    boolean jjtc000 = true;
                    jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(SYMBOL);
          jjtn000.setName(t.image);
      label_22:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case INTEGER:
        case FLOAT:
        case STRING:
        case INSTANCE:
        case SINGLEVAR:
        case MULTIVAR:
        case SFWILDCARD:
        case MFWILDCARD:
        case TILDE:
        case COLON:
        case EQUALS:
        case SYMBOL:
          ;
          break;
        default:
          jj_la1[45] = jj_gen;
          break label_22;
        }
        Constraint();
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

//<constraint> ::= ? | $? | <connected-constraint>
  final public void Constraint() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SFWILDCARD:
      SingleFieldWildcard();
      break;
    case MFWILDCARD:
      MultiFieldWildcard();
      break;
    case INTEGER:
    case FLOAT:
    case STRING:
    case INSTANCE:
    case SINGLEVAR:
    case MULTIVAR:
    case TILDE:
    case COLON:
    case EQUALS:
    case SYMBOL:
      ConnectedConstraint();
      break;
    default:
      jj_la1[46] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void SingleFieldWildcard() throws ParseException {
                              /*@bgen(jjtree) SingleFieldWildcard */
  COOLSingleFieldWildcard jjtn000 = new COOLSingleFieldWildcard(this, JJTSINGLEFIELDWILDCARD);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(SFWILDCARD);
    } finally {
                                    if (jjtc000) {
                                      jjtree.closeNodeScope(jjtn000, true);
                                    }
    }
  }

  final public void MultiFieldWildcard() throws ParseException {
                             /*@bgen(jjtree) MultiFieldWildcard */
  COOLMultiFieldWildcard jjtn000 = new COOLMultiFieldWildcard(this, JJTMULTIFIELDWILDCARD);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(MFWILDCARD);
    } finally {
                                   if (jjtc000) {
                                     jjtree.closeNodeScope(jjtn000, true);
                                   }
    }
  }

//<connected-constraint>::= <single-constraint> | <single-constraint> & <connected-constraint> |
//	<single-constraint> | <connected-constraint>

// THIS IS WRONG: Ampersands and lines can be mixed!!
  final public void ConnectedConstraint() throws ParseException {
                              /*@bgen(jjtree) ConnectedConstraint */
  COOLConnectedConstraint jjtn000 = new COOLConnectedConstraint(this, JJTCONNECTEDCONSTRAINT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      Term();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AMPERSAND:
      case LINE:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case AMPERSAND:
          jj_consume_token(AMPERSAND);
          ConnectedConstraint();
                                                      jjtn000.setTypeAnd();
          break;
        case LINE:
          jj_consume_token(LINE);
          ConnectedConstraint();
                                                 jjtn000.setTypeOr();
          break;
        default:
          jj_la1[47] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[48] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
                  if (jjtc000) {
                    jjtree.clearNodeScope(jjtn000);
                    jjtc000 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte000 instanceof RuntimeException) {
                    {if (true) throw (RuntimeException)jjte000;}
                  }
                  if (jjte000 instanceof ParseException) {
                    {if (true) throw (ParseException)jjte000;}
                  }
                  {if (true) throw (Error)jjte000;}
    } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                  }
    }
  }

//<term> ::= <constant> | <single-field-variable> | <multifield-variable> | 
//	:<function-call> | =<function-call>
  final public void Term() throws ParseException {
                /*@bgen(jjtree) Term */
  COOLTerm jjtn000 = new COOLTerm(this, JJTTERM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TILDE:
        jj_consume_token(TILDE);
                          jjtn000.setNegate(true);
        break;
      default:
        jj_la1[49] = jj_gen;
        ;
      }
      if (jj_2_6(3)) {
        Constant();
                             jjtree.closeNodeScope(jjtn000, true);
                             jjtc000 = false;
                             jjtn000.setType(COOLTerm.T_CONST);
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SINGLEVAR:
          SingleVariable();
                           jjtree.closeNodeScope(jjtn000, true);
                           jjtc000 = false;
                           jjtn000.setType(COOLTerm.T_SINGLE);
          break;
        case MULTIVAR:
          MultiVariable();
                          jjtree.closeNodeScope(jjtn000, true);
                          jjtc000 = false;
                          jjtn000.setType(COOLTerm.T_MULTI);
          break;
        case COLON:
          jj_consume_token(COLON);
          FunctionCall();
                                    jjtree.closeNodeScope(jjtn000, true);
                                    jjtc000 = false;
                                    jjtn000.setType(COOLTerm.T_COLON);
          break;
        case EQUALS:
          jj_consume_token(EQUALS);
          FunctionCall();
                                     jjtree.closeNodeScope(jjtn000, true);
                                     jjtc000 = false;
                                     jjtn000.setType(COOLTerm.T_EQ);
          break;
        default:
          jj_la1[50] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

/* Defglobal Construct
<defglobal-construct> ::= (defglobal [<defmodule-name>] <global-assignment>*)
<global-assignment> ::= <global-variable> = <expression>
<global-variable> ::= ?*<symbol>*
*/

//<defglobal-construct> ::= (defglobal [<defmodule-name>] <global-assignment>*)
  final public void DefglobalConstruct() throws ParseException {
                             /*@bgen(jjtree) DefglobalConstruct */
                              COOLDefglobalConstruct jjtn000 = new COOLDefglobalConstruct(this, JJTDEFGLOBALCONSTRUCT);
                              boolean jjtc000 = true;
                              jjtree.openNodeScope(jjtn000);Token t;
    try {
      jj_consume_token(DEFGLOBAL);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SYMBOL:
        t = jj_consume_token(SYMBOL);
              jjtn000.setName(t.image);
        break;
      default:
        jj_la1[51] = jj_gen;
        ;
      }
      label_23:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case GLOBALVAR:
          ;
          break;
        default:
          jj_la1[52] = jj_gen;
          break label_23;
        }
        GlobalAssignment();
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

//<global-assignment> ::= <global-variable> = <expression>
  final public void GlobalAssignment() throws ParseException {
                            /*@bgen(jjtree) GlobalAssignment */
                             COOLGlobalAssignment jjtn000 = new COOLGlobalAssignment(this, JJTGLOBALASSIGNMENT);
                             boolean jjtc000 = true;
                             jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(GLOBALVAR);
          jjtn000.setName(t.image);
      jj_consume_token(EQUALS);
      Expression();
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

/* Deffunction Construct
<deffunction-construct> 
	::= (deffunction <name> [<comment>] (<regular-parameter>* [<wildcard-parameter>]) <action>*)
<regular-parameter> ::= <single-field-variable>
<wildcard-parameter> ::= <multifield-variable>
*/

//<deffunction-construct> 
//	::= (deffunction <name> [<comment>] (<regular-parameter>* [<wildcard-parameter>]) <action>*)
  final public void DeffunctionConstruct() throws ParseException {
                               /*@bgen(jjtree) DeffunctionConstruct */
                                COOLDeffunctionConstruct jjtn000 = new COOLDeffunctionConstruct(this, JJTDEFFUNCTIONCONSTRUCT);
                                boolean jjtc000 = true;
                                jjtree.openNodeScope(jjtn000);Token t; Node n;
    try {
      jj_consume_token(DEFFUNCTION);
      t = jj_consume_token(SYMBOL);
          jjtn000.setName(t.image);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STRING:
        t = jj_consume_token(STRING);
                          jjtn000.setDocString(t.image);
        break;
      default:
        jj_la1[53] = jj_gen;
        ;
      }
      jj_consume_token(LBRACE);
      ParameterList();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MULTIVAR:
        MultiVariable();
        break;
      default:
        jj_la1[54] = jj_gen;
        ;
      }
      jj_consume_token(RBRACE);
      n = ActionList();
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtn000.setFunctionActions(n);
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

//<regular-parameter> ::= <single-field-variable>
  final public void ParameterList() throws ParseException {
    label_24:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SINGLEVAR:
        ;
        break;
      default:
        jj_la1[55] = jj_gen;
        break label_24;
      }
      jj_consume_token(SINGLEVAR);

    }
  }

/* Ignored, produces multifield variable directly
//<wildcard-parameter> ::= <multifield-variable>
void WildcardParameter()  #void : {}
{
    <MULTIVAR>
}
*/

/* Defgeneric Construct
<defgeneric-construct> ::= (defgeneric <name> [<comment>])
*/
  final public void DefgenericConstruct() throws ParseException {
                              /*@bgen(jjtree) DefgenericConstruct */
                               COOLDefgenericConstruct jjtn000 = new COOLDefgenericConstruct(this, JJTDEFGENERICCONSTRUCT);
                               boolean jjtc000 = true;
                               jjtree.openNodeScope(jjtn000);Token t;
    try {
      jj_consume_token(DEFGENERIC);
      t = jj_consume_token(SYMBOL);
          jjtn000.setName(t.image);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STRING:
        t = jj_consume_token(STRING);
                          jjtn000.setDocString(t.image);
        break;
      default:
        jj_la1[56] = jj_gen;
        ;
      }
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

/* Defmethod Construct
<defmethod-construct> ::= (defmethod <name> [<index>] [<comment>] (<parameter-restriction>*
	[<wildcard-parameter-restriction>]) <action>*)
<parameter-restriction> ::= <single-field-variable> | (<single-field-variable> <type>* [<query>])
<wildcard-parameter-restriction> ::= <multifield-variable> | (<multifield-variable> <type>* [<query>])
<type> ::= <class-name>
<query> ::= <global-variable> | <function-call>
*/

/////////////////////////////////////
  final public void DefmethodConstruct() throws ParseException {
                             /*@bgen(jjtree) DefmethodConstruct */
                              COOLDefmethodConstruct jjtn000 = new COOLDefmethodConstruct(this, JJTDEFMETHODCONSTRUCT);
                              boolean jjtc000 = true;
                              jjtree.openNodeScope(jjtn000);Token t;
    try {
      jj_consume_token(DEFMETHOD);
      t = jj_consume_token(SYMBOL);
          jjtn000.setName(t.image);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INTEGER:
        t = jj_consume_token(INTEGER);
                  jjtn000.setIndex(t.image);
        break;
      default:
        jj_la1[57] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STRING:
        t = jj_consume_token(STRING);
                  jjtn000.setDocString(t.image);
        break;
      default:
        jj_la1[58] = jj_gen;
        ;
      }
      jj_consume_token(LBRACE);
      label_25:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LBRACE:
        case SINGLEVAR:
          ;
          break;
        default:
          jj_la1[59] = jj_gen;
          break label_25;
        }
        ParameterRestriction();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACE:
      case MULTIVAR:
        WildcardParameterRestriction();
        break;
      default:
        jj_la1[60] = jj_gen;
        ;
      }
      jj_consume_token(RBRACE);
      ActionList();
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

//<parameter-restriction> ::= <single-field-variable> | (<single-field-variable> <type>* [<query>])
  final public void ParameterRestriction() throws ParseException {
                               /*@bgen(jjtree) ParameterRestriction */
  COOLParameterRestriction jjtn000 = new COOLParameterRestriction(this, JJTPARAMETERRESTRICTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      if (jj_2_7(2)) {
        jj_consume_token(SINGLEVAR);
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LBRACE:
          jj_consume_token(LBRACE);
          jj_consume_token(SINGLEVAR);
          label_26:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case SYMBOL:
              ;
              break;
            default:
              jj_la1[61] = jj_gen;
              break label_26;
            }
            Type();
          }
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case LBRACE:
          case GLOBALVAR:
            Query();
            break;
          default:
            jj_la1[62] = jj_gen;
            ;
          }
          jj_consume_token(RBRACE);
          break;
        default:
          jj_la1[63] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

//<wildcard-parameter-restriction> ::= <multifield-variable> | (<multifield-variable> <type>* [<query>])
  final public void WildcardParameterRestriction() throws ParseException {
                                       /*@bgen(jjtree) WildcardParameterRestriction */
  COOLWildcardParameterRestriction jjtn000 = new COOLWildcardParameterRestriction(this, JJTWILDCARDPARAMETERRESTRICTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      if (jj_2_8(2)) {
        jj_consume_token(MULTIVAR);
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LBRACE:
          jj_consume_token(LBRACE);
          jj_consume_token(MULTIVAR);
          label_27:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case SYMBOL:
              ;
              break;
            default:
              jj_la1[64] = jj_gen;
              break label_27;
            }
            Type();
          }
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case LBRACE:
          case GLOBALVAR:
            Query();
            break;
          default:
            jj_la1[65] = jj_gen;
            ;
          }
          jj_consume_token(RBRACE);
          break;
        default:
          jj_la1[66] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

//<type> ::= <class-name>
  final public void Type() throws ParseException {
               /*@bgen(jjtree) Type */
                COOLType jjtn000 = new COOLType(this, JJTTYPE);
                boolean jjtc000 = true;
                jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(SYMBOL);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtn000.setName(t.image);
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

//<query> ::= <global-variable> | <function-call>
  final public void Query() throws ParseException {
                /*@bgen(jjtree) Query */
                 COOLQuery jjtn000 = new COOLQuery(this, JJTQUERY);
                 boolean jjtc000 = true;
                 jjtree.openNodeScope(jjtn000);Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case GLOBALVAR:
        GlobalVariable();
        break;
      case LBRACE:
        FunctionCall();
        break;
      default:
        jj_la1[67] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
                  if (jjtc000) {
                    jjtree.clearNodeScope(jjtn000);
                    jjtc000 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte000 instanceof RuntimeException) {
                    {if (true) throw (RuntimeException)jjte000;}
                  }
                  if (jjte000 instanceof ParseException) {
                    {if (true) throw (ParseException)jjte000;}
                  }
                  {if (true) throw (Error)jjte000;}
    } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                  }
    }
  }

/*	Defclass Construct
<defclass-construct> ::= (defclass <name> [<comment>] (is-a <superclass-name>+)
	[<role>] [<pattern-match-role>] <slot>* <handler-documentation>*)
<role> ::= (role concrete | abstract)
<pattern-match-role> ::= (pattern-match reactive | non-reactive)
<slot> ::= (slot <name> <facet>*) | (single-slot <name> <facet>*) | (multislot <name> <facet>*)
<facet> ::= <default-facet> | <storage-facet> | <access-facet> | <propagation-facet> | 
	<source-facet> | <pattern-match-facet> | <visibility-facet> | 
	<create-accessor-facet> <override-message-facet> | <constraint-attribute>
<default-facet> ::= (default ?DERIVE | ?NONE | <expression>*) | (default-dynamic <expression>*)
<storage-facet> ::= (storage local | shared) 
<access-facet> ::= (access read-write | read-only | initialize-only) 
<propagation-facet> ::= (propagation inherit | no-inherit)
<source-facet> ::= (source exclusive | composite)
<pattern-match-facet> ::= (pattern-match reactive | non-reactive)
<visibility-facet> ::= (visibility private | public)
<create-accessor-facet> ::= (create-accessor ?NONE | read | write | read-write)
<override-message-facet> ::= (override-message ?DEFAULT | <message-name>)
<handler-documentation> ::= (message-handler <name> [<handler-type>])
<handler-type> ::= primary | around | before | after
*/
//<defclass-construct> ::= (defclass <name> [<comment>] (is-a <superclass-name>+)
//	[<role>] [<pattern-match-role>] <slot>* <handler-documentation>*)
  final public void DefclassConstruct() throws ParseException {
                            /*@bgen(jjtree) DefclassConstruct */
                             COOLDefclassConstruct jjtn000 = new COOLDefclassConstruct(this, JJTDEFCLASSCONSTRUCT);
                             boolean jjtc000 = true;
                             jjtree.openNodeScope(jjtn000);Token t;
    try {
      jj_consume_token(DEFCLASS);
      t = jj_consume_token(SYMBOL);
          jjtn000.setName(t.image);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STRING:
        t = jj_consume_token(STRING);
                  jjtn000.setDocString(t.image);
        break;
      default:
        jj_la1[68] = jj_gen;
        ;
      }
      jj_consume_token(LBRACE);
      jj_consume_token(IS_A);
      label_28:
      while (true) {
        t = jj_consume_token(SYMBOL);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SYMBOL:
          ;
          break;
        default:
          jj_la1[69] = jj_gen;
          break label_28;
        }
      }
      jj_consume_token(RBRACE);
      if (jj_2_9(2)) {
        Role(jjtn000);
      } else {
        ;
      }
      if (jj_2_10(2)) {
        PatternMatchRole(jjtn000);
      } else {
        ;
      }
      label_29:
      while (true) {
        if (jj_2_11(2)) {
          ;
        } else {
          break label_29;
        }
        Slot();
      }
      label_30:
      while (true) {
        if (jj_2_12(2)) {
          ;
        } else {
          break label_30;
        }
        HandlerDocumentation();
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

// JUST SET ATTRIBUTE
//<role> ::= (role concrete | abstract)
  final public void Role(COOLDefclassConstruct c) throws ParseException {
    jj_consume_token(LBRACE);
    jj_consume_token(ROLE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CONCRETE:
      jj_consume_token(CONCRETE);
                                     c.setConcrete();
      break;
    case ABSTRACT:
      jj_consume_token(ABSTRACT);
                                     c.setAbstract();
      break;
    default:
      jj_la1[70] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(RBRACE);
  }

// JUST SET ATTRIBUTE
//<pattern-match-role> ::= (pattern-match reactive | non-reactive)
  final public void PatternMatchRole(COOLDefclassConstruct c) throws ParseException {
    jj_consume_token(LBRACE);
    jj_consume_token(PATTERN_MATCH);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case REACTIVE:
      jj_consume_token(REACTIVE);
                                     c.setReactive();
      break;
    case NON_REACTIVE:
      jj_consume_token(NON_REACTIVE);
                                         c.setNonReactive();
      break;
    default:
      jj_la1[71] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(RBRACE);
  }

// JUST SET RULE ATTRIBUTE?
//<slot> ::= (slot <name> <facet>*) | (single-slot <name> <facet>*) | (multislot <name> <facet>*)
  final public ClassFacet Slot() throws ParseException {
                            Token t; ClassFacet cf=new ClassFacet();
    jj_consume_token(LBRACE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SLOT:
      jj_consume_token(SLOT);
      break;
    case SINGLE_SLOT:
      jj_consume_token(SINGLE_SLOT);
      break;
    case MULTISLOT:
      jj_consume_token(MULTISLOT);
      break;
    default:
      jj_la1[72] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    t = jj_consume_token(SYMBOL);
    label_31:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACE:
        ;
        break;
      default:
        jj_la1[73] = jj_gen;
        break label_31;
      }
      Facet(cf);
    }
    jj_consume_token(RBRACE);
          {if (true) return cf;}
    throw new Error("Missing return statement in function");
  }

//<facet> ::= <default-facet> | <storage-facet> | <access-facet> | <propagation-facet> | 
//	<source-facet> | <pattern-match-facet> | <visibility-facet> | 
//	<create-accessor-facet> <override-message-facet> | <constraint-attribute>
  final public void Facet(ClassFacet cf) throws ParseException {
    jj_consume_token(LBRACE);
    if (jj_2_13(2)) {
      DefaultFacet(cf);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STORAGE:
        StorageFacet(cf);
        break;
      case ACCESS:
        AccessFacet(cf);
        break;
      case PROPAGATION:
        PropagationFacet(cf);
        break;
      case SOURCE:
      case COMPOSITE:
        SourceFacet(cf);
        break;
      case PATTERN_MATCH:
        PatternMatchFacet(cf);
        break;
      case VISIBILITY:
        VisibilityFacet(cf);
        break;
      case CREATE_ACCESSOR:
        CreateAccessorFacet(cf);
        break;
      case OVERRIDE_MESSAGE:
        OverrideMessageFacet(cf);
        break;
      case LBRACE:
        ConstraintAttribute();
        break;
      default:
        jj_la1[74] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    jj_consume_token(RBRACE);
  }

//<default-facet> ::= (default ?DERIVE | ?NONE | <expression>*) | (default-dynamic <expression>*)
  final public void DefaultFacet(ClassFacet cf) throws ParseException {
                                           Node n;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DEFAULT_ATR:
      jj_consume_token(DEFAULT_ATR);
                                cf.setDynamic(false);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ATR_DERIVE:
        jj_consume_token(ATR_DERIVE);
                                       cf.setDefaultDerive();
        break;
      case ATR_NONE:
        jj_consume_token(ATR_NONE);
                                     cf.setDefaultNone();
        break;
      default:
        jj_la1[75] = jj_gen;
        n = ActionList();
                                         cf.setDefaultAction(n);
      }
      break;
    case DYNAMIC_ATR:
      jj_consume_token(DYNAMIC_ATR);
      n = ActionList();
                                               cf.setDefaultAction(n);
      break;
    default:
      jj_la1[76] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

// JUST SET RULE ATTRIBUTE
//<storage-facet> ::= (storage local | shared)
  final public void StorageFacet(ClassFacet cf) throws ParseException {
    jj_consume_token(STORAGE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LOCAL:
      jj_consume_token(LOCAL);
                          cf.setStorageLocal(true);
      break;
    case SHARED:
      jj_consume_token(SHARED);
                           cf.setStorageLocal(false);
      break;
    default:
      jj_la1[77] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

// JUST SET RULE ATTRIBUTE
//<access-facet> ::= (access read-write | read-only | initialize-only)
  final public void AccessFacet(ClassFacet cf) throws ParseException {
    jj_consume_token(ACCESS);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case READ_WRITE:
      jj_consume_token(READ_WRITE);
                               cf.setAccessReadWrite();
      break;
    case READ_ONLY:
      jj_consume_token(READ_ONLY);
                                  cf.setAccessRead();
      break;
    case INITIALIZE_ONLY:
      jj_consume_token(INITIALIZE_ONLY);
                                    cf.setAccessInitialize();
      break;
    default:
      jj_la1[78] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

// JUST SET ATTRIBUTE
//<propagation-facet> ::= (propagation inherit | no-inherit)
  final public void PropagationFacet(ClassFacet cf) throws ParseException {
    jj_consume_token(PROPAGATION);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INHERIT:
      jj_consume_token(INHERIT);
                            cf.setInherit(true);
      break;
    case NO_INHERIT:
      jj_consume_token(NO_INHERIT);
                               cf.setInherit(false);
      break;
    default:
      jj_la1[79] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

// JUST SET ATTRIBUTE
//<source-facet> ::= (source exclusive | composite)
  final public void SourceFacet(ClassFacet cf) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SOURCE:
      jj_consume_token(SOURCE);
      jj_consume_token(EXCLUSIVE);
      break;
    case COMPOSITE:
      jj_consume_token(COMPOSITE);
      break;
    default:
      jj_la1[80] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

// JUST SET ATTRIBUTE
//<pattern-match-facet> ::= (pattern-match reactive | non-reactive)
  final public void PatternMatchFacet(ClassFacet cf) throws ParseException {
    jj_consume_token(PATTERN_MATCH);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case REACTIVE:
      jj_consume_token(REACTIVE);
                                  cf.setMatchReactive(true);
      break;
    case NON_REACTIVE:
      jj_consume_token(NON_REACTIVE);
                                 cf.setMatchReactive(false);
      break;
    default:
      jj_la1[81] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

// JUST SET RULE ATTRIBUTE
//<visibility-facet> ::= (visibility private | public)
  final public void VisibilityFacet(ClassFacet cf) throws ParseException {
    jj_consume_token(VISIBILITY);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PRIVATE:
      jj_consume_token(PRIVATE);
                            cf.setPublic(false);
      break;
    case PUBLIC:
      jj_consume_token(PUBLIC);
                           cf.setPublic(true);
      break;
    default:
      jj_la1[82] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

// JUST SET RULE ATTRIBUTE
//<create-accessor-facet> ::= (create-accessor ?NONE | read | write | read-write)
  final public void CreateAccessorFacet(ClassFacet cf) throws ParseException {
    jj_consume_token(CREATE_ACCESSOR);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ATR_NONE:
      jj_consume_token(ATR_NONE);
      break;
    case READ:
      jj_consume_token(READ);
      break;
    case WRITE:
      jj_consume_token(WRITE);
      break;
    case READ_WRITE:
      jj_consume_token(READ_WRITE);
      break;
    default:
      jj_la1[83] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

// JUST SET RULE ATTRIBUTE
//<override-message-facet> ::= (override-message ?DEFAULT | <message-name>)
  final public void OverrideMessageFacet(ClassFacet cf) throws ParseException {
                                                   Token t;
    jj_consume_token(OVERRIDE_MESSAGE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ATR_DEFAULT:
      jj_consume_token(ATR_DEFAULT);
                                cf.setMessageDefault();
      break;
    case STRING:
      t = jj_consume_token(STRING);
                               cf.setMessageName(t.image);
      break;
    default:
      jj_la1[84] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

//<handler-documentation> ::= (message-handler <name> [<handler-type>])
  final public void HandlerDocumentation() throws ParseException {
                                      Token t; int i=-1;
    jj_consume_token(MESSAGE_HANDLER);
    t = jj_consume_token(SYMBOL);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PRIMARY:
    case AROUND:
    case BEFORE:
    case AFTER:
      i = HandlerType();
      break;
    default:
      jj_la1[85] = jj_gen;
      ;
    }
  }

// JUST RETURN TYPE
//<handler-type> ::= primary | around | before | after
  final public int HandlerType() throws ParseException {
                            int i=-1;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PRIMARY:
      jj_consume_token(PRIMARY);
                                  i=0;
      break;
    case AROUND:
      jj_consume_token(AROUND);
                                  i=1;
      break;
    case BEFORE:
      jj_consume_token(BEFORE);
                                  i=2;
      break;
    case AFTER:
      jj_consume_token(AFTER);
                                  i=3;
      break;
    default:
      jj_la1[86] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
          {if (true) return i;}
    throw new Error("Missing return statement in function");
  }

/* 	Defmessage-handler Construct
	<defmessage-handler-construct> 
		::= (defmessage-handler <class-name> <message-name> [<handler-type>] 
			[<comment>] (<parameter>* [<wildcard-parameter>]) <action>*)
	<handler-type> ::= around | before | primary | after
	<parameter> ::= <single-field-variable>
	<wildcard-parameter> ::= <multifield-variable>
*/

//<defmessage-handler-construct> 
//	::= (defmessage-handler <class-name> <message-name> [<handler-type>] 
//		[<comment>] (<parameter>* [<wildcard-parameter>]) <action>*)
  final public void DefmessageHandlerConstruct() throws ParseException {
                                     /*@bgen(jjtree) DefmessageHandlerConstruct */
                                      COOLDefmessageHandlerConstruct jjtn000 = new COOLDefmessageHandlerConstruct(this, JJTDEFMESSAGEHANDLERCONSTRUCT);
                                      boolean jjtc000 = true;
                                      jjtree.openNodeScope(jjtn000);Token t;
    try {
      jj_consume_token(DEFMESSAGEHANDLER);
      t = jj_consume_token(SYMBOL);
          jjtn000.setClassName(t.image);
      //name
              t = jj_consume_token(SYMBOL);
          jjtn000.setName(t.image);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PRIMARY:
      case AROUND:
      case BEFORE:
      case AFTER:
        HandlerType();
        break;
      default:
        jj_la1[87] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STRING:
        t = jj_consume_token(STRING);
                  jjtn000.setDocString(t.image);
        break;
      default:
        jj_la1[88] = jj_gen;
        ;
      }
      jj_consume_token(LBRACE);
      label_32:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SINGLEVAR:
          ;
          break;
        default:
          jj_la1[89] = jj_gen;
          break label_32;
        }
        SingleVariable();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MULTIVAR:
        MultiVariable();
        break;
      default:
        jj_la1[90] = jj_gen;
        ;
      }
      jj_consume_token(RBRACE);
      ActionList();
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

/*	Definstances Construct
	<definstances-construct> ::= (definstances <definstances-name> [active] [<comment>] <instance-template>*)
	<instance-template> ::= (<instance-definition>)
	<instance-definition> ::= <instance-name-expression> of <class-name-expression> <slot-override>*
	<slot-override> ::= (<slot-name-expression> <expression>*)
*/

//<definstances-construct> ::= (definstances <definstances-name> [active] [<comment>] <instance-template>*)
  final public void DefinstancesConstruct() throws ParseException {
                                /*@bgen(jjtree) DefinstancesConstruct */
                                 COOLDefinstancesConstruct jjtn000 = new COOLDefinstancesConstruct(this, JJTDEFINSTANCESCONSTRUCT);
                                 boolean jjtc000 = true;
                                 jjtree.openNodeScope(jjtn000);Token t;
    try {
      jj_consume_token(DEFINSTANCES);
      t = jj_consume_token(SYMBOL);
          jjtn000.setName(t.image);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ACTIVE:
        jj_consume_token(ACTIVE);
        break;
      default:
        jj_la1[91] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STRING:
        t = jj_consume_token(STRING);
                  jjtn000.setDocString(t.image);
        break;
      default:
        jj_la1[92] = jj_gen;
        ;
      }
      label_33:
      while (true) {
        if (jj_2_14(2)) {
          ;
        } else {
          break label_33;
        }
        InstanceTemplate();
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

//<instance-template> ::= (<instance-definition>)
  final public void InstanceTemplate() throws ParseException {
    jj_consume_token(LBRACE);
    InstanceDefinition();
    jj_consume_token(RBRACE);
  }

//<instance-definition> ::= <instance-name-expression> of <class-name-expression> <slot-override>*
  final public void InstanceDefinition() throws ParseException {
                                    Token t;
    // Should have two expressions returning the correct types, not symbols!!
            t = jj_consume_token(SYMBOL);
    jj_consume_token(OF);
    t = jj_consume_token(SYMBOL);
    label_34:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACE:
        ;
        break;
      default:
        jj_la1[93] = jj_gen;
        break label_34;
      }
      SlotOverride();
    }
  }

//<slot-override> ::= (<slot-name-expression> <expression>*)
  final public void SlotOverride() throws ParseException {
                              Token t;
    jj_consume_token(LBRACE);
    t = jj_consume_token(SYMBOL);
    ActionList();
    jj_consume_token(RBRACE);
  }

/*	Defmodule Construct
	<defmodule-construct> ::= (defmodule <module-name> [<comment>] <port-specification>*)
	<port-specification> ::= (export <port-item>) | (import <module-name> <port-item>)
	<port-item> ::= ?ALL | ?NONE | <port-construct> ?ALL | 
		<port-construct> ?NONE | <port-construct> <construct-name>+
	<port-construct> ::= deftemplate_construct | defclass | defglobal | deffunction | defgeneric
*/

//<defmodule-construct> ::= (defmodule <module-name> [<comment>] <port-specification>*)
  final public void DefmoduleConstruct() throws ParseException {
                             /*@bgen(jjtree) DefmoduleConstruct */
                              COOLDefmoduleConstruct jjtn000 = new COOLDefmoduleConstruct(this, JJTDEFMODULECONSTRUCT);
                              boolean jjtc000 = true;
                              jjtree.openNodeScope(jjtn000);Token t;
    try {
      jj_consume_token(DEFMODULE);
      t = jj_consume_token(SYMBOL);
          jjtn000.setName(t.image);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SYMBOL:
        t = jj_consume_token(SYMBOL);
                  jjtn000.setDocString(t.image);
        break;
      default:
        jj_la1[94] = jj_gen;
        ;
      }
      label_35:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LBRACE:
        case IMPORT:
          ;
          break;
        default:
          jj_la1[95] = jj_gen;
          break label_35;
        }
        PortSpecification();
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

//<port-specification> ::= (export <port-item>) | (import <module-name> <port-item>)
  final public void PortSpecification() throws ParseException {
                            /*@bgen(jjtree) PortSpecification */
                             COOLPortSpecification jjtn000 = new COOLPortSpecification(this, JJTPORTSPECIFICATION);
                             boolean jjtc000 = true;
                             jjtree.openNodeScope(jjtn000);Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACE:
        jj_consume_token(LBRACE);
        jj_consume_token(EXPORT);
        PortItem();
        break;
      case IMPORT:
        jj_consume_token(IMPORT);
        t = jj_consume_token(SYMBOL);
                  jjtn000.setName(t.image);
        PortItem();
        jj_consume_token(RBRACE);
        break;
      default:
        jj_la1[96] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

//			(
//				t = <SYMBOL>
//				{ jjtThis.addCLIPSPortname(t.image); }
//			)+

//<port-item> ::= ?ALL | ?NONE | <port-construct> ?ALL | 
//	<port-construct> ?NONE | <port-construct> <construct-name>+
  final public void PortItem() throws ParseException {
                   /*@bgen(jjtree) PortItem */
                    COOLPortItem jjtn000 = new COOLPortItem(this, JJTPORTITEM);
                    boolean jjtc000 = true;
                    jjtree.openNodeScope(jjtn000);Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ATR_ALL:
        jj_consume_token(ATR_ALL);
        break;
      case ATR_NONE:
        jj_consume_token(ATR_NONE);
        break;
      case DEFTEMPLATE_CONSTRUCT:
      case DEFFUNCTION:
      case DEFGENERIC:
      case DEFCLASS:
      case DEFGLOBAL:
        PortConstruct();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ATR_ALL:
          jj_consume_token(ATR_ALL);
          break;
        case ATR_NONE:
          jj_consume_token(ATR_NONE);
          break;
        default:
          jj_la1[98] = jj_gen;
          label_36:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case INSTANCE:
            case SYMBOL:
              ;
              break;
            default:
              jj_la1[97] = jj_gen;
              break label_36;
            }
            ConstructName();
          }
        }
        break;
      default:
        jj_la1[99] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void ConstructName() throws ParseException {
                        /*@bgen(jjtree) ConstructName */
                         COOLConstructName jjtn000 = new COOLConstructName(this, JJTCONSTRUCTNAME);
                         boolean jjtc000 = true;
                         jjtree.openNodeScope(jjtn000);Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SYMBOL:
        t = jj_consume_token(SYMBOL);
        break;
      case INSTANCE:
        t = jj_consume_token(INSTANCE);
        break;
      default:
        jj_la1[100] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
            jjtree.closeNodeScope(jjtn000, true);
            jjtc000 = false;
            jjtn000.setName(t.image);
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

//<port-construct> ::= deftemplate_construct | defclass | defglobal | deffunction | defgeneric
  final public void PortConstruct() throws ParseException {
    if (jj_2_15(2)) {
      jj_consume_token(DEFTEMPLATE_CONSTRUCT);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DEFCLASS:
        jj_consume_token(DEFCLASS);
        break;
      case DEFGLOBAL:
        jj_consume_token(DEFGLOBAL);
        break;
      case DEFFUNCTION:
        jj_consume_token(DEFFUNCTION);
        break;
      case DEFGENERIC:
        jj_consume_token(DEFGENERIC);
        break;
      default:
        jj_la1[101] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

/* constraint Attributes */

//<constraint-attribute> ::= <type-attribute> | <allowed-constant-attribute> | 
//	<range-attribute> | <cardinality-attribute>
  final public void ConstraintAttribute() throws ParseException {
    jj_consume_token(LBRACE);
    if (jj_2_16(2)) {
      TypeAttribute();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ALLOWED_SYMBOLS:
      case ALLOWED_STRINGS:
      case ALLOWED_LEXEMES:
      case ALLOWED_INTEGERS:
      case ALLOWED_FLOATS:
      case ALLOWED_NUMBERS:
      case ALLOWED_INSTANCES:
      case ALLOWED_CLASSES:
      case ALLOWED_VALUES:
        AllowedConstantAttribute();
        break;
      case RANGE:
        RangeAttribute();
        break;
      case CARDINALITY:
        CardinalityAttribute();
        break;
      default:
        jj_la1[102] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    jj_consume_token(RBRACE);
  }

//<type-attribute> ::= (type <type-specification>)
  final public void TypeAttribute() throws ParseException {
    jj_consume_token(TYPE);
    TypeSpecification();
  }

///////////////////
// Use EnumSets here

//<type-specification> ::= <allowed-type>+ | ?VARIABLE
  final public void TypeSpecification() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SYMBOL_TYPE:
    case STRING_TYPE:
    case LEXEME_TYPE:
    case INTEGER_TYPE:
    case FLOAT_TYPE:
    case NUMBER_TYPE:
    case INSTANCE_NAME_TYPE:
    case INSTANCE_ADDRESS_TYPE:
    case INSTANCE_TYPE:
    case EXTERNAL_ADDRESS_TYPE:
    case FACT_ADDRESS_TYPE:
      label_37:
      while (true) {
        AllowedType();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SYMBOL_TYPE:
        case STRING_TYPE:
        case LEXEME_TYPE:
        case INTEGER_TYPE:
        case FLOAT_TYPE:
        case NUMBER_TYPE:
        case INSTANCE_NAME_TYPE:
        case INSTANCE_ADDRESS_TYPE:
        case INSTANCE_TYPE:
        case EXTERNAL_ADDRESS_TYPE:
        case FACT_ADDRESS_TYPE:
          ;
          break;
        default:
          jj_la1[103] = jj_gen;
          break label_37;
        }
      }
      break;
    case VARIABLE_TYPE:
      jj_consume_token(VARIABLE_TYPE);
      break;
    default:
      jj_la1[104] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

//<allowed-type> ::= SYMBOL | STRING | LEXEME | INTEGER | FLOAT | NUMBER |
//	INSTANCE-NAME | INSTANCE-ADDRESS | INSTANCE | EXTERNAL-ADDRESS | FACT-ADDRESS
  final public void AllowedType() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SYMBOL_TYPE:
      jj_consume_token(SYMBOL_TYPE);
      break;
    case STRING_TYPE:
      jj_consume_token(STRING_TYPE);
      break;
    case LEXEME_TYPE:
      jj_consume_token(LEXEME_TYPE);
      break;
    case INTEGER_TYPE:
      jj_consume_token(INTEGER_TYPE);
      break;
    case FLOAT_TYPE:
      jj_consume_token(FLOAT_TYPE);
      break;
    case NUMBER_TYPE:
      jj_consume_token(NUMBER_TYPE);
      break;
    case INSTANCE_NAME_TYPE:
      jj_consume_token(INSTANCE_NAME_TYPE);
      break;
    case INSTANCE_ADDRESS_TYPE:
      jj_consume_token(INSTANCE_ADDRESS_TYPE);
      break;
    case INSTANCE_TYPE:
      jj_consume_token(INSTANCE_TYPE);
      break;
    case EXTERNAL_ADDRESS_TYPE:
      jj_consume_token(EXTERNAL_ADDRESS_TYPE);
      break;
    case FACT_ADDRESS_TYPE:
      jj_consume_token(FACT_ADDRESS_TYPE);
      break;
    default:
      jj_la1[105] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

// <allowed-constant-attribute> ::= (allowed-symbols <symbol-list>) | (allowed-strings <string-list>) |
//	(allowed-lexemes <lexeme-list> | (allowed-integers <integer-list>) | (allowed-floats <float-list>) |
//	(allowed-numbers <number-list>) | (allowed-instance-names <instance-list>) |
//	(allowed-classes <class-name-list>) | (allowed-values <value-list>)
  final public void AllowedConstantAttribute() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ALLOWED_SYMBOLS:
      jj_consume_token(ALLOWED_SYMBOLS);
      SymbolList();
      break;
    case ALLOWED_STRINGS:
      jj_consume_token(ALLOWED_STRINGS);
      StringList();
      break;
    case ALLOWED_LEXEMES:
      jj_consume_token(ALLOWED_LEXEMES);
      LexemeList();
      break;
    case ALLOWED_INTEGERS:
      jj_consume_token(ALLOWED_INTEGERS);
      IntegerList();
      break;
    case ALLOWED_FLOATS:
      jj_consume_token(ALLOWED_FLOATS);
      FloatList();
      break;
    case ALLOWED_NUMBERS:
      jj_consume_token(ALLOWED_NUMBERS);
      NumberList();
      break;
    case ALLOWED_INSTANCES:
      jj_consume_token(ALLOWED_INSTANCES);
      InstanceList();
      break;
    case ALLOWED_CLASSES:
      jj_consume_token(ALLOWED_CLASSES);
      ClassNameList();
      break;
    case ALLOWED_VALUES:
      jj_consume_token(ALLOWED_VALUES);
      ValueList();
      break;
    default:
      jj_la1[106] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

//<symbol-list> ::= <symbol>+ | ?VARIABLE
  final public void SymbolList() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SYMBOL:
      label_38:
      while (true) {
        jj_consume_token(SYMBOL);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SYMBOL:
          ;
          break;
        default:
          jj_la1[107] = jj_gen;
          break label_38;
        }
      }
      break;
    case VARIABLE_TYPE:
      jj_consume_token(VARIABLE_TYPE);
      break;
    default:
      jj_la1[108] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

//<string-list> ::= <string>+ | ?VARIABLE
  final public void StringList() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case STRING:
      label_39:
      while (true) {
        jj_consume_token(STRING);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case STRING:
          ;
          break;
        default:
          jj_la1[109] = jj_gen;
          break label_39;
        }
      }
      break;
    case VARIABLE_TYPE:
      jj_consume_token(VARIABLE_TYPE);
      break;
    default:
      jj_la1[110] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

//<lexeme-list> ::= <lexeme>+ | ?VARIABLE
  final public void LexemeList() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case STRING:
    case SYMBOL:
      label_40:
      while (true) {
        Lexeme();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case STRING:
        case SYMBOL:
          ;
          break;
        default:
          jj_la1[111] = jj_gen;
          break label_40;
        }
      }
      break;
    case VARIABLE_TYPE:
      jj_consume_token(VARIABLE_TYPE);
      break;
    default:
      jj_la1[112] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

//<integer-list> ::= <integer>+ | ?VARIABLE
  final public void IntegerList() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER:
      label_41:
      while (true) {
        jj_consume_token(INTEGER);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case INTEGER:
          ;
          break;
        default:
          jj_la1[113] = jj_gen;
          break label_41;
        }
      }
      break;
    case VARIABLE_TYPE:
      jj_consume_token(VARIABLE_TYPE);
      break;
    default:
      jj_la1[114] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

//<float-list> ::= <float>+ | ?VARIABLE
  final public void FloatList() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FLOAT:
      label_42:
      while (true) {
        jj_consume_token(FLOAT);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case FLOAT:
          ;
          break;
        default:
          jj_la1[115] = jj_gen;
          break label_42;
        }
      }
      break;
    case VARIABLE_TYPE:
      jj_consume_token(VARIABLE_TYPE);
      break;
    default:
      jj_la1[116] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

//<number-list> ::= <number>+ | ?VARIABLE
  final public void NumberList() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER:
    case FLOAT:
      label_43:
      while (true) {
        Number();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case INTEGER:
        case FLOAT:
          ;
          break;
        default:
          jj_la1[117] = jj_gen;
          break label_43;
        }
      }
      break;
    case VARIABLE_TYPE:
      jj_consume_token(VARIABLE_TYPE);
      break;
    default:
      jj_la1[118] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

//<instance-name-list> ::= <instance-name>+ | ?VARIABLE
  final public void InstanceList() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INSTANCE:
      label_44:
      while (true) {
        jj_consume_token(INSTANCE);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case INSTANCE:
          ;
          break;
        default:
          jj_la1[119] = jj_gen;
          break label_44;
        }
      }
      break;
    case VARIABLE_TYPE:
      jj_consume_token(VARIABLE_TYPE);
      break;
    default:
      jj_la1[120] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

//<class-name-list> ::= <class-name>+ | ?VARIABLE
  final public void ClassNameList() throws ParseException {
                               Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SYMBOL:
      label_45:
      while (true) {
        t = jj_consume_token(SYMBOL);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SYMBOL:
          ;
          break;
        default:
          jj_la1[121] = jj_gen;
          break label_45;
        }
      }
      break;
    case VARIABLE_TYPE:
      jj_consume_token(VARIABLE_TYPE);
      break;
    default:
      jj_la1[122] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

//<value-list> ::= <constant>+ | ?VARIABLE
  final public void ValueList() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER:
    case FLOAT:
    case STRING:
    case INSTANCE:
    case SYMBOL:
      label_46:
      while (true) {
        Constant();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case INTEGER:
        case FLOAT:
        case STRING:
        case INSTANCE:
        case SYMBOL:
          ;
          break;
        default:
          jj_la1[123] = jj_gen;
          break label_46;
        }
      }
      break;
    case VARIABLE_TYPE:
      jj_consume_token(VARIABLE_TYPE);
      break;
    default:
      jj_la1[124] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

//<range-attribute> ::= (range <range-specification> <range-specification>)
  final public void RangeAttribute() throws ParseException {
    jj_consume_token(RANGE);
    RangeSpecification();
    RangeSpecification();
  }

//<range-specification> ::= <number> | ?VARIABLE
  final public void RangeSpecification() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER:
    case FLOAT:
      Number();
      break;
    case VARIABLE_TYPE:
      jj_consume_token(VARIABLE_TYPE);
      break;
    default:
      jj_la1[125] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

//<cardinality-attribute> ::= (cardinality <cardinality-specification> <cardinality-specification>)
  final public void CardinalityAttribute() throws ParseException {
    jj_consume_token(CARDINALITY);
    CardinalitySpecification();
    CardinalitySpecification();
  }

//<cardinality-specification> ::= <integer> | ?VARIABLE
  final public void CardinalitySpecification() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER:
      Integer();
      break;
    case VARIABLE_TYPE:
      jj_consume_token(VARIABLE_TYPE);
      break;
    default:
      jj_la1[126] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  final private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  final private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  final private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  final private boolean jj_2_5(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_5(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(4, xla); }
  }

  final private boolean jj_2_6(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_6(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(5, xla); }
  }

  final private boolean jj_2_7(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_7(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(6, xla); }
  }

  final private boolean jj_2_8(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_8(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(7, xla); }
  }

  final private boolean jj_2_9(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_9(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(8, xla); }
  }

  final private boolean jj_2_10(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_10(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(9, xla); }
  }

  final private boolean jj_2_11(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_11(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(10, xla); }
  }

  final private boolean jj_2_12(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_12(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(11, xla); }
  }

  final private boolean jj_2_13(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_13(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(12, xla); }
  }

  final private boolean jj_2_14(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_14(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(13, xla); }
  }

  final private boolean jj_2_15(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_15(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(14, xla); }
  }

  final private boolean jj_2_16(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_16(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(15, xla); }
  }

  final private boolean jj_3R_79() {
    if (jj_3R_102()) return true;
    return false;
  }

  final private boolean jj_3R_78() {
    if (jj_3R_101()) return true;
    return false;
  }

  final private boolean jj_3R_77() {
    if (jj_3R_100()) return true;
    return false;
  }

  final private boolean jj_3R_76() {
    if (jj_3R_99()) return true;
    return false;
  }

  final private boolean jj_3R_75() {
    if (jj_3R_98()) return true;
    return false;
  }

  final private boolean jj_3_8() {
    if (jj_scan_token(MULTIVAR)) return true;
    return false;
  }

  final private boolean jj_3R_52() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_75()) {
    jj_scanpos = xsp;
    if (jj_3R_76()) {
    jj_scanpos = xsp;
    if (jj_3R_77()) {
    jj_scanpos = xsp;
    if (jj_3R_78()) {
    jj_scanpos = xsp;
    if (jj_3R_79()) return true;
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_96() {
    if (jj_scan_token(LBRACE)) return true;
    return false;
  }

  final private boolean jj_3R_73() {
    if (jj_3R_96()) return true;
    return false;
  }

  final private boolean jj_3R_102() {
    if (jj_scan_token(INSTANCE)) return true;
    return false;
  }

  final private boolean jj_3R_50() {
    if (jj_scan_token(LBRACE)) return true;
    if (jj_scan_token(DECLARE)) return true;
    Token xsp;
    if (jj_3R_73()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_73()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3_7() {
    if (jj_scan_token(SINGLEVAR)) return true;
    return false;
  }

  final private boolean jj_3R_114() {
    if (jj_3R_49()) return true;
    return false;
  }

  final private boolean jj_3R_106() {
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_114()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_74() {
    if (jj_3R_97()) return true;
    return false;
  }

  final private boolean jj_3R_99() {
    if (jj_scan_token(STRING)) return true;
    return false;
  }

  final private boolean jj_3R_93() {
    if (jj_scan_token(DEFMODULE)) return true;
    return false;
  }

  final private boolean jj_3R_105() {
    if (jj_3R_106()) return true;
    return false;
  }

  final private boolean jj_3R_104() {
    if (jj_scan_token(ATR_NONE)) return true;
    return false;
  }

  final private boolean jj_3R_103() {
    if (jj_scan_token(ATR_DERIVE)) return true;
    return false;
  }

  final private boolean jj_3R_98() {
    if (jj_scan_token(SYMBOL)) return true;
    return false;
  }

  final private boolean jj_3R_89() {
    if (jj_scan_token(DEFMETHOD)) return true;
    return false;
  }

  final private boolean jj_3R_51() {
    if (jj_scan_token(SYMBOL)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_74()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_81() {
    if (jj_scan_token(DYNAMIC_ATR)) return true;
    if (jj_3R_106()) return true;
    return false;
  }

  final private boolean jj_3R_100() {
    if (jj_scan_token(INTEGER)) return true;
    return false;
  }

  final private boolean jj_3R_57() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_80()) {
    jj_scanpos = xsp;
    if (jj_3R_81()) return true;
    }
    return false;
  }

  final private boolean jj_3R_80() {
    if (jj_scan_token(DEFAULT_ATR)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_103()) {
    jj_scanpos = xsp;
    if (jj_3R_104()) {
    jj_scanpos = xsp;
    if (jj_3R_105()) return true;
    }
    }
    return false;
  }

  final private boolean jj_3_4() {
    if (jj_3R_50()) return true;
    return false;
  }

  final private boolean jj_3R_82() {
    if (jj_scan_token(SYMBOL)) return true;
    return false;
  }

  final private boolean jj_3R_88() {
    if (jj_scan_token(DEFGENERIC)) return true;
    return false;
  }

  final private boolean jj_3_13() {
    if (jj_3R_57()) return true;
    return false;
  }

  final private boolean jj_3R_101() {
    if (jj_scan_token(FLOAT)) return true;
    return false;
  }

  final private boolean jj_3R_58() {
    if (jj_scan_token(LBRACE)) return true;
    if (jj_3R_82()) return true;
    return false;
  }

  final private boolean jj_3R_84() {
    if (jj_scan_token(DEFTEMPLATE)) return true;
    return false;
  }

  final private boolean jj_3_14() {
    if (jj_3R_58()) return true;
    return false;
  }

  final private boolean jj_3R_86() {
    if (jj_scan_token(DEFRULE)) return true;
    return false;
  }

  final private boolean jj_3R_92() {
    if (jj_scan_token(DEFINSTANCES)) return true;
    return false;
  }

  final private boolean jj_3_1() {
    if (jj_3R_47()) return true;
    return false;
  }

  final private boolean jj_3R_48() {
    if (jj_scan_token(DEFFACTS)) return true;
    if (jj_scan_token(SYMBOL)) return true;
    return false;
  }

  final private boolean jj_3R_69() {
    if (jj_3R_93()) return true;
    return false;
  }

  final private boolean jj_3R_68() {
    if (jj_3R_92()) return true;
    return false;
  }

  final private boolean jj_3R_55() {
    if (jj_scan_token(LBRACE)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(39)) {
    jj_scanpos = xsp;
    if (jj_scan_token(40)) {
    jj_scanpos = xsp;
    if (jj_scan_token(41)) return true;
    }
    }
    return false;
  }

  final private boolean jj_3R_67() {
    if (jj_3R_91()) return true;
    return false;
  }

  final private boolean jj_3R_66() {
    if (jj_3R_90()) return true;
    return false;
  }

  final private boolean jj_3R_65() {
    if (jj_3R_89()) return true;
    return false;
  }

  final private boolean jj_3R_87() {
    if (jj_scan_token(DEFFUNCTION)) return true;
    return false;
  }

  final private boolean jj_3R_64() {
    if (jj_3R_88()) return true;
    return false;
  }

  final private boolean jj_3R_63() {
    if (jj_3R_87()) return true;
    return false;
  }

  final private boolean jj_3R_62() {
    if (jj_3R_86()) return true;
    return false;
  }

  final private boolean jj_3R_61() {
    if (jj_3R_85()) return true;
    return false;
  }

  final private boolean jj_3R_60() {
    if (jj_3R_84()) return true;
    return false;
  }

  final private boolean jj_3R_54() {
    if (jj_scan_token(LBRACE)) return true;
    if (jj_scan_token(PATTERN_MATCH)) return true;
    return false;
  }

  final private boolean jj_3_2() {
    if (jj_3R_48()) return true;
    return false;
  }

  final private boolean jj_3R_91() {
    if (jj_scan_token(DEFMESSAGEHANDLER)) return true;
    return false;
  }

  final private boolean jj_3R_47() {
    if (jj_scan_token(LBRACE)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_2()) {
    jj_scanpos = xsp;
    if (jj_3R_60()) {
    jj_scanpos = xsp;
    if (jj_3R_61()) {
    jj_scanpos = xsp;
    if (jj_3R_62()) {
    jj_scanpos = xsp;
    if (jj_3R_63()) {
    jj_scanpos = xsp;
    if (jj_3R_64()) {
    jj_scanpos = xsp;
    if (jj_3R_65()) {
    jj_scanpos = xsp;
    if (jj_3R_66()) {
    jj_scanpos = xsp;
    if (jj_3R_67()) {
    jj_scanpos = xsp;
    if (jj_3R_68()) {
    jj_scanpos = xsp;
    if (jj_3R_69()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_72() {
    if (jj_3R_95()) return true;
    return false;
  }

  final private boolean jj_3R_53() {
    if (jj_scan_token(LBRACE)) return true;
    if (jj_scan_token(ROLE)) return true;
    return false;
  }

  final private boolean jj_3R_71() {
    if (jj_3R_94()) return true;
    return false;
  }

  final private boolean jj_3_5() {
    if (jj_3R_51()) return true;
    return false;
  }

  final private boolean jj_3R_70() {
    if (jj_3R_52()) return true;
    return false;
  }

  final private boolean jj_3R_113() {
    if (jj_3R_121()) return true;
    return false;
  }

  final private boolean jj_3R_85() {
    if (jj_scan_token(DEFGLOBAL)) return true;
    return false;
  }

  final private boolean jj_3_12() {
    if (jj_3R_56()) return true;
    return false;
  }

  final private boolean jj_3_11() {
    if (jj_3R_55()) return true;
    return false;
  }

  final private boolean jj_3R_122() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(71)) {
    jj_scanpos = xsp;
    if (jj_scan_token(72)) {
    jj_scanpos = xsp;
    if (jj_scan_token(73)) {
    jj_scanpos = xsp;
    if (jj_scan_token(74)) {
    jj_scanpos = xsp;
    if (jj_scan_token(75)) {
    jj_scanpos = xsp;
    if (jj_scan_token(76)) {
    jj_scanpos = xsp;
    if (jj_scan_token(77)) {
    jj_scanpos = xsp;
    if (jj_scan_token(78)) {
    jj_scanpos = xsp;
    if (jj_scan_token(79)) {
    jj_scanpos = xsp;
    if (jj_scan_token(80)) {
    jj_scanpos = xsp;
    if (jj_scan_token(81)) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3_10() {
    if (jj_3R_54()) return true;
    return false;
  }

  final private boolean jj_3_9() {
    if (jj_3R_53()) return true;
    return false;
  }

  final private boolean jj_3R_49() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_70()) {
    jj_scanpos = xsp;
    if (jj_3R_71()) {
    jj_scanpos = xsp;
    if (jj_3R_72()) return true;
    }
    }
    return false;
  }

  final private boolean jj_3R_115() {
    if (jj_3R_122()) return true;
    return false;
  }

  final private boolean jj_3R_107() {
    Token xsp;
    if (jj_3R_115()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_115()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_83() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_107()) {
    jj_scanpos = xsp;
    if (jj_scan_token(70)) return true;
    }
    return false;
  }

  final private boolean jj_3R_110() {
    if (jj_3R_118()) return true;
    return false;
  }

  final private boolean jj_3R_124() {
    if (jj_scan_token(TILDE)) return true;
    return false;
  }

  final private boolean jj_3R_109() {
    if (jj_3R_117()) return true;
    return false;
  }

  final private boolean jj_3R_128() {
    if (jj_scan_token(EQUALS)) return true;
    return false;
  }

  final private boolean jj_3R_120() {
    if (jj_scan_token(MFWILDCARD)) return true;
    return false;
  }

  final private boolean jj_3R_119() {
    if (jj_scan_token(SFWILDCARD)) return true;
    return false;
  }

  final private boolean jj_3R_108() {
    if (jj_3R_116()) return true;
    return false;
  }

  final private boolean jj_3R_95() {
    if (jj_scan_token(LBRACE)) return true;
    if (jj_scan_token(SYMBOL)) return true;
    return false;
  }

  final private boolean jj_3R_127() {
    if (jj_scan_token(COLON)) return true;
    return false;
  }

  final private boolean jj_3R_126() {
    if (jj_3R_117()) return true;
    return false;
  }

  final private boolean jj_3R_125() {
    if (jj_3R_116()) return true;
    return false;
  }

  final private boolean jj_3R_90() {
    if (jj_scan_token(DEFCLASS)) return true;
    return false;
  }

  final private boolean jj_3R_59() {
    if (jj_scan_token(TYPE)) return true;
    if (jj_3R_83()) return true;
    return false;
  }

  final private boolean jj_3R_123() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_124()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3_6()) {
    jj_scanpos = xsp;
    if (jj_3R_125()) {
    jj_scanpos = xsp;
    if (jj_3R_126()) {
    jj_scanpos = xsp;
    if (jj_3R_127()) {
    jj_scanpos = xsp;
    if (jj_3R_128()) return true;
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3_6() {
    if (jj_3R_52()) return true;
    return false;
  }

  final private boolean jj_3R_56() {
    if (jj_scan_token(MESSAGE_HANDLER)) return true;
    if (jj_scan_token(SYMBOL)) return true;
    return false;
  }

  final private boolean jj_3R_94() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_108()) {
    jj_scanpos = xsp;
    if (jj_3R_109()) {
    jj_scanpos = xsp;
    if (jj_3R_110()) return true;
    }
    }
    return false;
  }

  final private boolean jj_3R_121() {
    if (jj_3R_123()) return true;
    return false;
  }

  final private boolean jj_3R_112() {
    if (jj_3R_120()) return true;
    return false;
  }

  final private boolean jj_3R_117() {
    if (jj_scan_token(MULTIVAR)) return true;
    return false;
  }

  final private boolean jj_3_16() {
    if (jj_3R_59()) return true;
    return false;
  }

  final private boolean jj_3_3() {
    if (jj_3R_49()) return true;
    return false;
  }

  final private boolean jj_3R_118() {
    if (jj_scan_token(GLOBALVAR)) return true;
    return false;
  }

  final private boolean jj_3_15() {
    if (jj_scan_token(DEFTEMPLATE_CONSTRUCT)) return true;
    return false;
  }

  final private boolean jj_3R_116() {
    if (jj_scan_token(SINGLEVAR)) return true;
    return false;
  }

  final private boolean jj_3R_111() {
    if (jj_3R_119()) return true;
    return false;
  }

  final private boolean jj_3R_97() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_111()) {
    jj_scanpos = xsp;
    if (jj_3R_112()) {
    jj_scanpos = xsp;
    if (jj_3R_113()) return true;
    }
    }
    return false;
  }

  public COOLTokenManager token_source;
  SimpleCharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  public boolean lookingAhead = false;
  private boolean jj_semLA;
  private int jj_gen;
  final private int[] jj_la1 = new int[127];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static private int[] jj_la1_3;
  static {
      jj_la1_0();
      jj_la1_1();
      jj_la1_2();
      jj_la1_3();
   }
   private static void jj_la1_0() {
      jj_la1_0 = new int[] {0x1db200,0x1db201,0x3000,0x8000,0x1b000,0x1c0000,0x1db200,0x1db200,0xff400000,0x8000,0x200,0x8000,0x200,0x0,0x200,0x200,0x200,0x0,0x200,0x200,0x200,0x1db200,0x8000,0x200,0x200,0x1db200,0x200,0x0,0x0,0x0,0x40000,0x200,0x200,0x0,0x0,0x0,0x200,0x200,0x200,0xdb000,0x0,0x200,0x0,0xdb000,0x200,0xdb000,0xdb000,0x0,0x0,0x0,0xc0000,0x0,0x100000,0x8000,0x80000,0x40000,0x8000,0x1000,0x8000,0x40200,0x80200,0x0,0x100200,0x200,0x0,0x100200,0x200,0x100200,0x8000,0x0,0x0,0x0,0x0,0x200,0x200,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000,0x0,0x0,0x0,0x8000,0x40000,0x80000,0x0,0x8000,0x200,0x0,0x200,0x200,0x10000,0x0,0x16800000,0x10000,0x16000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000,0x8000,0x8000,0x8000,0x1000,0x1000,0x2000,0x2000,0x3000,0x3000,0x10000,0x10000,0x0,0x0,0x1b000,0x1b000,0x3000,0x1000,};
   }
   private static void jj_la1_1() {
      jj_la1_1 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x280,0x6,0x6,0x6,0x30,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x60000,0x3000,0x60000,0xfb80000,0x0,0x0,0x300000,0x380000,0x8000000,0x0,0x0,0x0,0x80000000,0x0,0x0,0x30000000,0x80000000,0x0,0x80000000,0x80000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x380,0x0,0x0,0x30,0x6,0x0,0x0,0x0,0x0,0x0,0x0,0x20,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000,0x8000,0x0,0x60,0x61,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_2() {
      jj_la1_2 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x33,0x0,0x0,0x0,0x33,0x0,0x33,0x33,0xc,0xc,0x2,0x30,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc0000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1ffc0000,0x3ff80,0x3ffc0,0x3ff80,0x7fc0000,0x0,0x40,0x0,0x40,0x0,0x40,0x0,0x40,0x0,0x40,0x0,0x40,0x0,0x40,0x0,0x40,0x0,0x40,0x40,0x40,};
   }
   private static void jj_la1_3() {
      jj_la1_3 = new int[] {0x20000000,0x20000000,0x0,0x20000000,0x20000000,0x0,0x20000000,0x20000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20000000,0x20000000,0x20000000,0x20000000,0x0,0x0,0x0,0x20000000,0x0,0x0,0x0,0x0,0x20000000,0x0,0x0,0x0,0x0,0x20000000,0x0,0x0,0x0,0x20000000,0x20000000,0x20000000,0x0,0x20000000,0x20000000,0x20000000,0x20000000,0x0,0x0,0x0,0x0,0x20000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20000000,0x0,0x0,0x20000000,0x0,0x0,0x0,0x0,0x20000000,0x0,0x6,0x0,0x0,0xcd2091,0x0,0x0,0x60,0x1300,0xc000,0x50000,0x6,0x300000,0xd00,0x0,0x1e000000,0x1e000000,0x1e000000,0x0,0x0,0x0,0x8,0x0,0x0,0x20000000,0x0,0x0,0x20000000,0x0,0x0,0x20000000,0x0,0x0,0x0,0x0,0x0,0x0,0x20000000,0x20000000,0x0,0x0,0x20000000,0x20000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20000000,0x20000000,0x20000000,0x20000000,0x0,0x0,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[16];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  public COOL(java.io.InputStream stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new COOLTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 127; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(java.io.InputStream stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 127; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public COOL(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new COOLTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 127; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 127; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public COOL(COOLTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 127; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(COOLTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 127; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  final private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }

  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  final public Token getToken(int index) {
    Token t = lookingAhead ? jj_scanpos : token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.Vector jj_expentries = new java.util.Vector();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      boolean exists = false;
      for (java.util.Enumeration e = jj_expentries.elements(); e.hasMoreElements();) {
        int[] oldentry = (int[])(e.nextElement());
        if (oldentry.length == jj_expentry.length) {
          exists = true;
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              exists = false;
              break;
            }
          }
          if (exists) break;
        }
      }
      if (!exists) jj_expentries.addElement(jj_expentry);
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[126];
    for (int i = 0; i < 126; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 127; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
          if ((jj_la1_3[i] & (1<<j)) != 0) {
            la1tokens[96+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 126; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

  final private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 16; i++) {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
            case 5: jj_3_6(); break;
            case 6: jj_3_7(); break;
            case 7: jj_3_8(); break;
            case 8: jj_3_9(); break;
            case 9: jj_3_10(); break;
            case 10: jj_3_11(); break;
            case 11: jj_3_12(); break;
            case 12: jj_3_13(); break;
            case 13: jj_3_14(); break;
            case 14: jj_3_15(); break;
            case 15: jj_3_16(); break;
          }
        }
        p = p.next;
      } while (p != null);
    }
    jj_rescan = false;
  }

  final private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
