/* Generated By:JJTree: Do not edit this line. SimpleNode.java */
/** AST Node representing a Symbol.
	@author jjTree
	@author Ory Chowaw-Liebman
*/

public class SimpleNode implements Node {
	protected Node parent;
	protected Node[] children;
	protected int id;
	protected COOL parser;

	protected String name;

	public void setName(String n) { name = n; }
	public String getName() { return name; }

	public SimpleNode(int i) {
		id = i;
		name="";
	}

	public SimpleNode(COOL p, int i) {
		this(i);
		parser = p;
		name="";
	}

	public void jjtOpen() {
	}

	public void jjtClose() {
	}
  
  // Tree Management Functions
	public void jjtSetParent(Node n) { parent = n; }
	public Node jjtGetParent() { return parent; }

	public void jjtAddChild(Node n, int i) {
		if (children == null) {
			children = new Node[i + 1];
		} else if (i >= children.length) {
			Node c[] = new Node[i + 1];
			System.arraycopy(children, 0, c, 0, children.length);
			children = c;
		}
		children[i] = n;
	}

	public Node jjtGetChild(int i) {
		return children[i];
	}

	public int jjtGetNumChildren() {
		return (children == null) ? 0 : children.length;
	}

  /* You can override these two methods in subclasses of SimpleNode to
     customize the way the node appears when the tree is dumped.  If
     your output uses more than one line you should override
     toString(String), otherwise overriding toString() is probably all
     you need to do. */

	public String toString() { return COOLTreeConstants.jjtNodeName[id]; }
	public String toString(String prefix) { return prefix + toString(); }

  /* Override this method if you want to customize how the node dumps
     out its children. */

	public void dump(String prefix) {
		System.out.println(toString(prefix));
		if (children != null) {
		for (int i = 0; i < children.length; ++i) {
			SimpleNode n = (SimpleNode)children[i];
			if (n != null) {
					n.dump(prefix + " ");
				}
			}
		}
	}
	
	// Some nodes may have local data (e.g. classes and functions)
	public CLIPSData getLocal(java.lang.String name)
	{
		if (parent==null) return null;
		return parent.getLocal(name);
	}


	/** Get this node's ID, as defined by jjTree.
	*/
	public int getId()
	{
		return id;
	}

	/** Compare two syntax trees, returns true if both trees have the
		same structure build from the same nodes.
	*/
	public boolean compareTree(Node n)
	{
		int i;
		// Do both nodes have the same id?
		if (id!=n.getId()) return false;
		// Do both nodes have the same name? (All nodes have a name, it defaults to the empty string. 
		// This can differentiate numbers and such...)
		if (getName()!=n.getName()) return false;
		// Do both nodes have the same number of children?
		if (jjtGetNumChildren()!=n.jjtGetNumChildren()) return false;
		// Do both nodes have the same children?
		for (i=0;i<jjtGetNumChildren();i++)
			if (!jjtGetChild(i).compareTree(n.jjtGetChild(i))) return false;
		// Yes, they do
		return true;
	}
		 
	public CLIPSData execute()
	{
		// Just execute first child. More comples Nodes have to override this anyways.
		return jjtGetChild(0).execute();
	};
	
}

