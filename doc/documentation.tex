\documentclass[a4paper,12pt]{scrbook}
\usepackage[latin1]{inputenc} % encoding
\usepackage{listings}
\usepackage{color}
\usepackage{float}
\usepackage{graphicx}
\usepackage{makeidx}



\definecolor{orange}{rgb}{1,0.5,0} 
\definecolor{hellgelb}{rgb}{1,1,0.7} 
\definecolor{blau}{rgb}{0,0.1,1} 
\definecolor{schwarz}{rgb}{0,0,0} 
\definecolor{rot}{rgb}{1,0,0} 
\definecolor{gruen}{rgb}{0,0.5,0}  


\newcommand{\insertfigure}[2]{
\begin{figure}[H]
  \centering
  \makebox{
    \includegraphics{images/#1.eps}
  }
  \caption{#2}
  \label{#1}
\end{figure}
}


\lstset{basicstyle=\ttfamily\small,tabsize=4,classoffset=0,aboveskip=\bigskipamount,keywordstyle=\color{blau},commentstyle=\color{orange},identifierstyle=\color{schwarz}}

\lstdefinelanguage{clips}{keywords={defrule,deftemplate,slot,multislot,assert,=>}, sensitive,keywordsprefix={:}, string=[b]" }[keywords,strings]

\lstnewenvironment{clips} { \lstset{language=clips, breaklines=true, prebreak={\mbox{\hfill$\hookleftarrow$}}  } } { }

\makeindex
\begin{document}








\begin{titlepage}
\begin{center}
\vspace*{4cm}
\Huge Jamocha in Action\\
\vspace{1cm}
\large Jamocha users manual\\
\vspace{1cm}
\normalsize Autoren\\
Uta Christoph\\
Josef Alexander Hahn\\
Karl-Heinz Krempels\\
\vspace{1cm}
2007-2008\\
\end{center}
\end{titlepage}

\tableofcontents
\newpage


\chapter{Rule engine Theory}







\chapter{About the Jamocha implementation}

\section{The Rete algorithm}
The Jamocha reasoning engine is based on the Rete algorithm. This algorith
works by adding each fact in the working memory to the root node of the rete
network. This rete network is builded from the given rules and is actually a
directed acyclic graph composed by a fixed number of different node types (see
below). The rete network has exactly one root node, which each fact in the
knowledge base is added to. Each node takes the facts from the input (the
inputs are the arrows, which end in the node), makes some calculations
(filtering, joining, and so on - for details see below) and returns the results
to the output (the outputs are the arrows, which start in the node). So, the
facts will be passed through the network from the root node to the leafs. The
leafs are terminal nodes; one terminal node for each rule.
\subsection{The node types}
The real work is done by the nodes. There are some different types of nodes for
different tasks.

\subsubsection{Alpha network}
All nodes in the alpha network will output single facts (in contrast to tuples
of facts, which are discussed later).

\paragraph{Object Type Nodes}
An object type node filters a fact by the template. Each instance of this node
type has a parameter ``template'' and lets pass a fact, iff that fact is an
instance of the template ``template'' (Figure \ref{node_objecttypenode}).
\insertfigure{node_objecttypenode}{Object Type Node}

\paragraph{Slot Filter Nodes}
A slot filter node filters a fact by means of a slot name, an operator and a
constant value. It lets pass a fact, iff for that fact the slot's value and the
node's given value are equal (for the case that operator is ``==``, otherwise
the other way around) (Figure \ref{node_slotfilternode}).
\insertfigure{node_slotfilternode}{Slot Filter Node}

\paragraph{Alpha Slot Comparator Node}
Nodes of this type also filters a fact by the content of it's slots. In
contrast to the Slot Filter Nodes, here two given slots are compared with each
other by means of a given operator (Figure \ref{node_alphaslotcomparatornode}).
\insertfigure{node_alphaslotcomparatornode}{Alpha Slot Comparator Node}


\subsubsection{Beta network}
\paragraph{What is a beta network and why do we need it?} At the beginning of
the graph flow, our unit of informations is the fact. But at the end (in the
terminal nodes), this is not enough. Here we need a whole tuple of facts,
basically one fact for each condition of the rule. Example:
\begin{clips}
(defrule foo
    ?x <- (salad (price 2) )
    ?y <- (sausage (price 2))
    ?z <- (beer (price 2))
    =>
    (do-something-with ?x ?y ?z )
)
\end{clips}
This rule's terminal node needs $salad \times sausage \times beer$-tuples.
Inside the beta network, these tuples are generated. Furthermore, the most
magic work (e.g. inter-fact comparison and quantor conditions) is located in
the beta part of the rete network.

\paragraph{Left Input Adaptor Node}
With this node, a fact becomes converted to a tuple, which only contains the
given fact. No further filters are applied here (Figure \ref{node_lia}).
\insertfigure{node_lia}{Left Input Adaptor Node}

\paragraph{Simple Beta Filter Node}
This node has one alpha-input (for single facts) and one beta-input (for
fact-tuples). This node builds a $(n+1)$-tuple out of a $n$-tuple and the
single fact by means of the cartesian product. Furthermore, it doesn't return
all possible combinations but applies filters. A filter can be
\begin{itemize}
  \item the comparison between a value of the alpha-part and a value of the
  beta-part (Figure \ref{node_simplebetafilter_slotcompare}), or
  \item the appliance of a boolean function (Figure
  \ref{node_simplebetafilter_functionevaluator}).
\end{itemize}
Each Simple Beta Filter Node can have more than one filter and the filter types
may be mixed.
\insertfigure{node_simplebetafilter_slotcompare}{Simple Beta Filter Node with
slot comparators}
\insertfigure{node_simplebetafilter_functionevaluator}{Simple Beta Filter Node
with function evaluator}

\paragraph{Quantor Beta Filter Node}
here we need a new implementation, since the old one only works in cases of
only one object type node within an notexists or exists condition.

\paragraph{Terminal Node}
A terminal node is the sink for each fact tuple for rule-matching facts. Each
fact tuple, which arrives here, triggers one new activation in the agenda
(and thereby one time the rule will fire).

\chapter{Users guide}

\chapter{Appendix}

\section{Functions}
\input{functions-documentation.tex}

\newpage
\printindex
\end{document}
