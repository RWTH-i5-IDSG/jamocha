/**
 * Copyright 2007 Karl-Heinz Krempels, Alexander Wilden
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://jamocha.sourceforge.net/
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * 
 **/

/**
 * Further information regarding the FIPA SL Content Language described 
 * in this file at http://fipa.org/specs/fipa00008/index.html
 **/

/* Generated By:JJTree: Do not edit this line. SimpleNode.java */
package org.jamocha.parser.sl_old;

public class SimpleNode implements Node {
	protected Node parent;
	protected Node[] children;
	protected int id;
	protected SLParser parser;
	protected String m_text;
	protected boolean evaluation = false;
	protected String parameterName;
	protected Object valueVector = null;

	public SimpleNode(int i) {
		id = i;
	}

	public SimpleNode(SLParser p, int i) {
		this(i);
		parser = p;
		
	}
	
	/*
	 * This method sets the evaluation flag for functional term nodes
	 * @return boolean evaluation
	 */
	public void setEvaluation() {
		evaluation = true;
	}

	/*
	 * This method returns the evaluation flag for functional term nodes
	 * @return boolean evaluation
	 */
	public boolean evaluated() {
		return evaluation;
	}

  
	public void setParameterName(String aName) {
	  parameterName = aName;
	}

	public String getParameterName() {
	  return parameterName;
	}

	public void jjtOpen() {}

	public void jjtClose() {}

	public void jjtSetParent(Node n) {
		parent = n;
	}

	public Node jjtGetParent() {
		return parent;
	}

	public void jjtAddChild(Node n, int i) {
		if (children == null) {
			children = new Node[i + 1];
		} else if (i >= children.length) {
			Node c[] = new Node[i + 1];
			System.arraycopy(children, 0, c, 0, children.length);
			children = c;
		}
		children[i] = n;
	}

	public Node jjtGetChild(int i) {
		return children[i];
	}

	public int jjtGetNumChildren() {
		return (children == null) ? 0 : children.length;
	}
	
	public int getID() {
		return id;
	}
	
	public void setText(String text) {
		m_text = text;
	}

	public String getText() {
		return m_text;
	}

	/** Accept the visitor. **/
	public Object jjtAccept(SLParserVisitor visitor, Object data) {
		return visitor.visit(this, data);
	}

	/** Accept the visitor. **/
	public Object childrenAccept(SLParserVisitor visitor, Object data) {
		if (children != null) {
			for (int i = 0; i < children.length; ++i) {
				children[i].jjtAccept(visitor, data);
			}
		}
		return data;
	}

	/* You can override these two methods in subclasses of SimpleNode to
	   customize the way the node appears when the tree is dumped.  If
	   your output uses more than one line you should override
	   toString(String), otherwise overriding toString() is probably all
	   you need to do. */

	public String toString() {
		return new String(
			SLParserTreeConstants.jjtNodeName[id]
				+ ((getText() == null) ? "" : ": " + m_text));
	}

	public String toString(String prefix) {
		return prefix + toString();
	}

	/* Override this method if you want to customize how the node dumps
	   out its children. */

	public void dump(String prefix) {
		System.out.println(toString(prefix));
		if (children != null) {
			for (int i = 0; i < children.length; ++i) {
				SimpleNode n = (SimpleNode) children[i];
				if (n != null) {
					n.dump(prefix + " ");
				}
			}
		}
	}
	
	// used for pre order visit to collect the functional terms
	public void visit() {
//		if (children != null) {
//			for (int i = 0; i < children.length; ++i) {
//				SimpleNode n = (SimpleNode) children[i];
//			}
//		}
	}
	
/*	
	/*
	 * returns a value vector for sequences used in JESS multislot templates
	 * @return valueVector
	 */
	public Object getValueVector() {
		return valueVector;
	}
	
	/*
	 * sets a value vector for sequences used in JESS multislot templates
	 * @param valueVector
	 */
	public void setValueVector(Object aValueVector) {
		valueVector = aValueVector;
	}

}
