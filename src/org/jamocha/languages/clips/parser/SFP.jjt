/*
 * Copyright 2007 Karl-Heinz Krempels, Sebastian Reinartz
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.jamocha.org/
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * 
 */
 
 /** 
		
	2007-04-04 : Reduced COOL to the Jamocha Slim Fast Parser (sfp) - Karl-Heinz Krempels, Sebastian Reinartz.
	2006-11-08 : Implemented the COOL Parser - Ulrich Loup, Ory Chowow-Liebman


	The Grammar is based on the CLIPS Object Oriented Language (COOL) used by
	the CLIPS Production system

	@author Karl-Heinz Krempels
**/

options {
	MULTI=true;
	STATIC=false;
	NODE_PREFIX="SFP";
	NODE_USES_PARSER=true;
	VISITOR = true;  // create Visitor interface
	ERROR_REPORTING = true;
	JDK_VERSION = "8.0";
}


/* Java code used for the Parser. */
PARSER_BEGIN(SFPParser)

/*
 * Copyright 2007 Karl-Heinz Krempels, Sebastian Reinartz
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.jamocha.org/
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * 
 */
package org.jamocha.languages.clips.parser;

import org.jamocha.languages.common.ScopeStack.SymbolBean;
import org.jamocha.languages.common.*;
import org.jamocha.languages.common.beans.*;

public class SFPParser {

	private ScopeStack scope = new ScopeStack();

	public SFPConditionalElement nextCE() throws ParseException {
		return ConditionalElement();
	}
}

PARSER_END(SFPParser)

/**********************************************
 * Lexical Specs
 */


SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
}

SPECIAL_TOKEN : /* COMMENTS */
{
  <SINGLE_LINE_COMMENT: ";" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
}

TOKEN :
{
  < LBRACE: "(" >
| < RBRACE: ")" >
| < #DIGIT: ["0"-"9"] >
| < INTEGER: (["+","-"])? (<DIGIT>)+ >
|
  < FLOAT:
	  (["+","-"])? (<DIGIT>)+ "." (<DIGIT>)* (<EXPONENT>)?
      | (["+","-"])? "." (<DIGIT>)+ (<EXPONENT>)?
      | (["+","-"])? (<DIGIT>)+ <EXPONENT>
  >
  
| < #EXPONENT: ["e","E"] (["+","-"])? (<DIGIT>)+ >
| < SILENT: "silent" >
|
  < STRING:
      ("\"" ((~["\"","\\"]) | ("\\" ( ["\\","\""] )))* "\"") |
      ("\'" ((~["\'","\\"]) | ("\\" ( ["\\","\'"] )))* "\'")
  >
| < SFWILDCARD: "?" >
| < MFWILDCARD: "$?" >
| < GLOBALVAR: "?*" <SYMBOL> "*" >
| < DEFFACTS: "deffacts" >
| < DEFTEMPLATE: "deftemplate" >
| < DEFTEMPLATE_CONSTRUCT: "deftemplate_construct" >
| < DEFRULE: "defrule" >
| < DEFFUNCTION: "deffunction" >
| < FUNCTIONGROUP: "functiongroup">
| < DEFGENERIC: "defgeneric" >
| < DEFMODULE: "defmodule" >
| < DEFGLOBAL: "defglobal" >
| < DEFAULT_ATR: "default" >
| < DYNAMIC_ATR: "default-dynamic" >
| < ATR_DEFAULT: "?DEFAULT" >
| < ATR_DERIVE: "?DERIVE" >
| < ATR_NONE: "?NONE" >
| < ATR_ALL: "?ALL" >
| < SLOT: "slot" >
| < SINGLE_SLOT: "single-slot" >
| < MULTISLOT: "multislot" >
| < ARROW: "=>">
| < SLOWCOMPILE: "slow-compile" >
| < DECLARE: "declare" >
| < SALIENCE: "salience" >
| < TEMPORALVALIDITY: "temporal-validity" >
| < MILLISECOND: "millisecond" >
| < SECOND: "second" >
| < MINUTE: "minute" >
| < HOUR: "hour" >
| < DAY: "day" >
| < MONTH: "month" >
| < YEAR: "year" >
| < WEEKDAY: "weekday" >
| < DURATION: "duration" >
| < AUTOFOCUS: "auto-focus" >
| < RULEVERSION: "rule-version">
| < TYPE: "type" >
| < TRUE: "TRUE" | "true" | "True" >
| < FALSE: "FALSE" | "false" | "False" >
| < NIL: "NIL" | "Nil" | "nil" >
| < NOT: "not" >
| < AND: "and" >
| < OR: "or" >
| < OF: "of" >
| < LOGICAL: "logical" >
| < TEST: "test" >
| < EXISTS: "exists" >
| < FORALL: "forall">
| < OBJECT: "object" >
| < ASSIGN: "<-" >
| < TILDE: "~" >
| < AMPERSAND: "&" >
| < LINE: "|" >
| < COLON: ":" >
| < EQUALS: "=" >
| < VARIABLE_TYPE: "?VARIABLE" >
| < SYMBOL_TYPE: "SYMBOL" >
| < STRING_TYPE: "STRING" >
| < DATETIME_TYPE: "DATETIME" >
| < LEXEME_TYPE: "LEXEME" >
| < INTEGER_TYPE: "INTEGER" >
| < SHORT_TYPE: "SHORT" >
| < LONG_TYPE: "LONG" >
| < FLOAT_TYPE: "FLOAT" >
| < DOUBLE_TYPE: "DOUBLE" >
| < NUMBER_TYPE: "NUMBER" >
| < BOOLEAN_TYPE: "BOOLEAN" >
| < EXTERNAL_ADDRESS_TYPE: "EXTERNAL-ADDRESS" >
| < FACT_ADDRESS_TYPE: "FACT-ADDRESS" >
| < ALLOWED_SYMBOLS: "allowed-symbols" >
| < ALLOWED_STRINGS: "allowed-strings" >
| < ALLOWED_LEXEMES: "allowed-lexemes" >
| < ALLOWED_INTEGERS: "allowed-integers" >
| < ALLOWED_LONGS: "allowed-longs" >
| < ALLOWED_SHORTS: "allowed-shorts" >
| < ALLOWED_FLOATS: "allowed-floats" >
| < ALLOWED_DOUBLES: "allowed-doubles" >
| < ALLOWED_NUMBERS: "allowed-numbers" >
| < ALLOWED_VALUES: "allowed-values" >
| < RANGE: "range" >
| < CARDINALITY: "cardinality" >
| < ACTIVE: "active" >
	// Special functions
| < ASSERT: "assert" >
| < RETRACT: "retract" >
| < FIND_FACT_BY_FACT: "find-fact-by-fact" >
| < MODIFY: "modify" >
| < DUPLICATE: "duplicate" >
| < FACT_RELATION: "fact-relation" >
| < IF: "if" >
| < THEN: "then" >
| < ELSE: "else" >
| < WHILE: "while" >
| < DO: "do" >
| < LOOP_FOR_COUNT: "loop-for-count" >
| < SWITCH: "switch" >
| < CASE: "case" >
//| < STAR: "*">
  // If you think this is ugly, you are right. See CLIPS Basic Progrmmers Guide:
  // "Numbers are symbols, but treated different. Instances are symbols, but treated different." 
| < #VARSYMBOL:  ["a"-"z","A"-"Z"] (~[" ","\r","\n","\t","\"","\'","(",")","&","|","<","~",";"])* >
| < SINGLEVAR: ("?" <VARSYMBOL>) >
| < MULTIVAR: ("$?" <VARSYMBOL>) >
| < SYMBOL:  
	(~[" ","\r","\n","\t","\"","\'","(",")","&","|","$","?","~",";","0"-"9","="])
	|(
		(~[" ","\r","\n","\t","\"","\'","(",")","&","|","$","?","~",";","[","="])
		(~[" ","\r","\n","\t","\"","\'","(",")","&","|","?","~",";","0"-"9"])*
		(~[" ","\r","\n","\t","\"","\'","(",")","&","|","<","~",";" ])*
		(~[" ","\r","\n","\t","\"","\'","(",")","&","|","$","?","~",";","]"])? 
	)
	|(
		(~[" ","\r","\n","\t","\"","\'","(",")","&","|","$","?","~",";","="])
		(~[" ","\r","\n","\t","\"","\'","(",")","&","|","?","~",";","0"-"9"])*
		(~[" ","\r","\n","\t","\"","\'","(",")","&","|","<","~",";" ])*
		(~[" ","\r","\n","\t","\"","\'","(",")","&","|","$","?","~",";","]"])+ 
	)
  >

}

/* TODO (From Clips Manual):
Data Types:
<file-name> ::= A symbol or string which is a valid file name (including path information)
	for the operating system under which CLIPS is running
<slot-name> ::= A valid deftemplate_construct slot name
<...-name> ::= A <symbol> where the ellipsis indicate what the symbol represents.
	For example, <rule-name> is a symbol which represents the name of a rule.
*/

/**********************************************
 * Cool Grammar Specs.
 */

// Start rule is a construct at a time, the parser reads all the constructs into a list.
SFPStart Start() : 
{}
{
   ( LOOKAHEAD(2)
	Construct() | Expression()
	
	) { return jjtThis; }
	| <EOF> { return null; }
}


/*
<number> ::= <float> | <integer> 
<lexeme> ::= <symbol> | <string>
<constant> ::= <datetime> | <symbol> | <string> | <integer> | <float>
*/


/**
*		Float
**/

Double Float() : 
{ Token t; }
{
	(
		t=<FLOAT>
	|	t=<DOUBLE>
	)
	{ return Double.parseDouble(t.image); }
}



/**
*		Integer
**/

Long Integer() : 
{ Token t; }
{
	(
		t=<SHORT>
	|	t=<INTEGER>
	|	t=<LONG>
	)
	{
		return Long.parseLong(t.image); 
	}
}


/**
*		Symbol
**/

SymbolBean Symbol() : 
{ Token t; }
{
	t=<SYMBOL>
	{
		return scope.getOrCreate(t.image); 
	}
}


/**
*		String
**/

String String() : 
{ Token t; }
{
	t=<STRING>
	{ return org.jamocha.languages.common.ParserUtils.getStringLiteral(t.image); }
}

/**
*		Constant
**/

ConstantBean Constant() :
{ SymbolBean s; String str; Long i; Double f; Boolean b; }
{ 	
	(
		<NIL>
		{ return new ConstantBean(null, Type.NIL); }	
	//|	DateTime()
	|	s = Symbol()
		{ return new ConstantBean(s, Type.SYMBOL); }
	|	str = String()
		{ return new ConstantBean(str, Type.STRING); }
	|	i = Integer()
		{ return new ConstantBean(i, Type.INTEGER); }
	|	f = Float()
		{ return new ConstantBean(f, Type.FLOAT); }
	|	b = BooleanSymbol()
		{ return new ConstantBean(b, Type.BOOLEAN); }
	)	
}


/**
*		Variable
**/
// This is used exactly then when only the variables value is needed

VariableBean Variable() : // #void: 
{ VariableBean bean = new VariableBean(); Token t; }
{
	// Single Variable is used exactly then when only the variables value is needed
	// Global Variable is used exactly then when only the variables value is needed
	// Multi Variable is used exactly then when only the variables contents are needed
	(
		t=<SINGLEVAR>
		{ bean.setImage(t.image); bean.setSingle(); }
	|	t=<MULTIVAR>
		{ bean.setImage(t.image); bean.setMulti(); }
	|	t=<GLOBALVAR>
		{ bean.setImage(t.image); bean.setGlobal(); }
	)
}


/**
*		Function Call
**/

// <function-call> ::= (<function-name> <expression>*)

FunctionCallBean FunctionCall() : 
{ FunctionCallBean fcb; }
{
	<LBRACE>
		(
			fcb = AssertFunc()
			{ return fcb; }
		//|	Modify()
		|	fcb = RetractFunc()
			{ return fcb; }
		//|	FindFactByFactFunc()
		//|	IfElseFunc()
		//|	WhileFunc()
		//|	LoopForCountFunc()
		|	fcb = AnyFunction()
			{ return fcb; }
		//|	SwitchCaseFunc()
		)
	<RBRACE>
}



/**
*		Any Function
**/

SimpleNode AnyFunction() : 
{}
{
 	(
 		Symbol()
 		(
 			Expression()
 		)*
 	)
 	
	{ return jjtThis; }
}



/**
*		Expression
**/

ExpressionBean Expression() : 
{ ExpressionBean exp;}
{	
	(	LOOKAHEAD(2)
		exp = Constant()
		{ return exp; }
	|	exp = Variable()
		{ return exp; }
	|	exp = FunctionCall() 
		{ return exp; }
	) 
}



/****
**		 Special functions which are defined by CLIPS to have
**		a non-standard syntax (e.g. not all parameters are expressions)
****/

/**
*		Assert Function
**/

AssertFunctionBean AssertFunc() : 
{ AssertFuncitonBean a = new AssertFunctionBean(); TemplateBean t; }
{
	<ASSERT>
	(
		t = RHSPattern()
		{ a.addElement(t); }
	)+
	{ return a; }
}


/**
*		Retract Function
**/

RetractFunctionBean RetractFunc() : 
{ RetractFunctionBean r = new RetractFunctionBean(); ExpressionBean exp; }
{
	<RETRACT>
	(
	//	<STAR>	// Retract all
	//|	(
			(
				exp = Expression()				{ r.addExpression(exp); }			)* // Integers and 'retract-specifiers' see BPG
	//	)
	)
//	RHSPattern()+
	{ return r; }
}


/**
*		Construct - Definition Main Handler 
**/

ConstructBean Construct() :
{ ConstructBean c;}
{
	<LBRACE>
		( LOOKAHEAD(2)
			c = DeftemplateConstruct()
			{ return c; }
		// |	DefglobalConstruct()
		|	c = DefruleConstruct()
			{ return c; }
		// |	DeffunctionConstruct()
		// |	DefmoduleConstruct()
		)
	<RBRACE>
}



/**
*		Deftemplate Construct
**/  
// <deftemplate-construct> ::= (deftemplate <deftemplate-name> [<comment>] <slot-definition>*)

DeftemplateConstructBean DeftemplateConstruct() :
{ DeftemplateConstructBean bean = new DeftemplateConstructBean(); SymbolBean symbol; SlotDefinitionBean slot; }
{
        (
        	<DEFTEMPLATE>
			symbol = Symbol()
			{ bean.setName(symbol); }
			//[ 
			// 	ConstructDescription()
			//]
			(
				slot = SlotDefinition()
				{ bean.addSlot(slot); }
			)*
	)
	{ return bean; }
}


/**
*		Slot Definition
**/  
//<slot-definition> ::= <single-slot-definition> | <multislot-definition>

SlotDefinitionBean SlotDefinition() : 
{ SlotDefinitionBean slotDef = new SlotDefinitionBean(); SymbolBean s; TemplateAttributeBean t; }
{
    ( 	
		<LBRACE> 
		(
			(		    <SLOT> (
				s=Symbol()
				{ slotDef.setName(s); }
				(
					t = TemplateAttribute()
					{ slotDef.addTemplateAttribute(t); }
				)*
			)
			)
				//| 	MultiSlotDefinition()
		)
		<RBRACE> 
    )
    {return slotDef;}
}


/**
*		Template Attribute
**/
//<template-attribute> ::= <default-attribute> | <constraint-attribute>

TemplateAttributeBean TemplateAttribute() : // #void: 
{ TemplateAttributeBean t = new TemplateAttributeBean(); ConstraintAttributeBean c; }
{
	<LBRACE>
	(	LOOKAHEAD(2)
	//	DefaultAttribute() 
	//|
		c = ConstraintAttribute()
		{ return c; }	) 
	<RBRACE>
}



SlotBean RHSSlot() : 
{ SlotBean slot = new SlotBean(); SymbolBean symbol; FieldBean field; }
{ 
	<LBRACE>
		symbol = Symbol() // slot name
		{ slot.setName(symbol); }
		(
			field = RHSField()
			{ slot.addField(field); }
		)*
	<RBRACE> 
	{ return slot; }
}

/**
*		Fact Construct
**/


/**
*		Right Hand Site Pattern
**/
// <RHS-pattern> ::= <ordered-RHS-pattern> | <template-RHS-pattern>
// <ordered-RHS-pattern> ::= (<symbol> <RHS-field>+)
// <template-RHS-pattern> ::= (<deftemplate-name> <RHS-slot>*)
// <RHS-slot> ::= <single-field-RHS-slot> | <multifield-RHS-slot> 
// <single-field-RHS-slot> ::= (<slot-name> <RHS-field>)
// <multifield-RHS-slot> ::= (<slot-name> <RHS-field>*)
// <RHS-field> ::= <variable> | <constant> | <function-call>
// <RHS-slot> ::= <single-field-RHS-slot> | <multifield-RHS-slot> 
// <single-field-RHS-slot> ::= (<slot-name> <RHS-field>)
// <multifield-RHS-slot> ::= (<slot-name> <RHS-field>*)

TemplateBean RHSPattern() : 
{ TemplateBean templ = new TemplateBean(); SymbolBean symbol; SlotBean slot; }
{ 
	<LBRACE>
		symbol = Symbol() //Template Name 
		{ templ.setName(symbol); }
		[
			LOOKAHEAD(2)
			<LBRACE>
				TemporalValidity()
			<RBRACE>
		]
		(
			slot = RHSSlot()
			{ t.addSlot(slot); }
		)*
	<RBRACE> 
	
	{ return templ; }
}


/**
*		Right Hand Site Field
**/

//<RHS-field> ::= <variable> | <constant> | <function-call>

FieldBean RHSField() : // #void: 
{ FieldBean fieldBean = new FieldBean(); }
{
    	Variable()
    |   Constant()
    |   FunctionCall()
}



/**
*		Define Rule Construct
**/

/*
<defrule-construct> ::= (defrule <rule-name> [<comment>] [<declaration>] <conditional-element>* => <expression>*) 
<rule-property> ::= (salience <integer-expression>) | (auto-focus <boolean-symbol>)
<boolean-symbol> ::= TRUE | FALSE
<conditional-element> ::= <pattern-CE> | <assigned-pattern-CE> | <not-CE> | <and-CE> | <or-CE> |
	<logical-CE> | <test-CE> | <exists-CE> | <forall-CE>
<pattern-CE> ::= <ordered-pattern-CE> | <template-pattern-CE> | <object-pattern-CE>
<assigned-pattern-CE> ::= <single-field-variable> <- <pattern-CE>
<not-CE> ::= (not <conditional-element>)
<and-CE> ::= (and <conditional-element>+)
<or-CE> ::= (or <conditional-element>+)
<logical-CE> ::= (logical <conditional-element>+)
<test-CE> ::= (test <function-call>)
<exists-CE> ::= (exists <conditional-element>+)
<forall-CE> ::= (forall <conditional-element> <conditional-element>+)
<ordered-pattern-CE> ::= (<symbol> <constraint>*)
<template-pattern-CE> ::= (<deftemplate-name> <LHS-slot>*)
<object-pattern-CE> ::= (object <attribute-constraint>*)
<attribute-constraint> ::= (is-a <constraint>) | (name <constraint>) | (<slot-name> <constraint>*)
<LHS-slot> ::= <single-field-LHS-slot> | <multifield-LHS-slot>
<single-field-LHS-slot> ::= (<slot-name> <constraint>)
<multifield-LHS-slot> ::= (<slot-name> <constraint>*)
<constraint> ::= ? | $? | <connected-constraint>
<connected-constraint>::= <single-constraint> | <single-constraint> & <connected-constraint> |
	<single-constraint> | <connected-constraint>
<single-constraint> ::= <term> | ~<term>
<term> ::= <constant> | <single-field-variable> | <multifield-variable> | 
	:<function-call> | =<function-call>
*/



/**
*		Define Rule Construct
**/

// <defrule-construct> ::= (defrule <rule-name> [<comment>] [<declaration>] <conditional-element>* => <expression>*) 

SimpleNode DefruleConstruct() :
{}
{
    	(
    		<DEFRULE>

    		Symbol()	//name
    		//[ 
    		//  	ConstructDescription()	
    		//]
    		( 
    			[
    				LOOKAHEAD(3)
    				Declaration()
    			]
   				(
    					ConditionalElement()
   				)* 
    		)
    			<ARROW>
        		ActionList()
        )        
	{ return jjtThis; }
}



/**
*		Action List
**/

// Create Dummy node to have fixed number of children in Defrule

SimpleNode ActionList():{} 
{ 
    	(
        	(
        	LOOKAHEAD(2)
    		Expression()
        	)*
	)
	{ return jjtThis; }
}



/**
*		Declaration
**/

//<declaration> ::= (declare <rule-property>+)

SimpleNode Declaration(): 
{}
{
    <LBRACE>
        <DECLARE>
        (
        	RuleProperty()
        )+
    <RBRACE>
    { return jjtThis; }
}



/**
*		Rule Property
**/

// <rule-property> ::= (salience <integer-expression>) | (auto-focus <boolean-symbol>)

void RuleProperty() : // #void: 
{}
{
    <LBRACE>
     	(
     		Salience()		
     	| 	AutoFocus()
     	|   SlowCompile()
     	|	RuleVersion()
	)
	<RBRACE>
}


/**
*		Boolean Symbol
**/

//<boolean-symbol> ::= TRUE | FALSE

Boolean BooleanSymbol() :
{ Token t; }
{
    (
    	t = <TRUE>
    	{ return true; }
    |	t = <False>
    	{ return false; }
    )
}


/**
*		Conditional Element
**/

//<conditional-element> ::= <pattern-CE> | <assigned-pattern-CE> | <not-CE> | <and-CE> | <or-CE> |
//                          <logical-CE> | <test-CE> | <exists-CE> | <forall-CE>

void ConditionalElement() : // #void:
{}
{
	(	
		(
		   <LBRACE> 
				(	
						TemplatePatternCE() 
					|	BooleanFunction() 
					|	LogicalCE() 
					|	TestCE()
					|	ExistsCE()
					|	ForallCE()		
				)
			<RBRACE>
		)

		|	AssignedPatternCE()
	)	
}



/**
*		Boolean Function
**/

void BooleanFunction() : // #void: 
{}
{
	(LOOKAHEAD(2)
		NotFunction()
	|	AndFunction()
	|	OrFunction()	
	)
}



/**
*		And Function
**/

NotFunctionBean NotFunction():
{}
{
	<NOT>
		ConditionalElement()

	{ return jjtThis; }
}



/**
*		And Function
**/

AndFunctionBean AndFunction():
{}
{	
	<AND>
		(ConditionalElement())+
    	
	{ return jjtThis; }
}



/**
*		Or Function
**/

OrFunctionBean OrFunction():
{}
{	

	<OR>
		(ConditionalElement())+
    	
	{ return jjtThis; }
}	


/**
*		Pattern Conditional Element
**/

//<assigned-pattern-CE> ::= <single-field-variable> <- <pattern-CE>
// Create and return conditions

SimpleNode AssignedPatternCE():
{}
{

	(
		SingleVariable() 
		<ASSIGN>
		
		<LBRACE>
		
			TemplatePatternCE()
		
		<RBRACE>
	) 
	
	{ return jjtThis; }
}



/**
*		Logical CE
**/

//<logical-CE> ::= (logical <conditional-element>+)
// Create and return conditions

SimpleNode LogicalCE() : 
{}
{
    <LOGICAL> 
    
    (
    	LOOKAHEAD(2)
    	
		ConditionalElement()
    )+ 
    
    { return jjtThis; }
}



/**
*		Test CE
**/

//<test-CE> ::= (test <function-call>)
// Create and return conditions (initialize the function before execution, to get a node

SimpleNode TestCE() : 
{}
{
	<TEST>
	FunctionCall()
	
	{ return jjtThis; }
}



/**
*		Exists CE
**/

//<exists-CE> ::= (exists <conditional-element>+)
// Create and return conditions
SimpleNode ExistsCE() : 
{}
{
    <EXISTS> 
    (
		LOOKAHEAD(2)
		
		ConditionalElement()
    )+
    
    { return jjtThis; }
}



/**
*		Forall CE
**/

//<forall-CE> ::= (forall <conditional-element> <conditional-element>+)
// Create and return conditions

SimpleNode ForallCE() : 
{}
{
	<FORALL> 
	ConditionalElement() 
	(
		LOOKAHEAD(2)
		
		ConditionalElement()
	)+	
    	
	{return jjtThis; }
}


/**
*		Template Pattern CE
**/

//<template-pattern-CE> ::= (<deftemplate-name> <LHS-slot>*)

SimpleNode TemplatePatternCE(): 
{}
{
    (
    	Symbol() //template Name
    	(LOOKAHEAD(2)
    			(UnorderedLHSFactBody())+
	    	|	OrderedLHSFactBody()
		)
    )
    
   { return jjtThis; }
}



SimpleNode UnorderedLHSFactBody(): 
{}
{
	<LBRACE>
	LHSSlot()
	<RBRACE>
	
	{ return jjtThis; }
}

SimpleNode OrderedLHSFactBody(): 
{}
{
	(
			Constraint()
	)*
	{ return jjtThis; }
}


/**
*		LHSSlot
**/

//<LHS-slot> ::= <single-field-LHS-slot> | <multifield-LHS-slot>

SimpleNode LHSSlot(): 
{}
{
    (
    	Symbol() //slot Name
		Constraint()
    )	
    
    { return jjtThis; }
}



/**
*		Constraint
**/

//<constraint> ::= ? | $? | <connected-constraint>

void Constraint() : // #void : 
{}
{		
		SingleFieldWildcard()
	|	MultiFieldWildcard()
	|	ConnectedConstraint()
}



/**
*		Singlefield Wildcard
**/

SimpleNode SingleFieldWildcard() : 
{}
{
	<SFWILDCARD>
	
    { return jjtThis; }
}



/**
*		Multifield Wildcard
**/

SimpleNode MultiFieldWildcard() : 
{}
{
	<MFWILDCARD>
	
    { return jjtThis; }
}



/**
*		Connected Constraint
**/

//<connected-constraint>::= <single-constraint> | <single-constraint> & <connected-constraint> |
//	<single-constraint> | <connected-constraint>

SimpleNode ConnectedConstraint():
{}
{
    (
    	Term() 
    [
		AmpersandConnectedConstraint()
	|	LineConnectedConstraint()
	]
    )
    {return jjtThis;}
}



/**
*		Ampersand Connected Constraint
**/

SimpleNode AmpersandConnectedConstraint(): 
{}
{
    (
		<AMPERSAND>
		Term()
	[
		LineConnectedConstraint() | AmpersandConnectedConstraint()
	]
    )
    
    { return jjtThis; }
}



/**
*		Line Connected Constraint
**/

SimpleNode LineConnectedConstraint(): 
{}
{
    (
		<LINE>
		Term()
	[
		LineConnectedConstraint() | AmpersandConnectedConstraint()
	]
    )
    
	{ return jjtThis; } 
}



/**
*		Term
**/

//<term> ::= <constant> | <single-field-variable> | <multifield-variable> | 
//	:<function-call> | =<function-call>

SimpleNode Term()  : 
{}
{
    (
    	[	
		Negation()
	] 
    ( LOOKAHEAD(3)
    	Constant()
    |	SingleVariable()
    |	MultiVariable()
    |	Colon()
    |	Equals()
    )
    )
    
    {return jjtThis;}
}



/**
*		Negation
**/

SimpleNode Negation() : 
{}
{
	<TILDE>
	
	{ return jjtThis; }
}



/**
*		Colon
**/

SimpleNode Colon() : 
{}
{
	<COLON>
	FunctionCall()
	{ return jjtThis; }
}



/**
*		Equals
**/

SimpleNode Equals() : 
{}
{
	<EQUALS>
	FunctionCall()
	{ return jjtThis; }
}


/**
*		Deffunction Construct
**/

//<deffunction-construct> 
//	::= (deffunction <name> [<comment>] (<regular-parameter>* [<wildcard-parameter>]) <expression>*)

SimpleNode DeffunctionConstruct()  :
{}
{
    (
    	<DEFFUNCTION>
        Symbol()	//name
        //[ 
        // 	ConstructDescription() //comment
        //]
        (<LBRACE>
        	(
        		SingleVariable()
        	)*
        	(
             	MultiVariable()
            )* 
        <RBRACE>
        )
        ActionList()
    ) 
    
    { return jjtThis; }
}


/**
*		Constraint Attribute
**/

//<constraint-attribute> ::= <type-attribute> | <allowed-constant-attribute> | 
//	<range-attribute> | <cardinality-attribute>

ConstraintAttributeBean ConstraintAttribute() :
{ ConstraintAttributeBean c = new ConstrainsAttributeBean(); AllowedTypes t; }
{
	( LOOKAHEAD(2)
		<TYPE>
		( 
			t = AllowedType()			{ c.addAllowedType(t) }
		)+
	//|	AllowedConstantAttribute()
	//|	RangeAttribute()
	//|	CardinalityAttribute()
	)
}


/**
*		Allowed Type
**/

//<allowed-type> ::= SYMBOL | STRING | LEXEME | INTEGER | FLOAT | NUMBER |
// EXTERNAL-ADDRESS | FACT-ADDRESS | DATETIME

AllowedTypes AllowedType() :
{}
{
	(		<SYMBOL_TYPE>
		{ return AllowedTypes.SYMBOL; }		
		|	<STRING_TYPE>
		{ return AllowedTypes.STRING; }		
		|	<LEXEME_TYPE>
		{ return AllowedTypes.LEXEME; }		
		|	<INTEGER_TYPE>
		{ return AllowedTypes.INTEGER; }		
		|	<FLOAT_TYPE>
		{ return AllowedTypes.FLOAT; }		
		|	<NUMBER_TYPE>
		{ return AllowedTypes.NUMBER; }		
		|	<BOOLEAN_TYPE>
		{ return AllowedTypes.BOOLEAN; }		
	)
}

