/** 
		
	2007-04-04 : Reducing COOL to Jamocha Slim Fast Parser (sfp) - Karl-Heinz Krempels.
	2006-11-08 : Implementing the COOL Parser - Ulrich Loup, Ory Chowow-Liebman

	The Grammar is based on the CLIPS Object Oriented Language (COOL) used by
	the CLIPS Production system
	
	@author Karl-Heinz Krempels
*/

options {
	MULTI=true;
	STATIC=false;
	NODE_PREFIX="SFP";
	NODE_USES_PARSER=true;
	VISITOR = true;  // create Visitor interface
	ERROR_REPORTING = true;
}


/* Java code used for the Parser. */
PARSER_BEGIN(SFPParser)
package org.jamocha.parser.sfp;

import org.jamocha.parser.Parser;
import org.jamocha.parser.ParserUtils;
import org.jamocha.parser.Expression;
import org.jamocha.parser.JamochaValue;

import org.jamocha.rete.Rete;

public class SFPParser implements Parser{

        public Expression nextExpression() throws ParseException {
          //      return Start().evaluate();
          return null;
        }

        public static void main(String args[])
        {
                boolean verbose = (args != null && args.length == 1 && "verbose".equals(args[0]));
                if(!verbose)System.out.println("Note: For verbose output type \"java Main verbose\".\n");
                System.out.print("SFP> ");
                Rete engine = new Rete();
                SFPParser p = new SFPParser(System.in);
                try
                {
                while (true)
                        {
                                SFPStart n = p.Start();
                                if (n==null) System.exit(0);
                                n.dump(" ");
                                JamochaValue val=null;
                                val =(JamochaValue)n.jjtAccept(new SFPInterpreter(engine), null);
                        }
                }
                catch (Exception e)
                {
                        System.err.println("ERROR: " + e.getMessage());
                        if(verbose)e.printStackTrace();
                }
        }



}

PARSER_END(SFPParser)

/**********************************************
 * Lexical Specs
 */


SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
}

SPECIAL_TOKEN : /* COMMENTS */
{
  <SINGLE_LINE_COMMENT: ";" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
}

TOKEN :
{
  < LBRACE: "(" >
| < RBRACE: ")" >| < GE1: ">=" >
| < #DIGIT: ["0"-"9"] >
| < INTEGER: (["+","-"])? (<DIGIT>)+ >
|
  < FLOAT:
        (<DIGIT>)+ "." (<DIGIT>)* (<EXPONENT>)?
      | "." (<DIGIT>)+ (<EXPONENT>)?
      | (<DIGIT>)+ <EXPONENT>
  >
  
| < #EXPONENT: ["e","E"] (["+","-"])? (<DIGIT>)+ >
| < #GMT_OFFSET: ("+"|"-") ( <DIGIT> )? <DIGIT> >
| < #DATE: <DIGIT> <DIGIT> <DIGIT> <DIGIT> "-" <DIGIT> <DIGIT> "-" <DIGIT> <DIGIT> >
| < #TIME: <DIGIT> <DIGIT> ":" <DIGIT> <DIGIT> ( ":" <DIGIT> <DIGIT>)? >
| < DATETIME:  <DATE> ( " " <TIME> (<GMT_OFFSET>)? )? > 
|
  < STRING:
      ("\"" ((~["\"","\\"]) | ("\\" ( ["\\","\""] )))* "\"") |
      ("\'" ((~["\'","\\"]) | ("\\" ( ["\\","\'"] )))* "\'")
  >
| < SFWILDCARD: "?" >
| < MFWILDCARD: "$?" >
| < GLOBALVAR: "?*" <SYMBOL> "*" >
| < DEFFACTS: "deffacts" >
| < DEFTEMPLATE: "deftemplate" >
| < DEFTEMPLATE_CONSTRUCT: "deftemplate_construct" >
| < DEFRULE: "defrule" >
| < DEFFUNCTION: "deffunction" >
| < DEFGENERIC: "defgeneric" >
| < DEFMODULE: "defmodule" >
| < DEFGLOBAL: "defglobal" >
| < DEFAULT_ATR: "default" >
| < DYNAMIC_ATR: "default-dynamic" >
| < ATR_DEFAULT: "?DEFAULT" >
| < ATR_DERIVE: "?DERIVE" >
| < ATR_NONE: "?NONE" >
| < ATR_ALL: "?ALL" >
| < SLOT: "slot" >
| < SINGLE_SLOT: "single-slot" >
| < MULTISLOT: "multislot" >
| < ARROW: "=>">
| < DECLARE: "declare" >
| < SALIENCE: "salience" >
| < AUTOFOCUS: "auto-focus" >
| <RULEVERSION: "rule-version">
| <	TYPE: "type" >
| < TRUE: "TRUE" | "true" | "True" >
| < FALSE: "FALSE" | "false" | "False" >
| < NOT: "not" >
| < AND: "and" >
| < OR: "or" >
| < OF: "of" >
| < LOGICAL: "logical" >
| < TEST: "test" >
| < EXISTS: "exists" >
| < FORALL: "forall">
| < OBJECT: "object" >
| < ASSIGN: "<-" >
| < TILDE: "~" >
| < AMPERSAND: "&" >
| < LINE: "|" >
| < COLON: ":" >
| < EQUALS: "=" >
| < VARIABLE_TYPE: "?VARIABLE" >
| < SYMBOL_TYPE: "SYMBOL" >
| < STRING_TYPE: "STRING" >
| < DATETIME_TYPE: "DATETIME" >
| < LEXEME_TYPE: "LEXEME" >
| < INTEGER_TYPE: "INTEGER" >
| < SHORT_TYPE: "SHORT" >
| < LONG_TYPE: "LONG" >
| < FLOAT_TYPE: "FLOAT" >
| < DOUBLE_TYPE: "DOUBLE" >
| < NUMBER_TYPE: "NUMBER" >
| < BOOLEAN_TYPE: "BOOLEAN" >
| < EXTERNAL_ADDRESS_TYPE: "EXTERNAL-ADDRESS" >
| < FACT_ADDRESS_TYPE: "FACT-ADDRESS" >
| < ALLOWED_SYMBOLS: "allowed-symbols" >
| < ALLOWED_STRINGS: "allowed-strings" >
| < ALLOWED_LEXEMES: "allowed-lexemes" >
| < ALLOWED_INTEGERS: "allowed-integers" >
| < ALLOWED_LONGS: "allowed-longs" >
| < ALLOWED_SHORTS: "allowed-shorts" >
| < ALLOWED_FLOATS: "allowed-floats" >
| < ALLOWED_DOUBLES: "allowed-doubles" >
| < ALLOWED_NUMBERS: "allowed-numbers" >
| < ALLOWED_VALUES: "allowed-values" >
| < RANGE: "range" >
| < CARDINALITY: "cardinality" >
| < ACTIVE: "active" >
	// Special functions
| < ASSERT: "assert" >
| < RETRACT: "retract" >
| < FIND_FACT_BY_FACT: "find-fact-by-fact" >
| < MODIFY: "modify" >
| < DUPLICATE: "duplicate" >
| < FACT_RELATION: "fact-relation" >
| < FACT_SLOT_VALUE: "fact-slot-value" >
| < IF: "if" >
| < THEN: "then" >
| < ELSE: "else" >
| < WHILE: "while" >
| < DO: "do" >
| < LOOP_FOR_COUNT: "loop-for-count" >
| < SWITCH: "switch" >
| < CASE: "case" >
| < STAR: "*">
  // If you think this is ugly, you are right. See CLIPS Basic Progrmmers Guide:
  // "Numbers are symbols, but treated different. Instances are symbols, but treated different." 
| < #VARSYMBOL:  ["a"-"z","A"-"Z"] (~[" ","\r","\n","\t","\"","\'","(",")","&","|","<","~",";"])* >
| < SINGLEVAR: ("?" <VARSYMBOL>) >
| < MULTIVAR: ("$?" <VARSYMBOL>) >
| < SYMBOL:  
	(~[" ","\r","\n","\t","\"","\'","(",")","&","|","$","?","~",";","0"-"9","="])
	|(
		(~[" ","\r","\n","\t","\"","\'","(",")","&","|","$","?","~",";","[","="])
		(~[" ","\r","\n","\t","\"","\'","(",")","&","|","?","~",";","0"-"9"])*
		(~[" ","\r","\n","\t","\"","\'","(",")","&","|","<","~",";" ])*
		(~[" ","\r","\n","\t","\"","\'","(",")","&","|","$","?","~",";","]"])? 
	)
	|(
		(~[" ","\r","\n","\t","\"","\'","(",")","&","|","$","?","~",";","="])
		(~[" ","\r","\n","\t","\"","\'","(",")","&","|","?","~",";","0"-"9"])*
		(~[" ","\r","\n","\t","\"","\'","(",")","&","|","<","~",";" ])*
		(~[" ","\r","\n","\t","\"","\'","(",")","&","|","$","?","~",";","]"])+ 
	)
  >

}

/* TODO (From Clips Manual):
Data Types:
<file-name> ::= A symbol or string which is a valid file name (including path information)
	for the operating system under which CLIPS is running
<slot-name> ::= A valid deftemplate_construct slot name
<...-name> ::= A <symbol> where the ellipsis indicate what the symbol represents.
	For example, <rule-name> is a symbol which represents the name of a rule.
*/

/**********************************************
 * Cool Grammar Specs.
 */

// Start rule is a construct at a time, the parser reads all the constructs into a list.
SFPStart Start() : 
{}
{
   ( LOOKAHEAD(2)
	Construct() | Expression()
	
	) { return jjtThis; }
	| <EOF> { return null; }
}


/*
<number> ::= <float> | <integer> 
<lexeme> ::= <symbol> | <string>
<constant> ::= <datetime> | <symbol> | <string> | <integer> | <float>
*/


/**
*		Float
**/

SimpleNode Float() : 
{ Token t; }
{
	(
		t=<FLOAT>
	//|	t=<DOUBLE>
	)
	
	{
		jjtThis.setName(t.image); 
		return jjtThis;
	}
}



/**
*		Integer
**/

SimpleNode Integer() : 
{ Token t; }
{
	(
		t=<INTEGER>
	//|	t=<LONG>
	//|	t=<SHORT>
	)
	
	{
		jjtThis.setName(t.image); 
		return jjtThis;
	}
}



/**
*		DateTime
**/

SimpleNode DateTime() : 
{ Token t; }
{
	t=<DATETIME>
	{
		jjtThis.setName(t.image);
		return jjtThis;
	}
}



/**
*		Number
**/

void Number() #void : 
{}
{	
	(	Float()
	|	Integer() 
	)
}



/**
*		Symbol
**/

SimpleNode Symbol() : 
{ Token t; }
{
	t=<SYMBOL>
	{
		jjtThis.setName(t.image); 
		return jjtThis;
	}
}



/**
*		String
**/

SimpleNode String() : 
{ Token t; }
{
	t=<STRING>
	{
		jjtThis.setName(ParserUtils.getStringLiteral(t.image)); 
		return jjtThis;
	}
}


/**
*		True
**/

SimpleNode True() : 
{ Token t; }
{
	t=<TRUE>
	{
		jjtThis.setName(t.image); 
		return jjtThis;
	}
}

/**
*		SymbolType
**/

SimpleNode SymbolType() : 
{ Token t; }
{
	t=<SYMBOL_TYPE>
	{
		jjtThis.setName(t.image); 
		return jjtThis;
	}
}

/**
*		StringType
**/

SimpleNode StringType() : 
{ Token t; }
{
	t=<STRING_TYPE>
	{
		jjtThis.setName(t.image); 
		return jjtThis;
	}
}

/**
*		DateTimeType
**/

SimpleNode DateTimeType() : 
{ Token t; }
{
	t=<DATETIME_TYPE>
	{
		jjtThis.setName(t.image); 
		return jjtThis;
	}
}

/**
*		LexemeType
**/

SimpleNode LexemeType() : 
{ Token t; }
{
	t=<LEXEME_TYPE>
	{
		jjtThis.setName(t.image); 
		return jjtThis;
	}
}

/**
*		BooleanType
**/

SimpleNode BooleanType() : 
{ Token t; }
{
	t=<BOOLEAN_TYPE>
	{
		jjtThis.setName(t.image); 
		return jjtThis;
	}
}

/**
*		IntegerType
**/

SimpleNode IntegerType() : 
{ Token t; }
{
	t=<INTEGER_TYPE>
	{
		jjtThis.setName(t.image); 
		return jjtThis;
	}
}

/**
*		longType
**/

SimpleNode LongType() : 
{ Token t; }
{
	t=<LONG_TYPE>
	{
		jjtThis.setName(t.image); 
		return jjtThis;
	}
}
/**
*		ShortType
**/

SimpleNode ShortType() : 
{ Token t; }
{
	t=<SHORT_TYPE>
	{
		jjtThis.setName(t.image); 
		return jjtThis;
	}
}
/**
*		FloatType
**/

SimpleNode FloatType() : 
{ Token t; }
{
	t=<FLOAT_TYPE>
	{
		jjtThis.setName(t.image); 
		return jjtThis;
	}
}

/**
*		DoubleType
**/

SimpleNode DoubleType() : 
{ Token t; }
{
	t=<DOUBLE_TYPE>
	{
		jjtThis.setName(t.image); 
		return jjtThis;
	}
}


/**
*		NumberType
**/

SimpleNode NumberType() : 
{ Token t; }
{
	t=<NUMBER_TYPE>
	{
		jjtThis.setName(t.image); 
		return jjtThis;
	}
}



/**
*		False
**/

SimpleNode False() : 
{ Token t; }
{
	t=<FALSE>
	{
		jjtThis.setName(t.image); 
		return jjtThis;
	}
}


/**
*		Lexeme
**/

void Lexeme() #void : 
{}
{	
	(	String()
	|	Symbol() 
	)
}



/**
*		Constant
**/

void Constant() #void :
{}
{ 	
	(
		DateTime()
	|   	Symbol()
	|	String()
	|	Integer()
	|	Float()
	|	BooleanSymbol()
	)
}



/**
*		Construct Description
**/

SimpleNode ConstructDescription() : 
{}
{	
    String()
    
    { return jjtThis; }
}



/**
*		Single Variable
**/
// This is used exactly then when only the variables value is needed

SimpleNode SingleVariable() : 
{ Token t; } 
{
	t=<SINGLEVAR>
	{ jjtThis.setName(t.image); return jjtThis;}
}



/**
*		Global Variable
**/
// This is used exactly then when only the variables value is needed

SimpleNode GlobalVariable() : 
{ Token t; } 
{
	t=<GLOBALVAR>
	{ jjtThis.setName(t.image); return jjtThis;}
}



/**
*		Multi Variable
**/
// This is used exactly then when only the variables contents are needed

SimpleNode MultiVariable() : 
{ Token t; } 
{
	t=<MULTIVAR>
	{ jjtThis.setName(t.image); return jjtThis;}
}



/**
*		Variable
**/
// This is used exactly then when only the variables value is needed

SimpleNode Variable() : 
{}
{	
	(	
		SingleVariable()
	|	MultiVariable()
	|	GlobalVariable() 
	) 
	{ return jjtThis; }
}



/**
*		Variable Type
**/
// This is used exactly then when only the variables contents are needed

SimpleNode VariableType() : 
{ Token t; } 
{
	t=<VARIABLE_TYPE>
	{ 
		jjtThis.setName(t.image); 
		return jjtThis;
	}
}



/**
*		Function Call
**/

// <function-call> ::= (<function-name> <expression>*)

SimpleNode FunctionCall() : 
{}
{
	<LBRACE> 
		(
			AssertFunc()
		|	RetractFunc()
		|   	FindFactByFactFunc()	
		|	IfElseFunc()
		|	AnyFunction()
		) 
	<RBRACE>
	
	{ return jjtThis; }
}



/**
*		Any Function
**/

SimpleNode AnyFunction() : 
{}
{
 	(
 		Symbol()
 		(
 			Expression()
 		)*
 	)
 	
	{ return jjtThis; }
}



/**
*		Expression
**/

SimpleNode Expression() : 
{} 
{	
	(	LOOKAHEAD(2)
		Constant()
	|	Variable()
	|	FunctionCall() 
	) 
	{ return jjtThis; }
}



/****
**		 Special functions wich are defined by CLIPS to have
**		a non-standart syntax (e.g. not all parameters are expressions)
****/

/**
*		Assert Function
**/

SimpleNode AssertFunc() : 
{}
{
	<ASSERT>
	(
		RHSPattern()
	)+
	{ return jjtThis; }
}



/**
*		FindFactByFact Function
**/

SimpleNode FindFactByFactFunc() : 
{}
{
	<FIND_FACT_BY_FACT>
	( 
		RHSPattern()
	)
	{ return jjtThis; }
}



/**
*		Retract Function
**/

SimpleNode RetractFunc() : 
{}
{
	<RETRACT>
	(
		<STAR>	// Retract all
	|	(
			(Expression())*		// Integers and 'retract-specifiers' see BPG
		)
	)
//	RHSPattern()+
	{ return jjtThis; }
}



/**
*		If Else Function
**/

SimpleNode IfElseFunc() : 
{}
{
	(
		<IF>
		Expression()
		<THEN>
		ActionList()
		[
		 	<ELSE>
		 	ActionList()
		 ]
	)
	
	{ return jjtThis; }
}



/**
*		While Function
**/

SimpleNode WhileFunc() : 
{}
{
	(
		<WHILE>
		Expression()
		[
		 	<DO>
		]
		ActionList()
	)
	
	{ return jjtThis; }
}



/**
*		Loop For Count Function
**/

SimpleNode LoopForCntFunc() : 
{}
{
	(
		<LOOP_FOR_COUNT>
		(
			<LBRACE>
			SingleVariable()
			[
			 	Expression()
			 	[ 
			 	 	Expression()
			 	]
			 ]
			 <RBRACE>
		)
		[
		 	<DO>
		 ]
		 ActionList()
	)
	
	{ return jjtThis; }
}



/**
*		Case Switch Function
**/

SimpleNode SwitchCaseFunc() : 
{}
{
	(
		<SWITCH>
		Expression()	// Test Expression
		(	LOOKAHEAD(2)
			CaseStatement()
		)*
		[	
		<LBRACE>
		<DEFAULT_ATR> 
		ActionList()
		<RBRACE>
		]
	)
	{ return jjtThis; }
}



/**
*		Case Statement Function
**/

SimpleNode CaseStatement() : 
{}
{
	(
		<LBRACE> 
			<CASE> 
			Expression()	// Comparison Expression
			<THEN> 
			ActionList()
		<RBRACE>
	)
	
	{ return jjtThis; }
}

/**
*		Default Statements for SwitchCaseFunc
**/
SimpleNode SwitchDefaults() : 
{}
{
	(
		<LBRACE>
			<DEFAULT_ATR> 
			ActionList()
		<RBRACE>
	)
	
	{ return jjtThis; }
}

/**
*		Construct - Definition Main Handler 
**/

void Construct() #void : {}
{
	<LBRACE>
		( LOOKAHEAD(2)
			DeftemplateConstruct()
		|	DefglobalConstruct()
		|	DefruleConstruct()
		|	DeffunctionConstruct()
		|	DefmoduleConstruct()
		)
	<RBRACE>
}



/**
*		Deftemplate Construct
**/  
// <deftemplate-construct> ::= (deftemplate <deftemplate-name> [<comment>] <slot-definition>*)

SimpleNode DeftemplateConstruct() :
{}
{
        (
        	<DEFTEMPLATE>
			Symbol()
			[ 
			 	ConstructDescription()
			]
			(
				SlotDefinition()
			)*
	)
	
        { return jjtThis; }
}



/**
*		Slot Definition
**/  
//<slot-definition> ::= <single-slot-definition> | <multislot-definition>

void  SlotDefinition()  #void: 
{}
{
    ( 	
		<LBRACE> 
		(
					SingleSlotDefinition()
				| 	MultiSlotDefinition()
			)
		<RBRACE> 
    )
}



/**
*		Single Slot Definition
**/
//< single-slot-definition> ::= ( slot <slot-name> <template-attribute>*)

SimpleNode SingleSlotDefinition() :
{}
{
	<SLOT>
	(
		Symbol()
		(
			TemplateAttribute()
		)*
	)
	{ return jjtThis; }
}



/**
*		Multi Slot Definition
**/
//<multislot-definition> ::= ( multislot <slot-name> <template-attribute>*)

SimpleNode MultiSlotDefinition() :
{} 
{
        <MULTISLOT>
	(
		Symbol()
		(
			TemplateAttribute()
		)*
	)
	{ return jjtThis; }
}



/**
*		Template Attribute
**/
//<template-attribute> ::= <default-attribute> | <constraint-attribute>

SimpleNode TemplateAttribute() : 
{}
{
	<LBRACE>
	(	LOOKAHEAD(2)
		DefaultAttribute() 
	| 	DynamicAttribute()
	|	ConstraintAttribute()
	) 
	<RBRACE>
	{ return jjtThis; }
}



/**
*		Attributes
**/
// A dummy node to have a list of attributes

SimpleNode Attributes() :
{} 
{ 
	(	LOOKAHEAD(2)
		Expression()
	)*
	{ return jjtThis; }
}



/**
*		Default Attribute
**/
//<default-attribute> ::= (default ?DERIVE | ?NONE | <expression>*) | (default-dynamic <expression>*)

SimpleNode DefaultAttribute() : 
{}
{
		<DEFAULT_ATR>
		(	
			DeriveAttribute()
		|	NoneAttribute() 
		|	DefaultAttributes() 
		)
		{ return jjtThis; }
}

SimpleNode DefaultAttributes() :
{}
{
    Attributes()
    
    { return jjtThis; }
}



/**
*		Derive Attribute
**/

SimpleNode DeriveAttribute() : 
{ Token t; }
{
	t = <ATR_DERIVE>
	{
		jjtThis.setName(t.image); 
		return jjtThis;
	}
}



/**
*		None Attribute
**/

SimpleNode NoneAttribute() : 
{ Token t; }
{
	t = <ATR_NONE>
	{
		jjtThis.setName(t.image); 
		return jjtThis;
	}
}



/**
*		Dynamic Attribute
**/

//<default-attribute> ::= (default ?DERIVE | ?NONE | <expression>*) | (default-dynamic <expression>*)

SimpleNode DynamicAttribute() : 
{}
{
	<DYNAMIC_ATR> 
	(	
		Attributes()
	)
	{ return jjtThis; }
}



/**
*		Fact Construct
**/

/* Fact Specification
<ordered-RHS-pattern> ::= ( <symbol> <RHS-field>+ )

<template-RHS-pattern> ::= ( <deftemplate-name> <RHS-slot>* )

<RHS-slot> ::= <single-field-RHS-slot> | <multifield-RHS-slot>

<single-field-RHS-slot> ::= (<slot-name> <RHS-field>)

<multifield-RHS-slot> ::= (<slot-name> <RHS-field>*)

<RHS-field> ::= <variable> | <constant> | <function-call>
*/



/**
*		Right Hand Site Pattern
**/
// <RHS-pattern> ::= <ordered-RHS-pattern> | <template-RHS-pattern>

void RHSPattern() #void : 
{}
{ 
	<LBRACE>
		TemplateRHSPattern()
	// currently ordered RHS aren't implemented
	//	| 	OrderedRHSPattern(t.image);
	<RBRACE> 
    
}



/**
*		Template Right Hand Site Pattern
**/
//<template-RHS-pattern> ::= (<deftemplate-name> <RHS-slot>*)

SimpleNode TemplateRHSPattern() :
{}
{
    (
	    Symbol()
        ( 
        	RHSSlot() 
        )*
    )
    
    { return jjtThis; }
}



/**
*		Right Hand Site Slot
**/
//<RHS-slot> ::= <single-field-RHS-slot> | <multifield-RHS-slot>
//<single-field-RHS-slot> ::= (<slot-name> <RHS-field>)
//<multifield-RHS-slot> ::= (<slot-name> <RHS-field>*)

SimpleNode RHSSlot() : 
{}
{
    <LBRACE> 
        (	Symbol() // slot-name
        	( 
        		RHSField() 
        	)*
        )
    <RBRACE>
    
    { return jjtThis; }
}



/**
*		Right Hand Site Field
**/

//<RHS-field> ::= <variable> | <constant> | <function-call>

void RHSField() #void : 
{}
{
    	Variable() 
    |   Constant() 
    |   FunctionCall()
}



/**
*		Define Rule Construct
**/

/*
<defrule-construct> ::= (defrule <rule-name> [<comment>] [<declaration>] <conditional-element>* => <expression>*) 
<rule-property> ::= (salience <integer-expression>) | (auto-focus <boolean-symbol>)
<boolean-symbol> ::= TRUE | FALSE
<conditional-element> ::= <pattern-CE> | <assigned-pattern-CE> | <not-CE> | <and-CE> | <or-CE> |
	<logical-CE> | <test-CE> | <exists-CE> | <forall-CE>
<pattern-CE> ::= <ordered-pattern-CE> | <template-pattern-CE> | <object-pattern-CE>
<assigned-pattern-CE> ::= <single-field-variable> <- <pattern-CE>
<not-CE> ::= (not <conditional-element>)
<and-CE> ::= (and <conditional-element>+)
<or-CE> ::= (or <conditional-element>+)
<logical-CE> ::= (logical <conditional-element>+)
<test-CE> ::= (test <function-call>)
<exists-CE> ::= (exists <conditional-element>+)
<forall-CE> ::= (forall <conditional-element> <conditional-element>+)
<ordered-pattern-CE> ::= (<symbol> <constraint>*)
<template-pattern-CE> ::= (<deftemplate-name> <LHS-slot>*)
<object-pattern-CE> ::= (object <attribute-constraint>*)
<attribute-constraint> ::= (is-a <constraint>) | (name <constraint>) | (<slot-name> <constraint>*)
<LHS-slot> ::= <single-field-LHS-slot> | <multifield-LHS-slot>
<single-field-LHS-slot> ::= (<slot-name> <constraint>)
<multifield-LHS-slot> ::= (<slot-name> <constraint>*)
<constraint> ::= ? | $? | <connected-constraint>
<connected-constraint>::= <single-constraint> | <single-constraint> & <connected-constraint> |
	<single-constraint> | <connected-constraint>
<single-constraint> ::= <term> | ~<term>
<term> ::= <constant> | <single-field-variable> | <multifield-variable> | 
	:<function-call> | =<function-call>
*/





/**
*		Define Rule Construct
**/
// <defrule-construct> ::= (defrule <rule-name> [<comment>] [<declaration>] <conditional-element>* => <expression>*) 

SimpleNode DefruleConstruct() :
{}
{
    	(
    		<DEFRULE>

    		Symbol()//name
    		[ 
    		  	ConstructDescription()	
    		]
    		( LOOKAHEAD(3)
    			(
    				Declaration()
    				(
    					ConditionalElement()
    				)* 
    			) |
    			(
    				(
    					ConditionalElement()
    				)* 
    			)
    		)
    			<ARROW>
        		ActionList()
        )        
	{ return jjtThis; }
}


// Create Dummy node to have fixed number of children in Defrule
SimpleNode ActionList():{} 
{ 
    	(
        	(
        	LOOKAHEAD(2)
    		Expression()
        	)*
	)
	{ return jjtThis; }
}




/**
*		Declaration
**/
//<declaration> ::= (declare <rule-property>+)

SimpleNode Declaration(): 
{}
{
    <LBRACE>
        <DECLARE>
        (
        	RuleProperty()
        )+
    <RBRACE>
    { return jjtThis; }
}



/**
*		Rule Property
**/
// <rule-property> ::= (salience <integer-expression>) | (auto-focus <boolean-symbol>)

SimpleNode RuleProperty(): 
{}
{
    	<LBRACE>
     	(
     		Salience()		
     	| 	AutoFocus()
     	|	RuleVersion()
	)
	<RBRACE>
    	
	{ return jjtThis; }
}

SimpleNode Salience() :
{}
{
	<SALIENCE>
	Expression()
	{ return jjtThis; }
}

SimpleNode AutoFocus(): 
{}
{
	<AUTOFOCUS>
	BooleanSymbol()
	
	{ return jjtThis; }
}

SimpleNode RuleVersion(): 
{}
{
	<RULEVERSION>
	Expression()
	
	{ return jjtThis; }
}

/**
*		Boolean Symbol
**/
//<boolean-symbol> ::= TRUE | FALSE

SimpleNode BooleanSymbol() : 
{}
{
    (
    	True()
    |	False()
    )
    
    {return jjtThis; }
}


//<conditional-element> ::= <pattern-CE> | <assigned-pattern-CE> | <not-CE> | <and-CE> | <or-CE> |
//                          <logical-CE> | <test-CE> | <exists-CE> | <forall-CE>
SimpleNode ConditionalElement() :
{}
{
	(
		(
		   <LBRACE> 
					TemplatePatternCE() 
				|	BooleanFunction() 
				|	LogicalCE() 
				|	TestCE()
				|	ExistsCE()
				|	ForallCE()		
			<RBRACE>
		)

		|	AssignedPatternCE() 
	)
	{ return jjtThis; }	
}

/**
*		Boolean Functions
**/

SimpleNode BooleanFunction(): 
{}
{
	(LOOKAHEAD(2)
		NotFunction()
	|	AndFunction()
	|	OrFunction()	
	)
    	
	{ return jjtThis; }
}

SimpleNode NotFunction():
{}
{
	<NOT>
		ConditionalElement()

	{ return jjtThis; }
}

SimpleNode AndFunction():
{}
{	
	<AND>
		ConditionalElement()
    	
	{ return jjtThis; }
}

SimpleNode OrFunction():
{}
{	

	<OR>
		ConditionalElement()
    	
	{ return jjtThis; }
}	


/**
*		Pattern Conditional Element
**/

//<assigned-pattern-CE> ::= <single-field-variable> <- <pattern-CE>
// Create and return conditions
SimpleNode AssignedPatternCE():
{}
{

	(
		SingleVariable() 
		<ASSIGN>
		
		<LBRACE>
		
			TemplatePatternCE()
		
		<RBRACE>
	) 
	
	{ return jjtThis; }
}


//<logical-CE> ::= (logical <conditional-element>+)
// Create and return conditions
SimpleNode LogicalCE() : 
{}
{
    <LOGICAL> 
    
    (
    	LOOKAHEAD(2)
    	
		ConditionalElement()
    )+ 
    
    { return jjtThis; }
}

//<test-CE> ::= (test <function-call>)
// Create and return conditions (needs to initialize function 
// before execution, thus it gets a node
SimpleNode TestCE() : 
{}
{
	<TEST>
	Symbol()
	
	{ return jjtThis; }
}

//<exists-CE> ::= (exists <conditional-element>+)
// Create and return conditions
SimpleNode ExistsCE() : 
{}
{
    <EXISTS> 
    (
		LOOKAHEAD(2)
		
		ConditionalElement()
    )+
    
    { return jjtThis; }
}

//<forall-CE> ::= (forall <conditional-element> <conditional-element>+)
// Create and return conditions
SimpleNode ForallCE() : 
{}
{
	<FORALL> 
	ConditionalElement() 
	(
		LOOKAHEAD(2)
		
		ConditionalElement()
	)+	
    	
	{return jjtThis; }
}

//<template-pattern-CE> ::= (<deftemplate-name> <LHS-slot>*)
SimpleNode TemplatePatternCE(): 
{}
{
    (
    	Symbol()
		(	
			LOOKAHEAD(2)
	
			<LBRACE>

				LHSSlot()

			<RBRACE>
		)*
    )
    
   { return jjtThis; }
}

//<attribute-constraint> ::= (name <constraint>) | (<slot-name> <constraint>*)
SimpleNode AttributeConstraint() :
{}
{
    <LBRACE>
		(
			Symbol()
			(
				Constraint()
			)* 
		)
    <RBRACE> 
    
    { return jjtThis; }
}




//<LHS-slot> ::= <single-field-LHS-slot> | <multifield-LHS-slot>

SimpleNode LHSSlot()  : 
{}
{
    (
    	Symbol()
	(
		LOOKAHEAD(2)
		Constraint()
	)*
    )	
	
    {return jjtThis;}
}




//<constraint> ::= ? | $? | <connected-constraint>
void Constraint() #void : 
{}
{
    SingleFieldWildcard() 
    | MultiFieldWildcard() 
    | ConnectedConstraint()
}




SimpleNode SingleFieldWildcard() : 
{ Token t; }
{
	t = <SFWILDCARD>
	{
	    jjtThis.setName(t.image);
	    return jjtThis; 
	}
}



SimpleNode MultiFieldWildcard() : 
{ Token t; }
{
	t = <MFWILDCARD>
	{
	    jjtThis.setName(t.image);
	    return jjtThis; 
	}
}




//<connected-constraint>::= <single-constraint> | <single-constraint> & <connected-constraint> |
//	<single-constraint> | <connected-constraint>

// THIS IS WRONG: Ampersands and lines can be mixed!!
SimpleNode ConnectedConstraint() : 
{}
{
    (
    	Term() 
	[ 
		Ampersand()
	|	Line()
	]
    )
	
    { return jjtThis; }
}



SimpleNode Ampersand():
{}
{
	<AMPERSAND>
	ConnectedConstraint()
	{ return jjtThis; } 
}



SimpleNode Line():
{}
{
	<LINE>
	ConnectedConstraint()
	{ return jjtThis; } 
}



//<term> ::= <constant> | <single-field-variable> | <multifield-variable> | 
//	:<function-call> | =<function-call>
SimpleNode Term()  : 
{}
{
    (
    	[	
		Negation()
	] 
    ( LOOKAHEAD(3)
		Constant()
    |	SingleVariable()
    |	MultiVariable()
    |	Colon()
    |	Equals()
    )
    )
    
    {return jjtThis;}
}



SimpleNode Negation() : 
{}
{
	<TILDE>
	
	{ return jjtThis; }
}



SimpleNode Colon() : 
{}
{
	<COLON>
	FunctionCall()
	{ return jjtThis; }
}



SimpleNode Equals() : 
{}
{
	<EQUALS>
	FunctionCall()
	{ return jjtThis; }
}

/* Defglobal Construct
<defglobal-construct> ::= (defglobal [<defmodule-name>] <global-assignment>*)
<global-assignment> ::= <global-variable> = <expression>
<global-variable> ::= ?*<symbol>*
*/

//<defglobal-construct> ::= (defglobal [<defmodule-name>] <global-assignment>*)
SimpleNode DefglobalConstruct()  :
{}
{
    (
    	<DEFGLOBAL>
        [ 
         	Symbol()//defmodule-name 
        ]
        (
        	GlobalAssignment()
        )*
    )
    
    { return jjtThis; }
}

//<global-assignment> ::= <global-variable> = <expression>
SimpleNode GlobalAssignment()  : 
{}
{
    (
        GlobalVariable()
        <EQUALS>
        Expression()
    )
    
    { return jjtThis; }
}

/* Deffunction Construct
<deffunction-construct> 
	::= (deffunction <name> [<comment>] (<regular-parameter>* [<wildcard-parameter>]) <expression>*)
<regular-parameter> ::= <single-field-variable>
<wildcard-parameter> ::= <multifield-variable>
*/

//<deffunction-construct> 
//	::= (deffunction <name> [<comment>] (<regular-parameter>* [<wildcard-parameter>]) <expression>*)
SimpleNode DeffunctionConstruct()  :
{}
{
    (
    	<DEFFUNCTION>
        Symbol()	//name
        [ 
         	ConstructDescription()
        ]
        <LBRACE> 
        	(
        		SingleVariable()
        	)*
        	[
             		MultiVariable()
             	] 
        <RBRACE>
        ActionList()
    ) 
    
    { return jjtThis; }
}


/* Defgeneric Construct
<defgeneric-construct> ::= (defgeneric <name> [<comment>])
*/
SimpleNode DefgenericConstruct() :
{}
{
     (
    	<DEFGENERIC>
        Symbol()	//name
        [ 
         	ConstructDescription()
        ]
     )
     
     { return jjtThis; }
}


//<parameter-restriction> ::= <single-field-variable> | (<single-field-variable> <type>* [<query>])
SimpleNode ParameterRestriction() : {}
{
	( LOOKAHEAD(2)
		SingleVariable()
	|	(
			<LBRACE>
				SingleVariable() 
				(
					AllowedType()
				)* 
				[
				 	Query()
				 ]
			<RBRACE>
		)
	)
	
	{ return jjtThis; }
}


//<wildcard-parameter-restriction> ::= <multifield-variable> | (<multifield-variable> <type>* [<query>])
SimpleNode WildcardParameterRestriction() : {}
{
	( LOOKAHEAD(2)
		MultiVariable()
	|
		(
			<LBRACE>
				MultiVariable() 
				(
					AllowedType()
				)* 
				[
				 	Query()
				 ]
			<RBRACE>
		)
	)
	
	{ return jjtThis; }
}



//<query> ::= <global-variable> | <function-call>
void Query() : { Token t; }
{
		GlobalVariable()
	|	FunctionCall()
}


/**
*		Constraint Attributes 
**/

//<constraint-attribute> ::= <type-attribute> | <allowed-constant-attribute> | 
//	<range-attribute> | <cardinality-attribute>

void ConstraintAttribute() #void : { }
{
	( LOOKAHEAD(2)
		TypeAttribute()
	|	AllowedConstantAttribute()
	|	RangeAttribute()
	|	CardinalityAttribute()
	)
}



/**
*		Type Attribute
**/

//<type-attribute> ::= (type <type-specification>)

SimpleNode TypeAttribute() :
{ }
{
	<TYPE> 
	TypeSpecification()
	
	{ return jjtThis; }
}



/**
*		Type Specification
**/

//<type-specification> ::= <allowed-type>+ | ?VARIABLE

SimpleNode TypeSpecification() : 
{}
{	(
		( 
			AllowedType() 
		)+ 
		| 	VariableType()
	)
	{ return jjtThis; }
}



/**
*		Allowed Type
**/

//<allowed-type> ::= SYMBOL | STRING | LEXEME | INTEGER | FLOAT | NUMBER |
// EXTERNAL-ADDRESS | FACT-ADDRESS | DATETIME

void AllowedType()  #void: 
{}
{
	(		SymbolType()		
		|	StringType()
		|	DateTimeType()
		|	LexemeType()
		| 	IntegerType()
		|	LongType()
		|	ShortType()
		| 	FloatType()
		| 	DoubleType()
		|	NumberType()
		|   	BooleanType()
	)
}



/**
*		Allowed Constant Atrributes
**/

// <allowed-constant-attribute> ::= (allowed-symbols <symbol-list>) | (allowed-strings <string-list>) |
//	(allowed-lexemes <lexeme-list> | (allowed-integers <integer-list>) | (allowed-floats <float-list>) |
//	(allowed-numbers <number-list>) | (allowed-values <value-list>)

SimpleNode AllowedConstantAttribute() : 
{ Token t; }
{
	(
			t = <ALLOWED_SYMBOLS> SymbolList()
		|	t = <ALLOWED_STRINGS> StringList()
		|	t = <ALLOWED_LEXEMES> LexemeList()
		|	t = <ALLOWED_INTEGERS> IntegerList()
		|	t = <ALLOWED_LONGS> IntegerList() //Long->integer
		|	t = <ALLOWED_SHORTS> IntegerList() //short ->integer
		|	t = <ALLOWED_FLOATS> FloatList()
		|	t = <ALLOWED_DOUBLES> FloatList() //Double->float
		|	t = <ALLOWED_NUMBERS> NumberList()
		|	t = <ALLOWED_VALUES> ValueList()
	)
	
	{ 	
		jjtThis.setName(t.image);
		return jjtThis; 
	}
}



/**
*		Symbol List
**/

//<symbol-list> ::= <symbol>+ | ?VARIABLE

SimpleNode SymbolList() : {}
{
    (
    		( <SYMBOL> )+ 
	|	VariableType()
    )
    
    { return jjtThis; }
}



/**
*		String List
**/

//<string-list> ::= <string>+ | ?VARIABLE

SimpleNode StringList() : 
{}
{
    (
    		( <STRING> )+ 
	|	VariableType()
    )
    
    { return jjtThis; }
}



/**
*		Lexeme List
**/

//<lexeme-list> ::= <lexeme>+ | ?VARIABLE

SimpleNode LexemeList() : 
{}
{
    (
    		( Lexeme() )+ 
	|	VariableType()
    )
    
    { return jjtThis; }
}



/**
*		Integer List
**/

//<integer-list> ::= <integer>+ | ?VARIABLE

SimpleNode IntegerList() :
{}
{
    (
    		( <INTEGER> )+ 
	| 	VariableType()
    )
    
    { return jjtThis; }
}

/**
*		Float List
**/

//<float-list> ::= <float>+ | ?VARIABLE

SimpleNode FloatList() : 
{}
{
    (
    		( <FLOAT> )+ 
	|	VariableType()
    )
    
    { return jjtThis; }
}



/**
*		Number List
**/

//<number-list> ::= <number>+ | ?VARIABLE

SimpleNode NumberList() : 
{}
{
    (
    		( Number() )+ 
	| 	VariableType()
    )
	
    { return jjtThis; }
}



/**
*		Value List
**/

//<value-list> ::= <constant>+ | ?VARIABLE

SimpleNode ValueList() : 
{}
{
    (
    		( Constant() )+ 
	|	VariableType()
    )
	
    { return jjtThis; }
}



/**
*		Range Attribute
**/

//<range-attribute> ::= (range <range-specification> <range-specification>)

SimpleNode RangeAttribute() :
{}
{
    (	
    	<RANGE> 
	
	RangeSpecification() 
	
	RangeSpecification()
   )
	
   { return jjtThis; }
}


/**
*		Range Specification
**/

//<range-specification> ::= <number> | ?VARIABLE

SimpleNode RangeSpecification()  : 
{}
{
    (
    		Number() 
	| 	VariableType()
    )
	
    { return jjtThis; }
}


//<cardinality-attribute> ::= (cardinality <cardinality-specification> <cardinality-specification>)
SimpleNode CardinalityAttribute()  : 
{}
{
    (
    	<CARDINALITY> 

	CardinalitySpecification() 

	CardinalitySpecification()
    )
    
    { return jjtThis; }
}



/**
*		Cardinality Specification
**/

//<cardinality-specification> ::= <integer> | ?VARIABLE

SimpleNode CardinalitySpecification() : 
{}
{
    (	
    		Integer() 
	| 	VariableType()
    )
	
    { return jjtThis; }
}



/**
*		Defmodule Construct
**/

//	<defmodule-construct> ::= (defmodule <module-name> [<comment>] )

SimpleNode DefmoduleConstruct() : 
{}
{
    (
    	<DEFMODULE>
	Symbol() 
	[
		ConstructDescription()
	]
    )
	
    { return jjtThis; }
}


