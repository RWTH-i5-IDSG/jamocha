options {
  OPTIMIZE_TOKEN_MANAGER = true;
  JAVA_UNICODE_ESCAPE = false;
  UNICODE_INPUT = true;
  STATIC = false;
}

PARSER_BEGIN(CLIPSParser)

package org.jamocha.parser.clips;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import org.jamocha.parser.Expression;
import org.jamocha.parser.JamochaValue;
import org.jamocha.parser.JamochaType;
import org.jamocha.parser.Parser;
import org.jamocha.parser.ParserUtils;
import org.jamocha.rete.BoundParam;
import org.jamocha.rete.Deftemplate;
import org.jamocha.rete.ExpressionCollection;
import org.jamocha.rete.ExpressionSequence;
import org.jamocha.rete.Function;
import org.jamocha.rete.Signature;
import org.jamocha.rete.TemplateSlot;
import org.jamocha.rete.Parameter;
import org.jamocha.rete.ParameterUtils;
import org.jamocha.rete.Slot;
import org.jamocha.rule.Action;
import org.jamocha.rule.AndCondition;
import org.jamocha.rule.AndLiteralConstraint;
import org.jamocha.rule.BoundConstraint;
import org.jamocha.rule.Condition;
import org.jamocha.rule.Constraint;
import org.jamocha.rule.Defrule;
import org.jamocha.rule.ExistCondition;
import org.jamocha.rule.FunctionAction;
import org.jamocha.rule.LiteralConstraint;
import org.jamocha.rule.MultiValue;
import org.jamocha.rule.ObjectCondition;
import org.jamocha.rule.OrLiteralConstraint;
import org.jamocha.rule.PredicateConstraint;
import org.jamocha.rule.RuleProperty;
import org.jamocha.rule.TestCondition;

public class CLIPSParser implements Parser {

    public void close() {
        if (token != null) {
            token.clear();
            token = null;
        }
        if (jj_nt != null) {
            jj_nt.clear();
            jj_nt = null;
        }
        if (jj_scanpos != null) {
            jj_scanpos.clear();
            jj_scanpos = null;
        }
        if (jj_lastpos != null) {
            jj_lastpos.clear();
            jj_lastpos = null;
        }
        try {
            jj_input_stream.inputStream.close();
        } catch (IOException e) {
            // later on log the error
        }
    }
}

PARSER_END(CLIPSParser)

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| ";;" : IN_COMMENT
}

/* COMMENTS */

< IN_COMMENT >
MORE : 
{ 
  <  ~[] >
|
  < COMMENT_TEXT: ( (["0"-"9"])|(["a"-"z"]) )+ >
}

< IN_COMMENT >
SKIP :
{
  < END_COMMENT: ("\r" | "\n" | "\r\n") > : DEFAULT
}

TOKEN :
{
  < LBRACE: "(" >
| < RBRACE: ")" >
| < INTEGER_LITERAL: ("-")? ["0"-"9"] (["0"-"9"])* >
|
  < FLOATING_POINT_LITERAL:
        ("-")? (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)?
      | ("-")? "." (["0"-"9"])+ (<EXPONENT>)?
      | ("-")? (["0"-"9"])+ <EXPONENT>
  >
| < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
|
  < STRING_LITERAL:
      ("\"" ((~["\"","\\"]) | ("\\" ( ["\\","\""] )))* "\"") |
      ("\'" ((~["\'","\\"]) | ("\\" ( ["\\","\'"] )))* "\'")
  >
| < BIND: ("?"(<LETTER>|<DIGIT>)+) >
| < BIND2: ("?"(<LETTER>|<DIGIT>)+"&:") >
| < BIND3: ("?*"(<LETTER>|<DIGIT>)+"*") >
| < BIND4: ("$?"(<LETTER>|<DIGIT>)+) >
| < BINDING: "bind" >
| < BOOLEAN: "BOOLEAN" >
| < ASSERT: "assert" >
| < ASSERTTEMPORAL: "assert-temporal" >
| < AUTOFOCUS: "auto-focus" >
| < CHAININGDIRECTION: "chaining-direction" >
| < COMMAND: "command" >
| < DECLARE: "declare" >
| < DEFCLASS: "defclass" >
| < DEFFACT: "deffact" >
| < DEFFUNCTION: "deffunction" >
| < DEFGENERIC: "defgeneric" >
| < DEFGLOBAL: "defglobal" >
| < DEFINSTANCE: "definstance" >
| < DEFMETHOD: "defmethod" >
| < DEFMODULE: "defmodule" >
| < DEFRULE: "defrule" >
| < DEFTEMPLATE: "deftemplate" >
| < DESCRIBECLASS: "describe-class" >
| < DOUBLE: "DOUBLE" >
| < EXISTS: "exists" >
| < EFFECTIVE: "effective-date" >
| < EXPIRATION: "expiration-date" >
| < FACTINDEX: "fact-index" >
| < FLOAT: "FLOAT" >
| < INTEGER: "INTEGER" >
| < LOGICAL: "logical" >
| < LONG: "LONG" >
| < MODIFY: "modify" >
| < MULTISLOT: "multislot" >
| < NOAGENDA: "no-agenda" >
| < NOLOOP: "no-loop" >
| < NUMBER: "NUMBER" >
| < NOTCE: "not" >
| < REMEMBERMATCH: "remember-match" >
| < RETRACT: "retract" >
| < RULEVERSION: "rule-version" >
| < SALIENCE: "salience" >
| < SEND: "send" >
| < SHORT: "SHORT" >
| < SLOT: "slot" >
| < STRING: "STRING" >
| < SYMBOL: "symbol" >
| < TEST: "test" >
| < TRUE: "TRUE" >
| < TRUE2: "true" >
| < TYPEDEF: "type" >
| < FALSE: "FALSE" >
| < FALSE2: "false" >
| < NIL: "nil" >
| < ARROW: "=>" >
| < ASSIGN: "<-" >
| < SEMICOLON: ";" >
| < PLUS: "+" >
| < MINUS: "-" >
| < MULTIPLY: "*" >
| < DIVIDE: "/" >
| < GT1: ">" >
| < GT2: "gt" >
| < LT1: "<" >
| < LT2: "lt" >
| < EQ1: "==" >
| < EQ2: "eq" >
| < LE1: "<=" >
| < LE2: "le" >
| < GE1: ">=" >
| < GE2: "ge" >
| < NE1: "!=" >
| < NE2: "ne" >
| < AND1: "and" >
| < AND2: "&" >
| < OR1: "or" >
| < OR2: "|" >
| < TILDA: "~" >
| < IDENTIFIER: (<LETTER>|<DIGIT>|<TYPEDEF>|["_",":","-","$",".","@","/"])+ >
|
  < LETTER:
      [
       "\u0024",
       "\u0041"-"\u005a",
       "\u005f",
       "\u0061"-"\u007a",
       "\u00c0"-"\u00d6",
       "\u00d8"-"\u00f6",
       "\u00f8"-"\u00ff",
       "\u0100"-"\u1fff",
       "\u3040"-"\u318f",
       "\u3300"-"\u337f",
       "\u3400"-"\u3d2d",
       "\u4e00"-"\u9fff",
       "\uf900"-"\ufaff"
      ]
  >
|
  < DIGIT:
      [
       "\u0030"-"\u0039",
       "\u0660"-"\u0669",
       "\u06f0"-"\u06f9",
       "\u0966"-"\u096f",
       "\u09e6"-"\u09ef",
       "\u0a66"-"\u0a6f",
       "\u0ae6"-"\u0aef",
       "\u0b66"-"\u0b6f",
       "\u0be7"-"\u0bef",
       "\u0c66"-"\u0c6f",
       "\u0ce6"-"\u0cef",
       "\u0d66"-"\u0d6f",
       "\u0e50"-"\u0e59",
       "\u0ed0"-"\u0ed9",
       "\u1040"-"\u1049"
      ]
  >
|
  < PATH_LITERAL:
      (<LETTER>|<DIGIT>|["_",":","-","\\","/","."])+
  >
}

Expression nextExpression() :
{
  Expression exp = null;
  Token obj = null;
  BoundParam bp = null;
  Signature func = null;
  Signature functionParam = null;
}
{
  obj = getBindType()
  {
    bp = new BoundParam();
    bp.setVariableName(obj.image);
    return bp;
  }
|
  (<LBRACE> func = expr() <RBRACE>)
  {
    return func;
  }
|
  <EOF>
  {
    return null;
  }
|
  LOOKAHEAD(<STRING_LITERAL>|<INTEGER_LITERAL>|<FLOATING_POINT_LITERAL>)
  {
    exp = typeExpr();
    return exp;
  }
}

// main expression for loading a data file
List loadExpr() :
{
  ArrayList facts = new ArrayList();
}
{
  (loadAllExpr(facts))+
  {
    return facts;
  }
}

// this method is used to load data
void loadAllExpr(List list) :
{
  JamochaValue[] param = null;
}
{
  param = assertBody()
  {
    list.add(param);
  }
}

// typeExpr is only responsible for parsing string and numeric types
JamochaValue typeExpr() :
{
  Token exp;
}
{
  exp = <STRING_LITERAL>
  {
    String strlit = exp.image;
    strlit = ParserUtils.getStringLiteral(strlit);
    return JamochaValue.newString(strlit);
  }
|
  exp = <INTEGER_LITERAL>
  {
    // we use Long
    return JamochaValue.newLong(Long.parseLong(exp.image));
  }
|
  exp = <FLOATING_POINT_LITERAL>
  {
    // we use float, double
    return JamochaValue.newDouble(Double.parseDouble(exp.image));
  }
|
  exp = <PATH_LITERAL>
  {
    return JamochaValue.newString(exp.image);
  }
}

Signature expr() :
{
  Token exp = null;
  Token exp2 = null;
  Token exp3 = null;
  String body;
  Deftemplate templ;
  Defrule rule;
  Signature func;
  ArrayList list = new ArrayList();
  JamochaValue[] pms;
  ExpressionSequence infunc = new ExpressionSequence();
}
{
  exp = <ASSERT> <LBRACE> exp2 = <IDENTIFIER>
  (assertContents(list))+ <RBRACE>
  {
    func = new Signature(exp.image);
    pms = new JamochaValue[2];
    pms[0] = JamochaValue.newIdentifier(exp2.image);
    pms[1] = JamochaValue.newObject(list.toArray());
    func.setParameters(pms);
    exp.clear();
    exp = null;
    return func;
  }
|
  exp = <ASSERTTEMPORAL> <LBRACE> exp2 = <IDENTIFIER>
  (assertContents(list))+ <RBRACE>
  {
    func = new Signature(exp.image);
    pms = new JamochaValue[2];
    pms[0] = JamochaValue.newIdentifier(exp2.image);
    pms[1] = JamochaValue.newObject(list.toArray());
    func.setParameters(pms);
    exp.clear();
    exp = null;
    return func;
  }
|
  exp = <RETRACT> (exp2 = <BIND> | exp2 = <INTEGER_LITERAL>)
  {
    func = new Signature(exp.image);
    Parameter[] rpms = new Parameter[1];
    if (exp2.image.startsWith("?")) {
      BoundParam bp = new BoundParam();
      bp.setVariableName(exp2.image);
      rpms[0] = bp;
    } else {
      JamochaValue vp = JamochaValue.newLong(Long.parseLong(exp2.image));
      rpms[0] = vp;
    }
    func.setParameters(rpms);
    exp.clear();
    exp = null;
    exp2.clear();
    exp2 = null;
    return func;
  }
|
  exp = <MODIFY> exp2 = <BIND> assertContents(list)
  {
    func = new Signature(exp.image);
    BoundParam bp = new BoundParam();
    bp.setVariableName(exp2.image);
    list.add(0,bp);
    func.setParameters(ParameterUtils.slotToParameters(list));
    exp.clear();
    exp = null;
    return func;
  }
|
  exp = <DEFTEMPLATE>
  templ = templateExpr()
  {
    func = new Signature(exp.image);
    pms = new JamochaValue[1];
    pms[0] = JamochaValue.newObject(templ);
    func.setParameters(pms);
    return func;
  }
|
  exp = <DEFMODULE>
  body = getIdentifier()
  {
    func = new Signature(exp.image);
    pms = new JamochaValue[1];
    pms[0] = JamochaValue.newIdentifier(body);
    func.setParameters(pms);
    return func;
  }
|
  exp = <DEFRULE>
  rule = ruleBody() 
  {
    func = new Signature(exp.image);
    pms = new JamochaValue[1];
    pms[0] = JamochaValue.newObject(rule);
    func.setParameters(pms);
    return func;
  }
|
  exp = <DEFCLASS> ((valueParams(list))+)?
  {
    func = new Signature(exp.image);
    func.setParameters(ParameterUtils.convertParameters(list));
    list.clear();
    return func;
  }
|
  exp = <DEFFUNCTION>
  exp2 = <IDENTIFIER> <LBRACE>
  ((bindingParams(list))+)? <RBRACE> (exp3 = <STRING_LITERAL>)? (<LBRACE>
  (ruleAction(infunc))? <RBRACE>)+
  {
    func = new Signature(exp.image);
    List parameters = new ArrayList();
    parameters.add(JamochaValue.newIdentifier(exp2.image));
    parameters.add(JamochaValue.newObject(ParameterUtils.convertParameters(list)));
    if(exp3 != null) {
      parameters.add(JamochaValue.newString(ParserUtils.getStringLiteral(exp3.image)));
    }
    parameters.add(infunc);
    func.setParameters(ParameterUtils.convertParameters(parameters));
    return func;
  }
|
  // example: (bind ?*x* 9)
  <BINDING> exp = getBindType() (valueParams(list))+
  {
    func = new Signature("bind");
    list.add(0,JamochaValue.newIdentifier(exp.image.substring(1)));
    func.setParameters(ParameterUtils.convertParameters(list));
    list.clear();
    return func;
  }
|
  (exp = <PLUS>|
   exp = <MINUS>|
   exp = <MULTIPLY>|
   exp = <DIVIDE>|
   exp = <GT1>|
   exp = <GT2>|
   exp = <LT1>|
   exp = <LT2>|
   exp = <EQ1>|
   exp = <EQ2>|
   exp = <LE1>|
   exp = <LE2>|
   exp = <GE1>|
   exp = <GE2>) (valueParams(list))+
  {
    func = new Signature(exp.image);
    func.setParameters(ParameterUtils.convertParameters(list));
    list.clear();
    return func;
  }
|
  exp = <IDENTIFIER> ((valueParams(list))+)?
  {
    func = new Signature(exp.image);
    func.setParameters(ParameterUtils.convertParameters(list));
    list.clear();
    return func;
  }
}

void valueParams(List list) :
{
  Object exp;
  Token tok;
  JamochaValue vp = null;
}
{
  LOOKAHEAD(<LBRACE>)<LBRACE>exp = expr()<RBRACE>
  {
    Signature subfunc = (Signature)exp;
    list.add(subfunc);
  }
|
  exp = typeExpr()
  {
    vp = (JamochaValue)exp;
    list.add(vp);
  }
|
  exp = <IDENTIFIER>
  {
    vp = JamochaValue.newIdentifier(((Token)exp).image);
    list.add(vp);
  }
|
  exp = <TRUE>
  {
    vp = JamochaValue.TRUE;
    list.add(vp);
  }
|
  exp = <TRUE2>
  {
    vp = JamochaValue.TRUE;
    list.add(vp);
  }
|
  exp = <FALSE>
  {
    vp = JamochaValue.FALSE;
    list.add(vp);
  }
|
  exp = <FALSE2>
  {
    vp = JamochaValue.FALSE;
    list.add(vp);
  }
|
  // in some cases, the parameters may be a binding to a variable
  tok = getBindType()
  {
    BoundParam bp = new BoundParam();
    if (tok.kind == CLIPSParserConstants.BIND4) {
      bp.setVariableName(tok.image.substring(2));
      bp.setIsMultislot(true);
    } else {
      bp.setVariableName(tok.image);
    }
    list.add(bp);
  }
}

/**
 * bindingParams is meant to parse the params for a deffunction
 */
void bindingParams(List list) :
{
  Token tok;
}
{
  tok = getBindType()
  {
    BoundParam bp = new BoundParam();
    if (tok.kind == CLIPSParserConstants.BIND4) {
      bp.setVariableName(tok.image.substring(2));
      bp.setIsMultislot(true);
    } else {
      bp.setVariableName(tok.image);
    }
    list.add(bp);
  }
}

Token getBindType() :
{
  Token exp;
}
{
  exp = <BIND3>
  {
    return exp;
  }
|
  exp = <BIND>
  {
    return exp;
  }
|
  exp = <BIND4>
  {
    return exp;
  }
}

/**
 * this is for convienance
 */
String getIdentifier() :
{
  Token exp;
}
{
  exp = <IDENTIFIER>
  {
    return exp.image;
  }
}

JamochaValue[] assertBody() :
{
  Token exp;
  List tokens = new ArrayList();
  JamochaValue[] param = null;
}
{
  <LBRACE> exp = <IDENTIFIER> (assertContents(tokens))+ <RBRACE>
  {
    param = new JamochaValue[2];
    param[0] = JamochaValue.newIdentifier(exp.image);
    param[1] = JamochaValue.newObject(tokens.toArray());
    tokens.clear();
    exp = null;
    return param;
  }
}

/* assert body */
void assertContents(List tokens) :
{
  Token exp;
  JamochaValue body = null;
}
{
  <LBRACE> exp = <IDENTIFIER> (body = checkMultiSlot())? <RBRACE>
  {
    if (body != null) {
      Slot s = new Slot(exp.image, body);
      tokens.add(s);
    }
    exp.clear();
    exp = null;
    body = null;
  }
}

JamochaValue checkMultiSlot() :
{
  Object body;
  ArrayList artokens = new ArrayList();
}
{
  LOOKAHEAD(<IDENTIFIER><IDENTIFIER>) (arrayType(artokens))+
  {
    JamochaValue[] values = new JamochaValue[artokens.size()];
    for(int i=0; i<artokens.size(); ++i) {
      values[i] = (JamochaValue) artokens.get(i);
    }
    return JamochaValue.newList(values);
  }
|
  LOOKAHEAD(<STRING_LITERAL><STRING_LITERAL>) (arrayType(artokens))+
  {
    JamochaValue[] values = new JamochaValue[artokens.size()];
    for(int i=0; i<artokens.size(); ++i) {
      values[i] = (JamochaValue) artokens.get(i);
    }
    return JamochaValue.newList(values);
  }
|
  LOOKAHEAD(<INTEGER_LITERAL><INTEGER_LITERAL>) (arrayType(artokens))+
  {
    JamochaValue[] values = new JamochaValue[artokens.size()];
    for(int i=0; i<artokens.size(); ++i) {
      values[i] = (JamochaValue) artokens.get(i);
    }
    return JamochaValue.newList(values);
  }
|
  LOOKAHEAD(<FLOATING_POINT_LITERAL><FLOATING_POINT_LITERAL>) (arrayType(artokens))+
  {
    JamochaValue[] values = new JamochaValue[artokens.size()];
    for(int i=0; i<artokens.size(); ++i) {
      values[i] = (JamochaValue) artokens.get(i);
    }
    return JamochaValue.newList(values);
  }
|
  LOOKAHEAD(<BIND><BIND>) (arrayType(artokens))+
  {
    JamochaValue[] values = new JamochaValue[artokens.size()];
    for(int i=0; i<artokens.size(); ++i) {
      values[i] = (JamochaValue) artokens.get(i);
    }
    return JamochaValue.newList(values);
  }
|
  LOOKAHEAD(<BIND3><BIND3>) (arrayType(artokens))+
  {
    JamochaValue[] values = new JamochaValue[artokens.size()];
    for(int i=0; i<artokens.size(); ++i) {
      values[i] = (JamochaValue) artokens.get(i);
    }
    return JamochaValue.newList(values);
  }
|
  body = slotValueType()
  {
    return (JamochaValue)body;
  }
}

JamochaValue slotValueType() :
{
  JamochaValue body;
  boolean bval;
  Token btoken;
}
{
  btoken = getBindType()
  {
      BoundParam bp = new BoundParam();
      bp.setVariableName(btoken.image);
      return JamochaValue.newBinding(bp);
  }
|
  body = typeExpr()
  {
    return body;
  }
|
  bval = trueFalse()
  {
    return bval?JamochaValue.TRUE:JamochaValue.FALSE;
  }
|
  btoken = <IDENTIFIER>
  {
    return JamochaValue.newIdentifier(btoken.image);
  }
}

/* arrayType handles multislot tokens */
void arrayType(List tokens) :
{
  Token tval;
  Object val;
  BoundParam bp;
}
{
  tval = <IDENTIFIER>
  {
    tokens.add(tval.image);
  }
|
  tval = <BIND>
  {
    bp = new BoundParam();
    bp.setVariableName(tval.image);
    tokens.add(JamochaValue.newBinding(bp));
  }
|
  tval = <BIND3>
  {
    bp = new BoundParam();
    bp.setVariableName(tval.image);
    tokens.add(JamochaValue.newBinding(bp));
  }
|
  val = typeExpr()
  {
    tokens.add(val);
  }
}

/* templateExpr gets the slots of a deftemplate */
Deftemplate templateExpr() :
{
  Token exp;
  Deftemplate template;
  List slots = new ArrayList();
}
{
  /* javacc gives a warning for this, but not sure how to do it better */
  exp = <IDENTIFIER> (templateBody(slots))+
  {
    TemplateSlot[] s = new TemplateSlot[slots.size()];
    slots.toArray(s);
    template = new Deftemplate(exp.image,null,s);
    slots.clear();
    exp.clear();
    exp = null;
    return template;
  }
}

void templateBody(List slots) :
{
  Token sname;
  JamochaType stype;
  int sid;
  TemplateSlot sl;
}
{
  LOOKAHEAD(<LBRACE> <SLOT>)<LBRACE> <SLOT> sname = <IDENTIFIER> stype = slotType() <RBRACE>
  {
    sid = slots.size();
    sl = new TemplateSlot(sname.image);
    sl.setId(sid);
    sl.setValueType(stype);
    slots.add(sl);
    sname = null;
  }
|
  LOOKAHEAD(<LBRACE> <MULTISLOT>)<LBRACE> <MULTISLOT> sname = <IDENTIFIER> <RBRACE>
  {
    sid = slots.size();
    sl = new TemplateSlot(sname.image);
    sl.setMultiSlot(true);
    sl.setId(sid);
    slots.add(sl);
    sname = null;
  }
}

JamochaType slotType() :
{
  JamochaType stype = JamochaType.UNDEFINED;
  JamochaType defaultType = JamochaType.UNDEFINED;
}
{
  /* the type declaration is optional, so question mark is used to tell javacc */
  (<LBRACE> <TYPEDEF> stype = getType() <RBRACE>)?
  {
    if (!stype.equals(JamochaType.UNDEFINED)) {
      defaultType = stype;
    }
    return defaultType;
  }
}

JamochaType getType() :
{
}
{
  <INTEGER>
  {
    return JamochaType.LONG;
  }
|
  <SHORT>
  {
    return JamochaType.LONG;
  }
|
  <LONG>
  {
    return JamochaType.LONG;
  }
|
  <FLOAT>
  {
    return JamochaType.DOUBLE;
  }
|
  <DOUBLE>
  {
    return JamochaType.DOUBLE;
  }
|
  <SYMBOL>
  {
    return JamochaType.IDENTIFIER;
  }
|
  <STRING>
  {
    return JamochaType.STRING;
  }
|
  <BOOLEAN>
  {
    return JamochaType.BOOLEAN;
  }
}

Defrule ruleBody() :
{
  Token exp = null;
  Token rulecomment = null;
  Defrule rule;
  List dec = new ArrayList();
  List conditions = new ArrayList();
  ExpressionSequence actions = new ExpressionSequence();
}
{
  exp = <IDENTIFIER> (LOOKAHEAD(<STRING_LITERAL>)rulecomment=<STRING_LITERAL>)?
  (LOOKAHEAD(<LBRACE><DECLARE>)ruleDeclaration(dec))? ((conditionElement(conditions))+)?
  arrow() 
  ruleActions(actions)
  {
    rule = new Defrule(exp.image);
    if (rulecomment != null) {
      rule.setDescription(rulecomment.image);
    }
    rule.setRuleProperties(dec);
    Iterator itr = conditions.iterator();
    while (itr.hasNext()) {
      rule.addCondition( (Condition)itr.next() );
    }
    
    for(int i=0;i<actions.size();++i){
      Expression acn = actions.get(i);
      if (acn instanceof Signature) {
        FunctionAction faction = new FunctionAction();
        faction.setFunction((Signature)acn);
        rule.addAction(faction);
      } else if (acn instanceof Action) {
        rule.addAction( (Action)acn );
      }
    }
    dec.clear();
    conditions.clear();
    exp = null;
    return rule;
  }
}

void ruleDeclaration(List list) :
{
}
{
  <LBRACE> <DECLARE> (ruleProperty(list)) <RBRACE>
  {
  }
}

void ruleProperty(List list) :
{
  Object exp = null;
  boolean tf = true;
  String ver = null;
  boolean remember = true;
  String direction = null;
  String date = null;
}
{
  (LOOKAHEAD(<LBRACE><SALIENCE>)exp = salience())?
  {
    if (exp != null) {
      Long intsal = new Long( ((Token)exp).image);
      RuleProperty sal = new RuleProperty(RuleProperty.SALIENCE,intsal.intValue());
      list.add(sal);
    }
  }
  (LOOKAHEAD(<LBRACE><AUTOFOCUS>)tf = autoFocus())?
  {
    RuleProperty auto = new RuleProperty(RuleProperty.AUTO_FOCUS,tf);
    list.add(auto);
  }
  (LOOKAHEAD(<LBRACE><RULEVERSION>) ver = ruleVersion())?
  {
    RuleProperty rp = new RuleProperty(RuleProperty.VERSION,ver);
    list.add(rp);
  }
  (LOOKAHEAD(<LBRACE><REMEMBERMATCH>) remember = remember())?
  {
    RuleProperty rmem = new RuleProperty(RuleProperty.REMEMBER_MATCH,remember);
    list.add(rmem);
  }
  (LOOKAHEAD(<LBRACE><EFFECTIVE>) date = effectiveDate())?
  {
    RuleProperty eff = new RuleProperty(RuleProperty.EFFECTIVE_DATE,date);
    list.add(eff);
  }
  (LOOKAHEAD(<LBRACE><EXPIRATION>) date = expirationDate())?
  {
    RuleProperty expr = new RuleProperty(RuleProperty.EXPIRATION_DATE,date);
    list.add(expr);
  }
  (LOOKAHEAD(<LBRACE><CHAININGDIRECTION>) direction = direction())?
  {
    RuleProperty dir = new RuleProperty(RuleProperty.DIRECTION,direction);
    list.add(dir);
  }
  (LOOKAHEAD(<LBRACE><NOAGENDA>) remember = noAgenda())?
  {
    RuleProperty noagenda = new RuleProperty(RuleProperty.NO_AGENDA,remember);
    list.add(noagenda);
  }
}

Object salience() :
{
  Object val = null;
}
{
  <LBRACE> <SALIENCE> val = <INTEGER_LITERAL> <RBRACE>
  {
    if (val != null) {
      return val;
    } else {
      return null;
    }
  }
}

boolean autoFocus() :
{
  boolean tf = false;
}
{
  <LBRACE> <AUTOFOCUS> tf = trueFalse() <RBRACE>
  {
    return tf;
  }
}

String ruleVersion() :
{
  Token exp;
}
{
  <LBRACE><RULEVERSION> exp = <PATH_LITERAL> <RBRACE>
  {
    return exp.image;
  }
}

boolean remember() :
{
  boolean tf = false;
}
{
  <LBRACE> <REMEMBERMATCH> tf = trueFalse() <RBRACE>
  {
    return tf;
  }
}

String direction() :
{
  Token exp;
  String defaultDir = "forward";
}
{
  <LBRACE><CHAININGDIRECTION> exp = <IDENTIFIER> <RBRACE>
  {
    if (exp != null && exp.image.equals("backward")) {
      return exp.image;
    } else {
      return defaultDir;
    }
  }
}

boolean noAgenda() :
{
  boolean tf = false;
}
{
  <LBRACE> <NOAGENDA> tf = trueFalse() <RBRACE>
  {
    return tf;
  }
}

String effectiveDate() :
{
  Token date;
}
{
  <LBRACE> <EFFECTIVE> date = <STRING_LITERAL> <RBRACE>
  {
    return date.image.substring(1,date.image.length() - 1);
  }
}

String expirationDate() :
{
  Token date;
}
{
  <LBRACE> <EXPIRATION> date = <STRING_LITERAL> <RBRACE>
  {
    return date.image.substring(1,date.image.length() - 1);
  }
}

boolean trueFalse() :
{
}
{
  <TRUE>
  {
    return true;
  }
|
  <TRUE2>
  {
    return true;
  }
|
  <FALSE>
  {
    return false;
  }
|
  <FALSE2>
  {
    return false;
  }
}

void conditionElement(List list) :
{
  Token exp;
}
{
  // handle ?var <- (context (name startup) )
  LOOKAHEAD(<BIND>) exp = <BIND> <ASSIGN> <LBRACE> CEType(list) <RBRACE>
  {
    ObjectCondition oc = (ObjectCondition)list.get(list.size() -1);
    BoundConstraint bc = new BoundConstraint(oc.getTemplateName(),true);
    bc.setValue(JamochaValue.newIdentifier(exp.image.substring(1)));
    oc.addConstraint(bc,0);
  }
|
  <LBRACE> CEType(list) <RBRACE>
  {
  }
}

void CEType(List list) :
{
  Token exp;
  Signature nested = null;
  List alpha = new ArrayList();
  ObjectCondition oc = null;
}
{
  // (not (path (id ?seatID) (name ?g2) ) )
  LOOKAHEAD(<NOTCE><LBRACE><IDENTIFIER><LBRACE>)
  <NOTCE> <LBRACE> exp = <IDENTIFIER> ((templatePatterns(alpha))+)? <RBRACE>
  {
    oc = new ObjectCondition();
    oc.setNegated(true);
    oc.setTemplateName(exp.image);
    Iterator itr = alpha.iterator();
    while (itr.hasNext()) {
      oc.addConstraint((Constraint)itr.next());
    }
    list.add(oc);
    alpha.clear();
    exp = null;
  }
|
  <NOTCE> <LBRACE> nested = expr() <RBRACE>
  {
    TestCondition tc = new TestCondition();
    tc.setNegated(true);
    tc.setFunction(nested);
    list.add(tc);
  }
|
  // (test (> ?var1 ?var2) )
  <TEST> <LBRACE> nested = expr() <RBRACE>
  {
    tc = new TestCondition();
    tc.setFunction(nested);
    list.add(tc);
  }
|
  <AND1> (<LBRACE> nested = expr() <RBRACE>)+
  {
    AndCondition ac = new AndCondition();
    ac.addNestedConditionElement(nested);
    list.add(ac);
  }
|
  <EXISTS> (<LBRACE> CEType(alpha) <RBRACE>)+
  {
    ExistCondition exc = new ExistCondition();
    exc.addNestedConditionElement(alpha);
    list.add(exc);
  }
|
  exp = <IDENTIFIER> ((templatePatterns(alpha))+)?
  {
    oc = new ObjectCondition();
    oc.setTemplateName(exp.image);
    Iterator itr = alpha.iterator();
    while (itr.hasNext()) {
      oc.addConstraint((Constraint)itr.next());
    }
    list.add(oc);
    alpha.clear();
    exp = null;
  }
}


void templatePatterns(List list) :
{
  Token exp = null;
}
{
  <LBRACE> exp = <IDENTIFIER> propertyType(list,exp) <RBRACE>
  {
    exp = null;
  }
}

void propertyType(List list, Token identifier) :
{
  Token id = null;
  JamochaValue body = null;
  Token body2 = null;
  boolean bval = false;
  LiteralConstraint vc;
  BoundConstraint bc;
  OrLiteralConstraint orc;
  AndLiteralConstraint andc;
  List andor = new java.util.ArrayList();
  MultiValue mv = null;
}
{
  LOOKAHEAD(<BIND2>) predicateFunc(list,identifier)
  {
    // do nothing
  }
|
  LOOKAHEAD(<BIND4>) body2 = <BIND4>
  {
    if (body2 != null) {
      bc = new BoundConstraint();
      bc.setName(identifier.image);
      bc.setValue(JamochaValue.newIdentifier(body2.image.substring(2)));
      bc.setIsMultislot(true);
      list.add(bc);
    }
  }
|
  LOOKAHEAD(<BIND>) body2 = <BIND>
  {
    if (body2 != null) {
      bc = new BoundConstraint();
      bc.setName(identifier.image);
      bc.setValue(JamochaValue.newIdentifier(body2.image.substring(1)));
      list.add(bc);
    }
  }
|
  LOOKAHEAD(<TILDA><BIND>) <TILDA> body2 = <BIND>
  {
    if (body2 != null) {
      bc = new BoundConstraint();
      bc.setName(identifier.image);
      bc.setValue(JamochaValue.newIdentifier(body2.image.substring(1)));
      bc.setNegated(true);
      list.add(bc);
    }
  }
|
  LOOKAHEAD((<STRING_LITERAL>|<INTEGER_LITERAL>|<FLOATING_POINT_LITERAL>)<OR2>) body = typeExpr() 
    (<OR2> orType(andor))+
  {
    if (body != null) {
      orc = new OrLiteralConstraint();
      orc.setName(identifier.image);
      mv = new MultiValue(body);
      orc.addValue(mv);
      orc.addValues(andor);
      list.add(orc);
    }
  }
|
  LOOKAHEAD(<TILDA>(<STRING_LITERAL>|<INTEGER_LITERAL>|<FLOATING_POINT_LITERAL>)<OR2>) <TILDA> body = typeExpr() 
    (<OR2> orType(andor))+
  {
    if (body != null) {
      orc = new OrLiteralConstraint();
      orc.setName(identifier.image);
      mv = new MultiValue(body);
      mv.setNegated(true);
      orc.addValue(mv);
      orc.addValues(andor);
      list.add(orc);
    }
  }
|
  LOOKAHEAD((<STRING_LITERAL>|<INTEGER_LITERAL>|<FLOATING_POINT_LITERAL>)<AND2>) body = typeExpr() 
    (<AND2> andType(andor))+
  {
    if (body != null) {
      andc = new AndLiteralConstraint();
      andc.setName(identifier.image);
      mv = new MultiValue(body);
      andc.addValue(mv);
      andc.addValues(andor);
      list.add(andc);
    }
  }
|
  LOOKAHEAD(<TILDA>(<STRING_LITERAL>|<INTEGER_LITERAL>|<FLOATING_POINT_LITERAL>)<AND2>) <TILDA> body = typeExpr() 
    (<AND2> andType(andor))+
  {
    if (body != null) {
      andc = new AndLiteralConstraint();
      andc.setName(identifier.image);
      mv = new MultiValue(body);
      mv.setNegated(true);
      andc.addValue(mv);
      andc.addValues(andor);
      list.add(andc);
    }
  }
|
  LOOKAHEAD(<TILDA>(<STRING_LITERAL>|<INTEGER_LITERAL>|<FLOATING_POINT_LITERAL>)) <TILDA> body = typeExpr()
  {
    if (body != null) {
      vc = new LiteralConstraint();
      vc.setName(identifier.image);
      vc.setValue(body);
      vc.setNegated(true);
      list.add(vc);
    }
  }
|
  LOOKAHEAD(<IDENTIFIER>) id = <IDENTIFIER>
  {
    if (id != null) {
      vc = new LiteralConstraint();
      vc.setName(identifier.image);
      vc.setValue(JamochaValue.newIdentifier(id.image));
      list.add(vc);
    }
  }
|
  LOOKAHEAD(<TILDA><IDENTIFIER>) <TILDA> id = <IDENTIFIER>
  {
    if (id != null) {
      vc = new LiteralConstraint();
      vc.setName(identifier.image);
      vc.setValue(JamochaValue.newIdentifier(id.image));
      vc.setNegated(true);
      list.add(vc);
    }
  }
|
  body = typeExpr()
  {
    if (body != null) {
      vc = new LiteralConstraint();
      vc.setName(identifier.image);
      vc.setValue(body);
      list.add(vc);
    }
  }
|
  bval = trueFalse()
  {
    vc = new LiteralConstraint();
      vc.setName(identifier.image);
      vc.setValue( bval?JamochaValue.TRUE:JamochaValue.FALSE );
      list.add(vc);
  }  
}

void andType(List list) :
{
  Token body = null;
  Object val = null;
  MultiValue mv = null;
}
{
  LOOKAHEAD(<IDENTIFIER>) body = <IDENTIFIER>
  {
    if (body != null) {
      mv = new MultiValue(body.image);
      list.add(mv);
    }
  }
|
  LOOKAHEAD(<TILDA>(<STRING_LITERAL>|<INTEGER_LITERAL>|<FLOATING_POINT_LITERAL>)) <TILDA> val = typeExpr()
  {
    if (val != null) {
      mv = new MultiValue(val,true);
      list.add(mv);
    }
  }
|
  val = typeExpr()
  {
    if (val != null) {
      mv = new MultiValue(val);
      list.add(mv);
    }
  }
}

void orType(List list) :
{
  Token body = null;
  Object val = null;
  MultiValue mv = null;
}
{
  LOOKAHEAD(<IDENTIFIER>) body = <IDENTIFIER>
  {
    if (body != null) {
      mv = new MultiValue(body.image);
      list.add(mv);
    }
  }
|
  LOOKAHEAD(<TILDA>(<STRING_LITERAL>|<INTEGER_LITERAL>|<FLOATING_POINT_LITERAL>)) <TILDA> val = typeExpr()
  {
    if (val != null) {
      mv = new MultiValue(val,true);
      list.add(mv);
    }
  }
|
  val = typeExpr()
  {
    if (val != null) {
      mv = new MultiValue(val);
      list.add(mv);
    }
  }
}

void predicateFunc(List list, Token identifier) :
{
  Token varname = null;
  String func = null;
  List params = new ArrayList();
  Token bind = null;
}
{
  varname = <BIND2> <LBRACE> func = functionName() bind = <BIND> actionParams(params) <RBRACE>
  {
    PredicateConstraint predc = new PredicateConstraint();
    predc.setName(identifier.image);
    predc.setVariableName(
      varname.image.substring(1,varname.image.length() -2));
    predc.setFunctionName(func);
    BoundParam bp = new BoundParam();
    bp.setVariableName(bind.image);
    predc.addParameter(bp);
    predc.addParameters(params);
    list.add(predc);
  }
}

String functionName() :
{
  Token fname = null;
}
{
  fname = <IDENTIFIER>
  {
    return fname.image;
  }
|
  (fname = <PLUS>|
   fname = <MINUS>|
   fname = <MULTIPLY>|
   fname = <DIVIDE>|
   fname = <GT1>|
   fname = <GT2>|
   fname = <LT1>|
   fname = <LT2>|
   fname = <EQ1>|
   fname = <EQ2>|
   fname = <LE1>|
   fname = <LE2>|
   fname = <GE1>|
   fname = <GE2>)
  {
    return fname.image;
  }
}

void arrow() :
{
}
{
  <ARROW>
  {
  }
}

void ruleActions(ExpressionCollection list) :
{
}
{
  ((<LBRACE> ruleAction(list) <RBRACE>)+)?
  {
  }
}

void ruleAction(ExpressionCollection list) :
{
  Parameter exp;
}
{
  exp = expr()
  {
    list.add(exp);
  }
}

void actionParams(List list) :
{
  Object exp;
  JamochaValue vp = null;
  JamochaValue value;
}
{
  exp = <BIND>
  {
    if (exp instanceof Token) {
      BoundParam bp = new BoundParam();
      bp.setVariableName( ((Token)exp).image.substring(1) );
      list.add(bp);
    }
  }
|
  exp = typeExpr()
  {
    vp = (JamochaValue)exp;
    list.add(vp);
  }
|
  exp = <IDENTIFIER>
  {
    if (exp instanceof Token) {
      value = JamochaValue.newIdentifier(((Token)exp).image );
    } else {
      value = JamochaValue.newIdentifier((String)exp);
    }
    vp = value;
    list.add(vp);
  }
}
