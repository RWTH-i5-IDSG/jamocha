/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. /Users/christoph/Documents/workspace/jamocha/src/main/org/jamocha/parser/cool/COOL.jj */
/*@egen*//** Grammar to generate a CLIPS Object Oriented Language (COOL)  parser with jjTree. 
	COOL is the language used by the CLIPS Production system 
		
	This jjTree Grammar creates an abstract synatx tree, based as closely on the 'look'
	of the source code, while the grammar is as close as possible to the specifications.
	This uses lots of rules which do not create nodes...
	
	The Actions  the grammar productions make certain assumptions about the nodes created.
	The following methods should be required by the SimpleNode interface:
		-setName
		-getName
		-execute
	Constructs also have
		-setDocString
		-getDocString
	
	Some Rules do not create Nodes, but instead directly produce data compatible
	with the engine. [ e.g. (autofocus true) is two nodes for 1 bit of information).
	
	Created Nov. 8th, 2006, at the Agent Technologies Practical 2006 at Aachen Technical University.
	
	@author Ory Chowaw-Liebman 
	@author Ulrich Loup
	@todo Can probably be optimized a bit
*/

options {              
	STATIC=false;                                               
    ERROR_REPORTING = true;
}


/* Java code used for the Parser. */
PARSER_BEGIN(COOLParser)
package org.jamocha.parser.cool;

import java.util.ArrayList;

import org.jamocha.parser.JamochaType;
import org.jamocha.parser.Parser;
import org.jamocha.parser.ParserUtils;
import org.jamocha.parser.Expression;

import org.jamocha.rete.Rete;
import org.jamocha.rete.AbstractSlot;
import org.jamocha.rete.Fact;
import org.jamocha.rete.TemplateSlot;
import org.jamocha.rule.*;

/** This is the jjTree Parser Class. Use Start() to parse an expression or construct of the 
	COOL programming langauge, and retrieve the Syntax tree returned as a class of type Node
	(or SimpleNode, or COOLStart).
	The actual parser is generated by jjTree (which generates the node classes for rules, if
	they don't exist) and JavaCC. Most funcitonality lies within the nodes, which therefore
	most not be deleted!! Regenerated nodes will lack members used in the semanic actions!
	Some nodes only contain very little information (as ittle as half a bit :-), so these
	tules do not generate rules, but preferably set the information directly in a class as 
	close as posible to the engine.
	See also class SimpleNode for information on Syntax Trees.
	Note that productions like lists of floats or sets of types should directly produce
	engine compatible classes or java lists, EnumSets and such.
*/
public class COOLParser implements/*@bgen(jjtree)*/ COOLParserTreeConstants, /*@egen*/ Parser{/*@bgen(jjtree)*/
  protected JJTCOOLParserState jjtree = new JJTCOOLParserState();

/*@egen*/

        public Expression nextExpression() throws ParseException {
                return Start();
        }

        public static void main(String args[])
        {
                boolean verbose = (args != null && args.length == 1 && "verbose".equals(args[0]));
                if(!verbose)System.out.println("Note: For verbose output type \"java Main verbose\".\n");
                System.out.print("COOL> ");
                Rete engine = new Rete();
                COOLParser p = new COOLParser(System.in);
                try
                {
                while (true)
                        {
                                COOLStart n = p.Start();
                                if (n==null) System.exit(0);
                                n.dump(" ");
                                System.out.println(n.getValue(engine).toString());
                        }
                }
                catch (Exception e)
                {
                        System.err.println("ERROR: " + e.getMessage());
                        if(verbose)e.printStackTrace();
                }
        }



}

PARSER_END(COOLParser)

/**********************************************
 * Lexical Specs
 */


SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
}

SPECIAL_TOKEN : /* COMMENTS */
{
  <SINGLE_LINE_COMMENT: ";" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
}

TOKEN :
{
  < LBRACE: "(" >
| < RBRACE: ")" >| < GE1: ">=" >
| < #DIGIT: ["0"-"9"] >
| < INTEGER: (["+","-"])? (<DIGIT>)+ >
|
  < FLOAT:
        (<DIGIT>)+ "." (<DIGIT>)* (<EXPONENT>)?
      | "." (<DIGIT>)+ (<EXPONENT>)?
      | (<DIGIT>)+ <EXPONENT>
  >
  
| < #EXPONENT: ["e","E"] (["+","-"])? (<DIGIT>)+ >
| < #GMT_OFFSET: ("+"|"-") ( <DIGIT> )? <DIGIT> >
| < #DATE: <DIGIT> <DIGIT> <DIGIT> <DIGIT> "-" <DIGIT> <DIGIT> "-" <DIGIT> <DIGIT> >
| < #TIME: <DIGIT> <DIGIT> ":" <DIGIT> <DIGIT> ( ":" <DIGIT> <DIGIT>)? >
| < DATETIME:  <DATE> ( " " <TIME> (<GMT_OFFSET>)? )? > 
|
  < STRING:
      ("\"" ((~["\"","\\"]) | ("\\" ( ["\\","\""] )))* "\"") |
      ("\'" ((~["\'","\\"]) | ("\\" ( ["\\","\'"] )))* "\'")
  >
| < INSTANCE: "[" <SYMBOL> "]">
| < SFWILDCARD: "?" >
| < MFWILDCARD: "$?" >
| < GLOBALVAR: "?*" <SYMBOL> "*" >
| < DEFFACTS: "deffacts" >
| < DEFTEMPLATE: "deftemplate" >
| < DEFTEMPLATE_CONSTRUCT: "deftemplate_construct" >
| < DEFRULE: "defrule" >
| < DEFFUNCTION: "deffunction" >
| < DEFGENERIC: "defgeneric" >
| < DEFMETHOD: "defmethod" >
| < DEFCLASS: "defclass" >
| < DEFMESSAGEHANDLER: "defmessage-handler" >
| < DEFINSTANCES: "definstances" >
| < DEFMODULE: "defmodule" >
| < DEFGLOBAL: "defglobal" >
| < DEFAULT_ATR: "default" >
| < DYNAMIC_ATR: "default-dynamic" >
| < ATR_DEFAULT: "?DEFAULT" >
| < ATR_DERIVE: "?DERIVE" >
| < ATR_NONE: "?NONE" >
| < ATR_ALL: "?ALL" >
| < SLOT: "slot" >
| < SINGLE_SLOT: "single-slot" >
| < MULTISLOT: "multislot" >
| < ARROW: "=>">
| < DECLARE: "declare" >
| < SALIENCE: "salience" >
| < AUTOFOCUS: "auto-focus" >
| < EXPORT: "export" >
| < IMPORT: "import" >
| <	TYPE: "type" >
| < TRUE: "TRUE" | "true" | "True" >
| < FALSE: "FALSE" | "false" | "False" >
| < NOT: "not" >
| < AND: "and" >
| < OR: "or" >
| < OF: "of" >
| < LOGICAL: "logical" >
| < TEST: "test" >
| < EXISTS: "exists" >
| < FORALL: "forall">
| < OBJECT: "object" >
| < IS_A: "is-a" >
//| < NAME: "name" >
| < ASSIGN: "<-" >
| < TILDE: "~" >
| < AMPERSAND: "&" >
| < LINE: "|" >
| < COLON: ":" >
| < EQUALS: "=" >
| < VARIABLE_TYPE: "?VARIABLE" >
| < SYMBOL_TYPE: "SYMBOL" >
| < STRING_TYPE: "STRING" >
| < DATETIME_TYPE: "DATETIME" >
| < LEXEME_TYPE: "LEXEME" >
| < INTEGER_TYPE: "INTEGER" >
| < FLOAT_TYPE: "FLOAT" >
| < NUMBER_TYPE: "NUMBER" >
| < INSTANCE_NAME_TYPE: "INSTANCE-NAME" >
| < INSTANCE_ADDRESS_TYPE: "INSTANCE-ADDRESS" >
| < INSTANCE_TYPE: "INSTANCE" >
| < EXTERNAL_ADDRESS_TYPE: "EXTERNAL-ADDRESS" >
| < FACT_ADDRESS_TYPE: "FACT-ADDRESS" >
| < ALLOWED_SYMBOLS: "allowed-symbols" >
| < ALLOWED_STRINGS: "allowed-strings" >
| < ALLOWED_LEXEMES: "allowed-lexemes" >
| < ALLOWED_INTEGERS: "allowed-integers" >
| < ALLOWED_FLOATS: "allowed-floats" >
| < ALLOWED_NUMBERS: "allowed-numbers" >
| < ALLOWED_INSTANCES: "allowed-instances" >
| < ALLOWED_CLASSES: "allowed-classes" >
| < ALLOWED_VALUES: "allowed-values" >
| < RANGE: "range" >
| < CARDINALITY: "cardinality" >
| < ROLE: "role" >
| < CONCRETE: "concrete" >
| < ABSTRACT: "abstract" >
| < PATTERN_MATCH: "pattern-match" >
| < REACTIVE: "reactive" >
| < NON_REACTIVE: "non-reactive" >
| < ACTIVE: "active" >
| < STORAGE: "storage" >
| < LOCAL: "local" >
| < SHARED: "shared" >
| < ACCESS: "access" >
| < READ_WRITE: "read-write" >
| < READ_ONLY: "read-only" >
| < READ: "read" >
| < WRITE: "write" >
| < INITIALIZE_ONLY: "initialize-only" >
| < PROPAGATION: "propagation" >
| < INHERIT: "inherit" >
| < NO_INHERIT: "no-inherit" >
| < SOURCE: "source" >
| < EXCLUSIVE: "exclusive" >
| < COMPOSITE: "composite" >
| < VISIBILITY: "visibility" >
| < PRIVATE: "private" >
| < PUBLIC: "public" >
| < CREATE_ACCESSOR: "create-accessor" >
| < OVERRIDE_MESSAGE: "override-message" >
| < MESSAGE_HANDLER: "message-handler" >
| < PRIMARY: "primary" >
| < AROUND: "around" >
| < BEFORE: "before" >
| < AFTER: "after" >
	// Special functions
| < ASSERT: "assert" >
| < RETRACT: "retract" >
| < FIND_FACT_BY_FACT: "find-fact-by-fact" >
| < MODIFY: "modify" >
| < DUPLICATE: "duplicate" >
| < FACT_RELATION: "fact-relation" >
| < FACT_SLOT_VALUE: "fact-slot-value" >
| < IF: "if" >
| < THEN: "then" >
| < ELSE: "else" >
| < WHILE: "while" >
| < DO: "do" >
| < LOOP_FOR_COUNT: "loop-for-count" >
| < SWITCH: "switch" >
| < CASE: "case" >
| < STAR: "*">
  // If you think this is ugly, you are right. See CLIPS Basic Progrmmers Guide:
  // "Numbers are symbols, but treated different. Instances are symbols, but treated different." 
| < #VARSYMBOL:  ["a"-"z","A"-"Z"] (~[" ","\r","\n","\t","\"","\'","(",")","&","|","<","~",";"])* >
| < SINGLEVAR: ("?" <VARSYMBOL>) >
| < MULTIVAR: ("$?" <VARSYMBOL>) >
| < SYMBOL:  
	(~[" ","\r","\n","\t","\"","\'","(",")","&","|","$","?","~",";","0"-"9","="])
	|(
		(~[" ","\r","\n","\t","\"","\'","(",")","&","|","$","?","~",";","[","="])
		(~[" ","\r","\n","\t","\"","\'","(",")","&","|","?","~",";","0"-"9"])*
		(~[" ","\r","\n","\t","\"","\'","(",")","&","|","<","~",";" ])*
		(~[" ","\r","\n","\t","\"","\'","(",")","&","|","$","?","~",";","]"])? 
	)
	|(
		(~[" ","\r","\n","\t","\"","\'","(",")","&","|","$","?","~",";","="])
		(~[" ","\r","\n","\t","\"","\'","(",")","&","|","?","~",";","0"-"9"])*
		(~[" ","\r","\n","\t","\"","\'","(",")","&","|","<","~",";" ])*
		(~[" ","\r","\n","\t","\"","\'","(",")","&","|","$","?","~",";","]"])+ 
	)
  >

}

/* TODO (From Clips Manual):
Data Types:
<file-name> ::= A symbol or string which is a valid file name (including path information)
	for the operating system under which CLIPS is running
<slot-name> ::= A valid deftemplate_construct slot name
<...-name> ::= A <symbol> where the ellipsis indicate what the symbol represents.
	For example, <rule-name> is a symbol which represents the name of a rule.
*/

/**********************************************
 * Cool Grammar Specs.
 */

/** Start rule is one construct at a time, Parser reads constructs into list.
	No need to create nodes for Start, Defcon and Funcon rule.*/
COOLStart Start() : {/*@bgen(jjtree) Start */
  COOLStart jjtn000 = new COOLStart(this, JJTSTART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Start */
   try {
/*@egen*/
	
   ( LOOKAHEAD(2)
	Construct() | Expression()
	
	)/*@bgen(jjtree)*/
          {
            jjtree.closeNodeScope(jjtn000, true);
            jjtc000 = false;
          }
/*@egen*/ { return jjtn000; }
	| <EOF>/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                }
/*@egen*/ { return null; }/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}


/*
<number> ::= <float> | <integer> 
<lexeme> ::= <symbol> | <string>
<constant> ::= <datetime> | <symbol> | <string> | <integer> | <float> | <instance-name>
*/


Node Float() : {/*@bgen(jjtree) Float */
                 COOLFloat jjtn000 = new COOLFloat(this, JJTFLOAT);
                 boolean jjtc000 = true;
                 jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) Float */
        try {
/*@egen*/
	t=<FLOAT>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		jjtn000.setName(t.image); 
		return jjtn000;
	}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

Node Integer() : {/*@bgen(jjtree) Integer */
                   COOLInteger jjtn000 = new COOLInteger(this, JJTINTEGER);
                   boolean jjtc000 = true;
                   jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) Integer */
        try {
/*@egen*/
	t=<INTEGER>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		jjtn000.setName(t.image); 
		return jjtn000;
	}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

Node DateTime() : {/*@bgen(jjtree) DateTime */
                    COOLDateTime jjtn000 = new COOLDateTime(this, JJTDATETIME);
                    boolean jjtc000 = true;
                    jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) DateTime */
        try {
/*@egen*/
	t=<DATETIME>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		jjtn000.setName(t.image);
		return jjtn000;
	}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


Node Number()       : { Node n; }
{	
	(	n=Float()
	|	n=Integer() 
	) { return n; }
}

Node Symbol() : {/*@bgen(jjtree) Symbol */
                  COOLSymbol jjtn000 = new COOLSymbol(this, JJTSYMBOL);
                  boolean jjtc000 = true;
                  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t;}
{/*@bgen(jjtree) Symbol */
        try {
/*@egen*/
	t=<SYMBOL>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		jjtn000.setName(t.image); 
		return jjtn000;
	}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

Node String() : {/*@bgen(jjtree) String */
                  COOLString jjtn000 = new COOLString(this, JJTSTRING);
                  boolean jjtc000 = true;
                  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) String */
        try {
/*@egen*/
	t=<STRING>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		jjtn000.setName(ParserUtils.getStringLiteral(t.image)); 
		return jjtn000;
	}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/

}


Node Lexeme()       : { Node n; }
{	
	(	n=String()
	|	n=Symbol() 
	) { return n; }
}

Node Instance() : {/*@bgen(jjtree) Instance */
                    COOLInstance jjtn000 = new COOLInstance(this, JJTINSTANCE);
                    boolean jjtc000 = true;
                    jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) Instance */
        try {
/*@egen*/
	t=<INSTANCE>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ 
		jjtn000.setName(t.image);
		return jjtn000;
	}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

Node Constant()      :{ Node n; }
{ 	
	(
		n=DateTime()
	|   n=Symbol()
	|	n=String()
	|	n=Integer()
	|	n=Float()
	|	n=Instance() 
	) { return n; }
}

void Comment()       : {}
{	
    String()
}

/*
<function-name> ::= Any symbol which corresponds to a system or user defined function, a
	deffunction name, or a defgeneric name
	( Ory: I understand this to be a <SYMBOL> token )
<file-name> ::= A symbol or string which is a valid file name (including path information)
	for the operating system under which CLIPS is running

<variable> ::= <single-field-variable> | <multifield-variable> | <global-variable>
<function-call> ::= (<function-name> <expression>*)
<expression> ::= <constant> | <variable> | <function-call>
<action> ::= <expression>
*/

// This is used exactly then when only the variables value is needed
Node SingleVariable() : {/*@bgen(jjtree) SingleVariable */
                          COOLSingleVariable jjtn000 = new COOLSingleVariable(this, JJTSINGLEVARIABLE);
                          boolean jjtc000 = true;
                          jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; } 
{/*@bgen(jjtree) SingleVariable */
        try {
/*@egen*/
	t=<SINGLEVAR>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ jjtn000.setName(t.image); return jjtn000;}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

// This is used exactly then when only the variables value is needed
Node GlobalVariable() : {/*@bgen(jjtree) GlobalVariable */
                          COOLGlobalVariable jjtn000 = new COOLGlobalVariable(this, JJTGLOBALVARIABLE);
                          boolean jjtc000 = true;
                          jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; } 
{/*@bgen(jjtree) GlobalVariable */
        try {
/*@egen*/
	t=<GLOBALVAR>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ jjtn000.setName(t.image); return jjtn000;}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

// This is used exactly then when only the variables contents are needed
Node MultiVariable() : {/*@bgen(jjtree) MultiVariable */
                         COOLMultiVariable jjtn000 = new COOLMultiVariable(this, JJTMULTIVARIABLE);
                         boolean jjtc000 = true;
                         jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; } 
{/*@bgen(jjtree) MultiVariable */
        try {
/*@egen*/
	t=<MULTIVAR>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ jjtn000.setName(t.image); return jjtn000;}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

// This is used exactly then when only the variables value is needed
Node Variable()       : { Node n; }
{	
	(	n=SingleVariable()
	|	n=MultiVariable()
	|	n=GlobalVariable() 
	) { return n;}
}

Node FunctionCall()       : { Token t; Node n;}
{
	"(" (
		( n=AssertFunc() )
	|	( n=RetractFunc() )
	|   ( n=FindFactByFactFunc() )
	|	( n=IfElseFunc() )
	|	( n=AnyFunction() )
	) ")" { return n; }
}

Node AnyFunction() :{/*@bgen(jjtree) AnyFunction */
                      COOLAnyFunction jjtn000 = new COOLAnyFunction(this, JJTANYFUNCTION);
                      boolean jjtc000 = true;
                      jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) AnyFunction */
        try {
/*@egen*/
	t=<SYMBOL> 
	{ jjtn000.setName(t.image); }
	(Expression())*/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/ 
	{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

Node Expression()       : { Node n; } 
{	
	(	LOOKAHEAD(2)
		n=Constant()
	|	n=Variable()
	|	n=FunctionCall() 
	) { return n; }
}

////////////////////////////////////////////////////
// Special functions wich are defined by CLIPS to have
// a non-standart syntax (e.g. not all parameters are expressions)
Node AssertFunc() : {/*@bgen(jjtree) AssertFunc */
  COOLAssertFunc jjtn000 = new COOLAssertFunc(this, JJTASSERTFUNC);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) AssertFunc */
        try {
/*@egen*/
	<ASSERT>
	(RHSPattern())+/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

////////////////////////////////////////////////////
// Special functions wich are defined by CLIPS to have
// a non-standart syntax (e.g. not all parameters are expressions)
Node FindFactByFactFunc() : {/*@bgen(jjtree) FindFactByFactFunc */
  COOLFindFactByFactFunc jjtn000 = new COOLFindFactByFactFunc(this, JJTFINDFACTBYFACTFUNC);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) FindFactByFactFunc */
        try {
/*@egen*/
	<FIND_FACT_BY_FACT>
	(RHSPattern())+/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

Node RetractFunc() : {/*@bgen(jjtree) RetractFunc */
  COOLRetractFunc jjtn000 = new COOLRetractFunc(this, JJTRETRACTFUNC);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) RetractFunc */
        try {
/*@egen*/
	<RETRACT>
	(
		<STAR>	// Retract all
	|	(
			(Expression())*		// Integers and 'retract-specifiers' see BPG
		)
	)/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
//	RHSPattern()+
	{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

Node IfElseFunc() : {/*@bgen(jjtree) IfElseFunc */
                      COOLIfElseFunc jjtn000 = new COOLIfElseFunc(this, JJTIFELSEFUNC);
                      boolean jjtc000 = true;
                      jjtree.openNodeScope(jjtn000);
/*@egen*/ Node n;}
{/*@bgen(jjtree) IfElseFunc */
        try {
/*@egen*/
	<IF>
	Expression()
	<THEN>
	n=ActionList()
	[
		<ELSE>
		n=ActionList()
	]/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

Node WhileFunc() : {/*@bgen(jjtree) WhileFunc */
  COOLWhileFunc jjtn000 = new COOLWhileFunc(this, JJTWHILEFUNC);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) WhileFunc */
        try {
/*@egen*/
	<WHILE>
	Expression()
	[<DO>]
	ActionList()/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

Node LoopForCntFunc() : {/*@bgen(jjtree) LoopForCntFunc */
  COOLLoopForCntFunc jjtn000 = new COOLLoopForCntFunc(this, JJTLOOPFORCNTFUNC);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) LoopForCntFunc */
        try {
/*@egen*/
	<LOOP_FOR_COUNT>
	(
		"("
		SingleVariable()
		[
			Expression() { /*End Index for node*/ }
		[ Expression() { /*End Index for node, move previous to start*/ } ]
		]
		")"
	)
	[<DO>]
	ActionList()/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

Node SwitchCaseFunc() : {/*@bgen(jjtree) SwitchCaseFunc */
  COOLSwitchCaseFunc jjtn000 = new COOLSwitchCaseFunc(this, JJTSWITCHCASEFUNC);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) SwitchCaseFunc */
        try {
/*@egen*/
	<SWITCH>
	Expression()	// Test Expression
	(	LOOKAHEAD(2)
		CaseStatement()
	)*
	([	
		"(" <DEFAULT_ATR> ActionList()
	])/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void CaseStatement() : {/*@bgen(jjtree) CaseStatement */
  COOLCaseStatement jjtn000 = new COOLCaseStatement(this, JJTCASESTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) CaseStatement */
        try {
/*@egen*/
	"(" 
		<CASE> 
		Expression()	// Comparison Expression
		<THEN> 
		ActionList()
	")"/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/** Dummy Defined in CLIPS programmers guide... */
void Action()       : {} {  Expression() }


/** Main Handler for Definition constructs.
	Note it contains the parantheses for the constructs
*/
void Construct()       : {}
{
	"("
	( LOOKAHEAD(2)
		DeffactsConstruct()
	|	DeftemplateConstruct()
	|	DefglobalConstruct()
	|	DefruleConstruct()
	|	DeffunctionConstruct()
	|	DefgenericConstruct()
	|	DefmethodConstruct()
 	|	DefclassConstruct()
	|	DefmessageHandlerConstruct()
	|	DefinstancesConstruct()
	|	DefmoduleConstruct()
	)
	")"
}

/* Deffacts construct: 
	<deffacts-construct> ::= (deffacts <deffacts-name> [<comment>] <RHS-pattern>*) 
*/
void DeffactsConstruct() :{/*@bgen(jjtree) DeffactsConstruct */
                            COOLDeffactsConstruct jjtn000 = new COOLDeffactsConstruct(this, JJTDEFFACTSCONSTRUCT);
                            boolean jjtc000 = true;
                            jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) DeffactsConstruct */
      try {
/*@egen*/
      <DEFFACTS>
      t = <SYMBOL>
      { jjtn000.setName(t.image); }
      [
		t=<STRING>
		{ jjtn000.setDocString(ParserUtils.getStringLiteral(t.image)); }
	  ]
      (RHSPattern())*/*@bgen(jjtree)*/
      } catch (Throwable jjte000) {
        if (jjtc000) {
          jjtree.clearNodeScope(jjtn000);
          jjtc000 = false;
        } else {
          jjtree.popNode();
        }
        if (jjte000 instanceof RuntimeException) {
          throw (RuntimeException)jjte000;
        }
        if (jjte000 instanceof ParseException) {
          throw (ParseException)jjte000;
        }
        throw (Error)jjte000;
      } finally {
        if (jjtc000) {
          jjtree.closeNodeScope(jjtn000, true);
        }
      }
/*@egen*/
}

/* Deftemplate construct
<deftemplate-construct> ::= (deftemplate <deftemplate-name> [<comment>] <slot-definition>*)
<slot-definition> ::= <single-slot-definition> | <multislot-definition> 
<single-slot-definition> ::= (slot <slot-name> <template-attribute>*)
<multislot-definition> ::= (multislot <slot-name> <template-attribute>*)
<template-attribute> ::= <default-attribute> | <constraint-attribute>
<default-attribute> ::= (default ?DERIVE | ?NONE | <expression>*) | (default-dynamic <expression>*)
*/
void DeftemplateConstruct() :{/*@bgen(jjtree) DeftemplateConstruct */
                               COOLDeftemplateConstruct jjtn000 = new COOLDeftemplateConstruct(this, JJTDEFTEMPLATECONSTRUCT);
                               boolean jjtc000 = true;
                               jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; AbstractSlot s;}
{/*@bgen(jjtree) DeftemplateConstruct */
        try {
/*@egen*/
        <DEFTEMPLATE>
        t = <SYMBOL>
        { 
			jjtn000.setName(t.image); 
		}
	    [
			t=<STRING>
			{ jjtn000.setDocString(ParserUtils.getStringLiteral(t.image)); }
		]
        (
			s=SlotDefinition() { jjtn000.addSlot(s); }
        )*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//<slot-definition> ::= <single-slot-definition> | <multislot-definition>
AbstractSlot SlotDefinition()       : { AbstractSlot ret;}
{
    ( 
		"(" ( ret=SingleSlotDefinition() | ret=MultislotDefinition() ) ")" 
    )	{ return ret; }
}

//<single-slot-definition> ::= (slot <slot-name> <template-attribute>*)
AbstractSlot SingleSlotDefinition()       :
{ 
	Token t;
	TemplateSlot ts = new TemplateSlot();
}
{
	<SLOT>
	t = <SYMBOL>
	{ 
		ts.setName(t.image); //<slot-name>
	}
	(
		TemplateAttribute(ts)
	)*
	{ return ts; }
}

//<multislot-definition> ::= (multislot <slot-name> <template-attribute>*)
AbstractSlot MultislotDefinition()       :
{ 
	Token t; 
	TemplateSlot ts = new TemplateSlot();
	ts.setMultiSlot(true);
}
{
        <MULTISLOT>
        t = <SYMBOL>
        { ts.setName(t.image); }//<slot-name>
        (
			TemplateAttribute(ts)
		)*
		{return ts;}
}

//<template-attribute> ::= <default-attribute> | <constraint-attribute>
void TemplateAttribute(TemplateSlot ts)       : { }
{
	<LBRACE>
	(	LOOKAHEAD(2)
	    DefaultAttribute(ts) 
	| 	DynamicAttribute(ts)
	|	ConstraintAttribute(ts)
	) 
	<RBRACE>
}

// Create a dummy node to have a list of attributes
Node Attributes():{/*@bgen(jjtree) Attributes */
  COOLAttributes jjtn000 = new COOLAttributes(this, JJTATTRIBUTES);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} 
{/*@bgen(jjtree) Attributes */
        try {
/*@egen*/ 
	(	LOOKAHEAD(3)
		Expression()
	)*/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//<default-attribute> ::= (default ?DERIVE | ?NONE | <expression>*) | (default-dynamic <expression>*)
void DefaultAttribute(TemplateSlot ts)       : { Node n;}
{
		<DEFAULT_ATR>
		(	
			<ATR_DERIVE> { ts.setDefaultDerive(); }
		|	<ATR_NONE> // { ts.setDefaultNone(); }
		|	n=Attributes() { ts.setStaticDefaultExpression(n); }
		)
}



void DynamicAttribute(TemplateSlot ts)       : { Node n;}
{
	<DYNAMIC_ATR> 
	(	
		n=Attributes() { ts.setDynamicDefaultExpression(n); }
	)
}

/* Fact Specification
<RHS-pattern> ::= <ordered-RHS-pattern> | <template-RHS-pattern>
<ordered-RHS-pattern> ::= (<symbol> <RHS-field>+)
<template-RHS-pattern> ::= (<deftemplate-name> <RHS-slot>*)
<RHS-slot> ::= <single-field-RHS-slot> | <multifield-RHS-slot>
<single-field-RHS-slot> ::= (<slot-name> <RHS-field>)
<multifield-RHS-slot> ::= (<slot-name> <RHS-field>*)
<RHS-field> ::= <variable> | <constant> | <function-call>
*/
void RHSPattern()       : { Token t; }
{ 
	"("
	t = <SYMBOL>
	{
		TemplateRHSPattern(t.image);
	//	else OrderedRHSPattern(t.image);
	// currently ordered RHS aren't implemented
	}
    ")" 
    
}

//<ordered-RHS-pattern> ::= (<symbol> <RHS-field>+)
Fact OrderedRHSPattern(String name) : {/*@bgen(jjtree) OrderedRHSPattern */
                                        COOLOrderedRHSPattern jjtn000 = new COOLOrderedRHSPattern(this, JJTORDEREDRHSPATTERN);
                                        boolean jjtc000 = true;
                                        jjtree.openNodeScope(jjtn000);
/*@egen*/ jjtn000.setName(name);  }
{/*@bgen(jjtree) OrderedRHSPattern */
    try {
/*@egen*/
    (  Expression() )*/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/	// CLIPS user guide says (assert (duck)) is legal, so does CLIPS interpreter!!
}

//<template-RHS-pattern> ::= (<deftemplate-name> <RHS-slot>*)
void TemplateRHSPattern(String name) :{/*@bgen(jjtree) TemplateRHSPattern */
                                         COOLTemplateRHSPattern jjtn000 = new COOLTemplateRHSPattern(this, JJTTEMPLATERHSPATTERN);
                                         boolean jjtc000 = true;
                                         jjtree.openNodeScope(jjtn000);
/*@egen*/  jjtn000.setName(name); }
{/*@bgen(jjtree) TemplateRHSPattern */
        try {
/*@egen*/
        (RHSSlot())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//<RHS-slot> ::= <single-field-RHS-slot> | <multifield-RHS-slot>
//<single-field-RHS-slot> ::= (<slot-name> <RHS-field>)
//<multifield-RHS-slot> ::= (<slot-name> <RHS-field>*)
void RHSSlot() : {/*@bgen(jjtree) RHSSlot */
                   COOLRHSSlot jjtn000 = new COOLRHSSlot(this, JJTRHSSLOT);
                   boolean jjtc000 = true;
                   jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) RHSSlot */
    try {
/*@egen*/
    "(" 
        t = <SYMBOL>
        { jjtn000.setName(t.image); }	// slot-name
        (Expression())*
    ")"/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

//<RHS-field> ::= <variable> | <constant> | <function-call>
// Same as expression
/*void RHSField() #void : {}
{
    Variable() | Constant() | FunctionCall()
}*/

/* Defrule Construct
<defrule-construct> 
	::= (defrule <rule-name> [<comment>] [<declaration>] <conditional-element>* => <action>*) 
<declaration> ::= (declare <rule-property>+)
<rule-property> ::= (salience <integer-expression>) | (auto-focus <boolean-symbol>)
<boolean-symbol> ::= TRUE | FALSE
<conditional-element> ::= <pattern-CE> | <assigned-pattern-CE> | <not-CE> | <and-CE> | <or-CE> |
	<logical-CE> | <test-CE> | <exists-CE> | <forall-CE>
<pattern-CE> ::= <ordered-pattern-CE> | <template-pattern-CE> | <object-pattern-CE>
<assigned-pattern-CE> ::= <single-field-variable> <- <pattern-CE>
<not-CE> ::= (not <conditional-element>)
<and-CE> ::= (and <conditional-element>+)
<or-CE> ::= (or <conditional-element>+)
<logical-CE> ::= (logical <conditional-element>+)
<test-CE> ::= (test <function-call>)
<exists-CE> ::= (exists <conditional-element>+)
<forall-CE> ::= (forall <conditional-element> <conditional-element>+)
<ordered-pattern-CE> ::= (<symbol> <constraint>*)
<template-pattern-CE> ::= (<deftemplate-name> <LHS-slot>*)
<object-pattern-CE> ::= (object <attribute-constraint>*)
<attribute-constraint> ::= (is-a <constraint>) | (name <constraint>) | (<slot-name> <constraint>*)
<LHS-slot> ::= <single-field-LHS-slot> | <multifield-LHS-slot>
<single-field-LHS-slot> ::= (<slot-name> <constraint>)
<multifield-LHS-slot> ::= (<slot-name> <constraint>*)
<constraint> ::= ? | $? | <connected-constraint>
<connected-constraint>::= <single-constraint> | <single-constraint> & <connected-constraint> |
	<single-constraint> | <connected-constraint>
<single-constraint> ::= <term> | ~<term>
<term> ::= <constant> | <single-field-variable> | <multifield-variable> | 
	:<function-call> | =<function-call>
*/
void DefruleConstruct() :{/*@bgen(jjtree) DefruleConstruct */
                           COOLDefruleConstruct jjtn000 = new COOLDefruleConstruct(this, JJTDEFRULECONSTRUCT);
                           boolean jjtc000 = true;
                           jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; Node n; Condition ce; }
{/*@bgen(jjtree) DefruleConstruct */
  try {
/*@egen*/
  ( <DEFRULE>
	t=<SYMBOL>
	{ jjtn000.setName(t.image); }//name
	[ t=<STRING> { jjtn000.setDocString(ParserUtils.getStringLiteral(t.image)); }	]
	( LOOKAHEAD(3)
		(
			Declaration(jjtn000)
			(
				ce=ConditionalElement()
								{  jjtn000.addCondition(ce); }
			)* 
		) |
		(
			(
				ce=ConditionalElement()
				{  jjtn000.addCondition(ce); }
			)* 
		)
	)
	<ARROW>
	n=ActionList()/*@bgen(jjtree)*/
                       {
                         jjtree.closeNodeScope(jjtn000, true);
                         jjtc000 = false;
                       }
/*@egen*/ { jjtn000.setRuleActions(n); }
  )/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

////////////////////////////
// Conditional elements should not produce nodes, 
// but conditions as in package org.jamocha.rule

// Create Dummy node to have fixed number of chlidren in Defrule
/*Node CEList():{} 
{ 
	(ConditionalElement())* {}
	{ return jjtThis; }
}
*/

// Create Dummy node to have fixed number of children in Defrule
Node ActionList():{/*@bgen(jjtree) ActionList */
  COOLActionList jjtn000 = new COOLActionList(this, JJTACTIONLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} 
{/*@bgen(jjtree) ActionList */
        try {
/*@egen*/ 
	(	LOOKAHEAD(2)
		Expression()
	)*/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/ 
	{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


/*
// Create Dummy node to have fixed number of children later
Node CEList2():{} 
{ 
	(ConditionalElement())+ 
	{ return jjtThis; }
}
*/

//<declaration> ::= (declare <rule-property>+)
void Declaration(COOLDefruleConstruct r)       : {}
{
    "("
        <DECLARE>
        (RuleProperty(r))+
    ")"
}

//<rule-property> ::= (salience <integer-expression>) | (auto-focus <boolean-symbol>)
void RuleProperty(COOLDefruleConstruct r)      : { Node n; }
{
    "(" (
		(  <SALIENCE>
			//todo:        <integer-expression>
			// Ory: Just use expression and check for it being an integer at runtime (it could use global variables)
			// Need to determine salience at runtime!!
			n=Expression() { r.setSalienceExpression(n); }
		)
		{ // Set node type to salience, 
		}
     | (	<AUTOFOCUS> 
		(	<TRUE> { r.setAutoFocus(true); }
		|	<FALSE> { r.setAutoFocus(false); } 
		)
	)) ")"
}

//<boolean-symbol> ::= TRUE | FALSE
void BooleanSymbol() : {/*@bgen(jjtree) BooleanSymbol */
                         COOLBooleanSymbol jjtn000 = new COOLBooleanSymbol(this, JJTBOOLEANSYMBOL);
                         boolean jjtc000 = true;
                         jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t;}
{/*@bgen(jjtree) BooleanSymbol */
    try {
/*@egen*/
    ( t=<TRUE> )/*@bgen(jjtree)*/
                 {
                   jjtree.closeNodeScope(jjtn000, true);
                   jjtc000 = false;
                 }
/*@egen*/ { jjtn000.setName(t.image); jjtn000.setToTrue();}
    |
    ( t=<FALSE> )/*@bgen(jjtree)*/
                  {
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                  }
/*@egen*/ { jjtn000.setName(t.image); jjtn000.setToFalse(); }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

//<conditional-element> ::= <pattern-CE> | <assigned-pattern-CE> | <not-CE> | <and-CE> | <or-CE> |
//                          <logical-CE> | <test-CE> | <exists-CE> | <forall-CE>
Condition ConditionalElement()       : { Condition ce; }
{
	"(" 
		(
			ce=PatternCE() 
		|	ce=AssignedPatternCE() 
		|	ce=BooleanFunction() 
		|	ce=LogicalCE() 
		|	ce=TestCE()
		|	ce=ExistsCE()
		|	ce=ForallCE()
		)
	")"
	{ return ce; }	
}

// Create and return conditions
Condition BooleanFunction()       : { Condition ce=null,child; }
{
	(	(	// Unary operators
			// No not condition and no condition negation ==> can't implement yet
			<NOT> {  }
			child=ConditionalElement() { /*not_ce.addNestedConditionElement(child);*/ }
		)
	|	(	// non-Unary operators
			(
				<AND> { ce=new AndCondition(); }
      			(
					child=ConditionalElement() { /*and_ce.addNestedConditionElement(child); */} 
				)+
			)
		|	(	// No Or condition and no condition negation ==> can't implement yet
				<OR> { ce=new AndCondition(); }
      			(
					child=ConditionalElement() { /*or_ce.addNestedConditionElement(child); */ } 
				)+
			) 
		)
	)	{ return ce; }
		
}

//<pattern-CE> ::= <ordered-pattern-CE> | <template-pattern-CE> | <object-pattern-CE>
// Create and return conditions
Condition  PatternCE()       : { Condition ce;}
{
	( LOOKAHEAD(2) 
		ce=OrderedPatternCE() 
	|	ce=TemplatePatternCE() 
	|	ce=ObjectPatternCE() 
	) { return ce; }
}

//<assigned-pattern-CE> ::= <single-field-variable> <- <pattern-CE>
// Create and return conditions 	--	NOT IMPLEMENTED!!
Condition AssignedPatternCE()       : {}
{
	(
		SingleVariable() 
		<ASSIGN>
		PatternCE()
    ) { return null; }
}


//<logical-CE> ::= (logical <conditional-element>+)
// Create and return conditions	--	NOT IMPLEMENTED!!
Condition LogicalCE()       : {}
{
    <LOGICAL> 
    (
		ConditionalElement()
    )+ 
    { return null; }
}

//<test-CE> ::= (test <function-call>)
// Create and return conditions (needs to initialize function 
// before execution, thus it gets a node
Condition TestCE() : {/*@bgen(jjtree) TestCE */
                       COOLTestCE jjtn000 = new COOLTestCE(this, JJTTESTCE);
                       boolean jjtc000 = true;
                       jjtree.openNodeScope(jjtn000);
/*@egen*/ TestCondition ce=new TestCondition(); Token t;}
{/*@bgen(jjtree) TestCE */
    try {
/*@egen*/
    ( 
		<TEST>
		t=<SYMBOL> { jjtn000.setName(t.image); jjtn000.setCondition(ce); }
	)/*@bgen(jjtree)*/
          {
            jjtree.closeNodeScope(jjtn000, true);
            jjtc000 = false;
          }
/*@egen*/ { return ce; }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

//<exists-CE> ::= (exists <conditional-element>+)
// Create and return conditions
Condition ExistsCE()       : 
{
	Condition child;
	ExistCondition ce=new ExistCondition();
}
{
    <EXISTS> 
    (
		child=ConditionalElement() { ce.addNestedConditionElement(child); }
    )+
    { return ce; }
}

//<forall-CE> ::= (forall <conditional-element> <conditional-element>+)
// Create and return conditions	--	NOT IMPLEMENTED!!
Condition ForallCE()       : {}
{
	(	<FORALL> 
	ConditionalElement() 
	(ConditionalElement())+
	)	{return null; }
}

// TODO finish 
//<ordered-pattern-CE> ::= (<symbol> <constraint>*)
Condition OrderedPatternCE()      : 
{ 	
	Token t; 
	Condition ce=null;	// NOT IMPLEMENTED
}
{
        (	
			t=<SYMBOL>
//			{ jjtThis.setName(t.image); }
			(Constraint())*
		)	{ return null; }
}

// TODO finish 
//<template-pattern-CE> ::= (<deftemplate-name> <LHS-slot>*)
Condition TemplatePatternCE()      : 
{ 
	Token t; 
	Condition ce=null;
}
{
		(
			t=<SYMBOL>
			{  }	//deftemplate-name
			(LHSSlot())*
        )	{ return null; }
}

//<object-pattern-CE> ::= (object <attribute-constraint>*)
// Create and return conditions (use exist condition!!)
Condition ObjectPatternCE()       : 
{ 
	ObjectCondition ce=new ObjectCondition();
	Constraint c;
}
{
        (	<OBJECT>
        (
			c=AttributeConstraint() 
			{ ce.addConstraint(c); }
		)*
		)	{ return ce; }
}

//<attribute-constraint> ::= (is-a <constraint>) | (name <constraint>) | (<slot-name> <constraint>*)
// Create and return conditions (Are these implemented??)
Constraint AttributeConstraint()        :
{ 
	Token t;
	Constraint c=null;
}
{
    "("
		(
			t=<SYMBOL> 
			{  
				// compare symbol to fixed strings, because 'name' can be 
				// used as slot name according to CLIPS user guide
			}
			(Constraint())* 
		)
    ")" { return c; }
}

// Functionally identical !?
//<single-field-LHS-slot> ::= (<slot-name> <constraint>)
//<multifield-LHS-slot> ::= (<slot-name> <constraint>*)
//<LHS-slot> ::= <single-field-LHS-slot> | <multifield-LHS-slot>
void LHSSlot()  : {/*@bgen(jjtree) LHSSlot */
                    COOLLHSSlot jjtn000 = new COOLLHSSlot(this, JJTLHSSLOT);
                    boolean jjtc000 = true;
                    jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) LHSSlot */
        try {
/*@egen*/
        t=<SYMBOL>
        { jjtn000.setName(t.image); }	//slot-name
		( LOOKAHEAD(2)
			Constraint()
		)*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/

}

//<constraint> ::= ? | $? | <connected-constraint>
void Constraint()       : {}
{
    SingleFieldWildcard() | MultiFieldWildcard() | ConnectedConstraint()
}

void SingleFieldWildcard() : {/*@bgen(jjtree) SingleFieldWildcard */
  COOLSingleFieldWildcard jjtn000 = new COOLSingleFieldWildcard(this, JJTSINGLEFIELDWILDCARD);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) SingleFieldWildcard */
                                  try {
/*@egen*/ <SFWILDCARD>/*@bgen(jjtree)*/
                                  } finally {
                                    if (jjtc000) {
                                      jjtree.closeNodeScope(jjtn000, true);
                                    }
                                  }
/*@egen*/ }
void MultiFieldWildcard() : {/*@bgen(jjtree) MultiFieldWildcard */
  COOLMultiFieldWildcard jjtn000 = new COOLMultiFieldWildcard(this, JJTMULTIFIELDWILDCARD);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) MultiFieldWildcard */
                                 try {
/*@egen*/ <MFWILDCARD>/*@bgen(jjtree)*/
                                 } finally {
                                   if (jjtc000) {
                                     jjtree.closeNodeScope(jjtn000, true);
                                   }
                                 }
/*@egen*/ }

//<connected-constraint>::= <single-constraint> | <single-constraint> & <connected-constraint> |
//	<single-constraint> | <connected-constraint>

// THIS IS WRONG: Ampersands and lines can be mixed!!
void ConnectedConstraint() : {/*@bgen(jjtree) ConnectedConstraint */
  COOLConnectedConstraint jjtn000 = new COOLConnectedConstraint(this, JJTCONNECTEDCONSTRAINT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ConnectedConstraint */
                try {
/*@egen*/
		Term() 
	[ 
		( <AMPERSAND> ConnectedConstraint() { jjtn000.setTypeAnd(); } )
	|	( <LINE> ConnectedConstraint() { jjtn000.setTypeOr(); } )
	]/*@bgen(jjtree)*/
                } catch (Throwable jjte000) {
                  if (jjtc000) {
                    jjtree.clearNodeScope(jjtn000);
                    jjtc000 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte000 instanceof RuntimeException) {
                    throw (RuntimeException)jjte000;
                  }
                  if (jjte000 instanceof ParseException) {
                    throw (ParseException)jjte000;
                  }
                  throw (Error)jjte000;
                } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                  }
                }
/*@egen*/
}

//<term> ::= <constant> | <single-field-variable> | <multifield-variable> | 
//	:<function-call> | =<function-call>
void Term()  : {/*@bgen(jjtree) Term */
  COOLTerm jjtn000 = new COOLTerm(this, JJTTERM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Term */
        try {
/*@egen*/
	[	<TILDE>	{ jjtn000.setNegate(true); }
	] 
    ( LOOKAHEAD(3)
		Constant()/*@bgen(jjtree)*/
                           {
                             jjtree.closeNodeScope(jjtn000, true);
                             jjtc000 = false;
                           }
/*@egen*/ { jjtn000.setType(COOLTerm.T_CONST); }
    |	SingleVariable()/*@bgen(jjtree)*/
                         {
                           jjtree.closeNodeScope(jjtn000, true);
                           jjtc000 = false;
                         }
/*@egen*/ { jjtn000.setType(COOLTerm.T_SINGLE); }
    |	MultiVariable()/*@bgen(jjtree)*/
                        {
                          jjtree.closeNodeScope(jjtn000, true);
                          jjtc000 = false;
                        }
/*@egen*/ { jjtn000.setType(COOLTerm.T_MULTI); }
    |	(<COLON> FunctionCall() )/*@bgen(jjtree)*/
                                  {
                                    jjtree.closeNodeScope(jjtn000, true);
                                    jjtc000 = false;
                                  }
/*@egen*/ { jjtn000.setType(COOLTerm.T_COLON); }
    |	(<EQUALS> FunctionCall() )/*@bgen(jjtree)*/
                                   {
                                     jjtree.closeNodeScope(jjtn000, true);
                                     jjtc000 = false;
                                   }
/*@egen*/ { jjtn000.setType(COOLTerm.T_EQ); } 
    )/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/* Defglobal Construct
<defglobal-construct> ::= (defglobal [<defmodule-name>] <global-assignment>*)
<global-assignment> ::= <global-variable> = <expression>
<global-variable> ::= ?*<symbol>*
*/

//<defglobal-construct> ::= (defglobal [<defmodule-name>] <global-assignment>*)
void DefglobalConstruct()  :{/*@bgen(jjtree) DefglobalConstruct */
                              COOLDefglobalConstruct jjtn000 = new COOLDefglobalConstruct(this, JJTDEFGLOBALCONSTRUCT);
                              boolean jjtc000 = true;
                              jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) DefglobalConstruct */
        try {
/*@egen*/
        <DEFGLOBAL>
        [ 
            t=<SYMBOL>
            { jjtn000.setName(t.image); }	//defmodule-name 
        ]
        (GlobalAssignment())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//<global-assignment> ::= <global-variable> = <expression>
void GlobalAssignment()  : {/*@bgen(jjtree) GlobalAssignment */
                             COOLGlobalAssignment jjtn000 = new COOLGlobalAssignment(this, JJTGLOBALASSIGNMENT);
                             boolean jjtc000 = true;
                             jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) GlobalAssignment */
        try {
/*@egen*/
	t=<GLOBALVAR>
	{ jjtn000.setName(t.image); }	// Needs to access variable to set, can not use variable node
    <EQUALS>
    Expression()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/* Deffunction Construct
<deffunction-construct> 
	::= (deffunction <name> [<comment>] (<regular-parameter>* [<wildcard-parameter>]) <action>*)
<regular-parameter> ::= <single-field-variable>
<wildcard-parameter> ::= <multifield-variable>
*/

//<deffunction-construct> 
//	::= (deffunction <name> [<comment>] (<regular-parameter>* [<wildcard-parameter>]) <action>*)
void DeffunctionConstruct()  :
{/*@bgen(jjtree) DeffunctionConstruct */
        COOLDeffunctionConstruct jjtn000 = new COOLDeffunctionConstruct(this, JJTDEFFUNCTIONCONSTRUCT);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/ 
	Token t; 
	Node n; 
	ArrayList list = new ArrayList();
}
{/*@bgen(jjtree) DeffunctionConstruct */
        try {
/*@egen*/
        <DEFFUNCTION>
        t=<SYMBOL>
        { jjtn000.setName(t.image); jjtn000.hasMultiVars(false);}//name
        [ t=<STRING> 
			{ jjtn000.setDocString(ParserUtils.getStringLiteral(t.image)); }
        ]
        "(" 
            (
				t=<SINGLEVAR>	{ list.add(t.image); }	// Should add strings or such to a java list here
			)*

			[ 
				t=<MULTIVAR> 
				{list.add(t.image); jjtn000.hasMultiVars(true);}
			] 
        ")"
        n=ActionList()/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
        { 
			jjtn000.SetFunctionParams(list);
			jjtn000.setFunctionActions(n); 
		}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


/* Ignored, produces multifield variable directly
//<wildcard-parameter> ::= <multifield-variable>
void WildcardParameter()  #void : {}
{
    <MULTIVAR>
}
*/

/* Defgeneric Construct
<defgeneric-construct> ::= (defgeneric <name> [<comment>])
*/
void DefgenericConstruct()  :{/*@bgen(jjtree) DefgenericConstruct */
                               COOLDefgenericConstruct jjtn000 = new COOLDefgenericConstruct(this, JJTDEFGENERICCONSTRUCT);
                               boolean jjtc000 = true;
                               jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) DefgenericConstruct */
        try {
/*@egen*/
        <DEFGENERIC>
        t=<SYMBOL>
        { jjtn000.setName(t.image); }	//name
        [ t=<STRING>
			{ jjtn000.setDocString(ParserUtils.getStringLiteral(t.image)); }
        ]/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/* Defmethod Construct
<defmethod-construct> ::= (defmethod <name> [<index>] [<comment>] (<parameter-restriction>*
	[<wildcard-parameter-restriction>]) <action>*)
<parameter-restriction> ::= <single-field-variable> | (<single-field-variable> <type>* [<query>])
<wildcard-parameter-restriction> ::= <multifield-variable> | (<multifield-variable> <type>* [<query>])
<type> ::= <class-name>
<query> ::= <global-variable> | <function-call>
*/

/////////////////////////////////////

void DefmethodConstruct() : {/*@bgen(jjtree) DefmethodConstruct */
                              COOLDefmethodConstruct jjtn000 = new COOLDefmethodConstruct(this, JJTDEFMETHODCONSTRUCT);
                              boolean jjtc000 = true;
                              jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) DefmethodConstruct */
        try {
/*@egen*/
	<DEFMETHOD>
	t = <SYMBOL>
	{ jjtn000.setName(t.image); }//name
	([
		t = <INTEGER>
		{ jjtn000.setIndex(t.image); }//method index (cf. clipsbasic programmers guide section 8.4.2)
	])
	([
		t = <STRING>
		{ jjtn000.setDocString(ParserUtils.getStringLiteral(t.image)); }//comment
	])
	(
		<LBRACE>
			(	LOOKAHEAD(2)
				ParameterRestriction()
			)*
			[ WildcardParameterRestriction() ]
		<RBRACE>
	)
	// This should be the nodes only subtree
    ActionList()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//<parameter-restriction> ::= <single-field-variable> | (<single-field-variable> <type>* [<query>])
void ParameterRestriction() : {/*@bgen(jjtree) ParameterRestriction */
  COOLParameterRestriction jjtn000 = new COOLParameterRestriction(this, JJTPARAMETERRESTRICTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ParameterRestriction */
        try {
/*@egen*/
	( LOOKAHEAD(2)
		(
			<SINGLEVAR>
		) |
		(
			<LBRACE>
				<SINGLEVAR> 
				(Type())* 
				[Query()]
			<RBRACE>
		)
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//<wildcard-parameter-restriction> ::= <multifield-variable> | (<multifield-variable> <type>* [<query>])
void WildcardParameterRestriction() : {/*@bgen(jjtree) WildcardParameterRestriction */
  COOLWildcardParameterRestriction jjtn000 = new COOLWildcardParameterRestriction(this, JJTWILDCARDPARAMETERRESTRICTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) WildcardParameterRestriction */
        try {
/*@egen*/
	( LOOKAHEAD(2)
		(
			<MULTIVAR>
		) |
		(
			<LBRACE>
				<MULTIVAR> 
				(Type())* 
				[Query()]
			<RBRACE>
		)
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//<type> ::= <class-name>
void Type() : {/*@bgen(jjtree) Type */
                COOLType jjtn000 = new COOLType(this, JJTTYPE);
                boolean jjtc000 = true;
                jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) Type */
        try {
/*@egen*/
	t = <SYMBOL>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ jjtn000.setName(t.image); }/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*///class-name
}

//<query> ::= <global-variable> | <function-call>
void Query() : {/*@bgen(jjtree) Query */
                 COOLQuery jjtn000 = new COOLQuery(this, JJTQUERY);
                 boolean jjtc000 = true;
                 jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) Query */
                try {
/*@egen*/
		GlobalVariable()
	|	FunctionCall()/*@bgen(jjtree)*/
                } catch (Throwable jjte000) {
                  if (jjtc000) {
                    jjtree.clearNodeScope(jjtn000);
                    jjtc000 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte000 instanceof RuntimeException) {
                    throw (RuntimeException)jjte000;
                  }
                  if (jjte000 instanceof ParseException) {
                    throw (ParseException)jjte000;
                  }
                  throw (Error)jjte000;
                } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                  }
                }
/*@egen*/
}

/*	Defclass Construct
<defclass-construct> ::= (defclass <name> [<comment>] (is-a <superclass-name>+)
	[<role>] [<pattern-match-role>] <slot>* <handler-documentation>*)
<role> ::= (role concrete | abstract)
<pattern-match-role> ::= (pattern-match reactive | non-reactive)
<slot> ::= (slot <name> <facet>*) | (single-slot <name> <facet>*) | (multislot <name> <facet>*)
<facet> ::= <default-facet> | <storage-facet> | <access-facet> | <propagation-facet> | 
	<source-facet> | <pattern-match-facet> | <visibility-facet> | 
	<create-accessor-facet> <override-message-facet> | <constraint-attribute>
<default-facet> ::= (default ?DERIVE | ?NONE | <expression>*) | (default-dynamic <expression>*)
<storage-facet> ::= (storage local | shared) 
<access-facet> ::= (access read-write | read-only | initialize-only) 
<propagation-facet> ::= (propagation inherit | no-inherit)
<source-facet> ::= (source exclusive | composite)
<pattern-match-facet> ::= (pattern-match reactive | non-reactive)
<visibility-facet> ::= (visibility private | public)
<create-accessor-facet> ::= (create-accessor ?NONE | read | write | read-write)
<override-message-facet> ::= (override-message ?DEFAULT | <message-name>)
<handler-documentation> ::= (message-handler <name> [<handler-type>])
<handler-type> ::= primary | around | before | after
*/
//<defclass-construct> ::= (defclass <name> [<comment>] (is-a <superclass-name>+)
//	[<role>] [<pattern-match-role>] <slot>* <handler-documentation>*)
void DefclassConstruct() : {/*@bgen(jjtree) DefclassConstruct */
                             COOLDefclassConstruct jjtn000 = new COOLDefclassConstruct(this, JJTDEFCLASSCONSTRUCT);
                             boolean jjtc000 = true;
                             jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) DefclassConstruct */
        try {
/*@egen*/
	<DEFCLASS>
	t = <SYMBOL>
	{ jjtn000.setName(t.image); }//name
	[
		t = <STRING>
		{ jjtn000.setDocString(ParserUtils.getStringLiteral(t.image)); }//comment
	]
	<LBRACE>
		<IS_A>
		(
			t = <SYMBOL>
		)+
	<RBRACE>
	[ LOOKAHEAD(2) Role(jjtn000) ]
	[ LOOKAHEAD(2) PatternMatchRole(jjtn000) ]
	( LOOKAHEAD(2) Slot() )*
	( LOOKAHEAD(2) HandlerDocumentation() )*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


// JUST SET ATTRIBUTE
//<role> ::= (role concrete | abstract)
void Role(COOLDefclassConstruct c)       : {}
{
	<LBRACE>
		<ROLE> 
		(	<CONCRETE> { c.setConcrete(); }
		|	<ABSTRACT> { c.setAbstract(); }
		)
	<RBRACE>
}

// JUST SET ATTRIBUTE
//<pattern-match-role> ::= (pattern-match reactive | non-reactive)
void PatternMatchRole(COOLDefclassConstruct c)       : {}
{
	<LBRACE>
		<PATTERN_MATCH> 
		(	<REACTIVE> { c.setReactive(); }
		|	<NON_REACTIVE> { c.setNonReactive(); }
		)
	<RBRACE>
}


// JUST SET RULE ATTRIBUTE?
//<slot> ::= (slot <name> <facet>*) | (single-slot <name> <facet>*) | (multislot <name> <facet>*)
TemplateSlot Slot()       : { Token t; TemplateSlot ts=new TemplateSlot();}
{
	<LBRACE>
		(
			<SLOT> { ts.setMultiSlot(false); }
		|	<SINGLE_SLOT> { ts.setMultiSlot(false); }
		|	<MULTISLOT> { ts.setMultiSlot(true); }
		)
		t = <SYMBOL>
		{ 
		 	ts.setName(t.image);
		}
		( Facet(ts) )*
	<RBRACE>
	{ return ts; }
}

//<facet> ::= <default-facet> | <storage-facet> | <access-facet> | <propagation-facet> | 
//	<source-facet> | <pattern-match-facet> | <visibility-facet> | 
//	<create-accessor-facet> <override-message-facet> | <constraint-attribute>
void Facet(TemplateSlot ts)       : {}
{
	<LBRACE> 			// facets all have brackets
		( LOOKAHEAD(2)
			DefaultFacet(ts)
		| 	StorageFacet(ts)
		|	AccessFacet(ts)
		|	PropagationFacet(ts)
		|	SourceFacet(ts)
		|	PatternMatchFacet(ts)
		|	VisibilityFacet(ts)
		|	CreateAccessorFacet(ts)
		|	OverrideMessageFacet(ts)
		|	ConstraintAttribute(ts)
		)
	<RBRACE>
}

//<default-facet> ::= (default ?DERIVE | ?NONE | <expression>*) | (default-dynamic <expression>*)
void DefaultFacet(TemplateSlot ts)       : { Node n; }
{
	( 	<DEFAULT_ATR>
		(	<ATR_DERIVE> { ts.setDefaultDerive(); }
		|	<ATR_NONE> // { ts.setDefaultNone(); }
		|   n=Attributes() { ts.setStaticDefaultExpression(n); }
		) 
	) 
	|	
	( 	
		<DYNAMIC_ATR> 
		n=Attributes() { ts.setDynamicDefaultExpression(n); }
	)
}


// JUST SET RULE ATTRIBUTE
//<storage-facet> ::= (storage local | shared)
void StorageFacet(TemplateSlot ts)        : {}
{
	<STORAGE> 
	(	<LOCAL>  			// { ts.setStorageLocal(true); }
	|	<SHARED> 			// { ts.setStorageLocal(false); }
	)
}
	

// JUST SET RULE ATTRIBUTE
//<access-facet> ::= (access read-write | read-only | initialize-only)
void AccessFacet(TemplateSlot ts)       : {}
{
	<ACCESS> 
	(	<READ_WRITE>		// { ts.setAccessReadWrite(); }
	|	<READ_ONLY>			// { ts.setAccessRead(); }
	|	<INITIALIZE_ONLY> 	// { ts.setAccessInitialize(); }
	)
}


// JUST SET ATTRIBUTE
//<propagation-facet> ::= (propagation inherit | no-inherit)
void PropagationFacet(TemplateSlot ts)       : {}
{
	<PROPAGATION> 
	(	<INHERIT> 			// { ts.setInherit(true); }
	| 	<NO_INHERIT> 		// { ts.setInherit(false); }
	)
}


// JUST SET ATTRIBUTE
//<source-facet> ::= (source exclusive | composite)
void SourceFacet(TemplateSlot ts)       : {}
{
	<SOURCE> <EXCLUSIVE> | <COMPOSITE>
}


// JUST SET ATTRIBUTE
//<pattern-match-facet> ::= (pattern-match reactive | non-reactive)
void PatternMatchFacet(TemplateSlot ts)        : {}
{
	<PATTERN_MATCH> 
	(	<REACTIVE> 				// { ts.setMatchReactive(true); }
	|	<NON_REACTIVE> 			// { ts.setMatchReactive(false); }
	)
}


// JUST SET RULE ATTRIBUTE
//<visibility-facet> ::= (visibility private | public)
void VisibilityFacet(TemplateSlot ts)       : {}
{
	<VISIBILITY> 
	(	<PRIVATE> 				// { ts.setPublic(false); }
	|	<PUBLIC> 				// { ts.setPublic(true); }
	)
}


// JUST SET RULE ATTRIBUTE
//<create-accessor-facet> ::= (create-accessor ?NONE | read | write | read-write)
void CreateAccessorFacet(TemplateSlot ts)       : {}
{
	<CREATE_ACCESSOR> 
	(	<ATR_NONE> 
	|	<READ> 
	|	<WRITE> 
	|	<READ_WRITE>
	)
}


// JUST SET RULE ATTRIBUTE
//<override-message-facet> ::= (override-message ?DEFAULT | <message-name>)
void OverrideMessageFacet(TemplateSlot ts)       : { Token t; }
{
	<OVERRIDE_MESSAGE> 
	(	<ATR_DEFAULT> 			// { ts.setMessageDefault(); }
	|	t = <STRING> 			// { ts.setMessageName(ParserUtils.getStringLiteral(t.image)); }
	)
}


//<handler-documentation> ::= (message-handler <name> [<handler-type>])
void HandlerDocumentation()       : { Token t; int i=-1; }
{
	(
		<MESSAGE_HANDLER>
		t = <SYMBOL>
		[ i=HandlerType() ]
	) 
	
}

// JUST RETURN TYPE
//<handler-type> ::= primary | around | before | after
int HandlerType()       : { int i=-1; }
{
	(	<PRIMARY>	{ i=0; }
	|	<AROUND>	{ i=1; }
	|	<BEFORE>	{ i=2; }
	|	<AFTER>		{ i=3; }
	)
	{ return i; }
}

/* 	Defmessage-handler Construct
	<defmessage-handler-construct> 
		::= (defmessage-handler <class-name> <message-name> [<handler-type>] 
			[<comment>] (<parameter>* [<wildcard-parameter>]) <action>*)
	<handler-type> ::= around | before | primary | after
	<parameter> ::= <single-field-variable>
	<wildcard-parameter> ::= <multifield-variable>
*/

//<defmessage-handler-construct> 
//	::= (defmessage-handler <class-name> <message-name> [<handler-type>] 
//		[<comment>] (<parameter>* [<wildcard-parameter>]) <action>*)
void DefmessageHandlerConstruct() : {/*@bgen(jjtree) DefmessageHandlerConstruct */
                                      COOLDefmessageHandlerConstruct jjtn000 = new COOLDefmessageHandlerConstruct(this, JJTDEFMESSAGEHANDLERCONSTRUCT);
                                      boolean jjtc000 = true;
                                      jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) DefmessageHandlerConstruct */
        try {
/*@egen*/
	<DEFMESSAGEHANDLER>
	t = <SYMBOL>
	{ jjtn000.setClassName(t.image); }//name
	t = <SYMBOL>
	{ jjtn000.setName(t.image); }//name 2
	[ HandlerType() ]
	[
		t = <STRING>
		{ jjtn000.setDocString(ParserUtils.getStringLiteral(t.image)); }//comment
	]
	<LBRACE>
		(SingleVariable())* //parameter
		[MultiVariable()]
	<RBRACE>
	(ActionList())/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/*	Definstances Construct
	<definstances-construct> ::= (definstances <definstances-name> [active] [<comment>] <instance-template>*)
	<instance-template> ::= (<instance-definition>)
	<instance-definition> ::= <instance-name-expression> of <class-name-expression> <slot-override>*
	<slot-override> ::= (<slot-name-expression> <expression>*)
*/

//<definstances-construct> ::= (definstances <definstances-name> [active] [<comment>] <instance-template>*)
void DefinstancesConstruct() : {/*@bgen(jjtree) DefinstancesConstruct */
                                 COOLDefinstancesConstruct jjtn000 = new COOLDefinstancesConstruct(this, JJTDEFINSTANCESCONSTRUCT);
                                 boolean jjtc000 = true;
                                 jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) DefinstancesConstruct */
        try {
/*@egen*/
	<DEFINSTANCES>
	t = <SYMBOL>
	{ jjtn000.setName(t.image); }//name
	[ <ACTIVE> ]
	[
		t = <STRING>
		{ jjtn000.setDocString(ParserUtils.getStringLiteral(t.image)); }//comment
	]
	(LOOKAHEAD(2) InstanceTemplate())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//<instance-template> ::= (<instance-definition>)
void InstanceTemplate()       : {}
{
	<LBRACE>
		InstanceDefinition()
	<RBRACE>
}

//<instance-definition> ::= <instance-name-expression> of <class-name-expression> <slot-override>*
void InstanceDefinition()       : { Token t; }
{
	// Should have two expressions returning the correct types, not symbols!!
	t = <SYMBOL>
//	{ jjtThis.setCLIPSName(t.image); }//instance-name
	<OF>
	t = <SYMBOL>
//	{ jjtThis.setCLIPSName2(t.image); }//class-name
	(SlotOverride())*
}

//<slot-override> ::= (<slot-name-expression> <expression>*)
void SlotOverride()       : { Token t; }
{
	<LBRACE>
	t = <SYMBOL>	// Should be an expression returning a slot name
//	{ jjtThis.setName(t.image); }//slot-name
	ActionList()
	<RBRACE>
}

/*	Defmodule Construct
	<defmodule-construct> ::= (defmodule <module-name> [<comment>] <port-specification>*)
	<port-specification> ::= (export <port-item>) | (import <module-name> <port-item>)
	<port-item> ::= ?ALL | ?NONE | <port-construct> ?ALL | 
		<port-construct> ?NONE | <port-construct> <construct-name>+
	<port-construct> ::= deftemplate_construct | defclass | defglobal | deffunction | defgeneric
*/

//<defmodule-construct> ::= (defmodule <module-name> [<comment>] <port-specification>*)
void DefmoduleConstruct() : {/*@bgen(jjtree) DefmoduleConstruct */
                              COOLDefmoduleConstruct jjtn000 = new COOLDefmoduleConstruct(this, JJTDEFMODULECONSTRUCT);
                              boolean jjtc000 = true;
                              jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) DefmoduleConstruct */
        try {
/*@egen*/
	<DEFMODULE>
	t = <SYMBOL>
	{ jjtn000.setName(t.image); }//name
	[
		t = <SYMBOL>
		{ jjtn000.setDocString(t.image); }//comment
	]
	(PortSpecification())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//<port-specification> ::= (export <port-item>) | (import <module-name> <port-item>)
void PortSpecification() : {/*@bgen(jjtree) PortSpecification */
                             COOLPortSpecification jjtn000 = new COOLPortSpecification(this, JJTPORTSPECIFICATION);
                             boolean jjtc000 = true;
                             jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) PortSpecification */
        try {
/*@egen*/
	<LBRACE>
	(
		<EXPORT>
		PortItem()
	) |
	(
		<IMPORT>
		t = <SYMBOL>
		{ jjtn000.setName(t.image); }//name
		PortItem()
	)
	<RBRACE>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//			(
//				t = <SYMBOL>
//				{ jjtThis.addCLIPSPortname(t.image); }
//			)+

//<port-item> ::= ?ALL | ?NONE | <port-construct> ?ALL | 
//	<port-construct> ?NONE | <port-construct> <construct-name>+
void PortItem() : {/*@bgen(jjtree) PortItem */
                    COOLPortItem jjtn000 = new COOLPortItem(this, JJTPORTITEM);
                    boolean jjtc000 = true;
                    jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) PortItem */
        try {
/*@egen*/
	(	<ATR_ALL> 
	| 	<ATR_NONE> 
	| 	( 
			PortConstruct() 
			(	<ATR_ALL> 
			|	<ATR_NONE> 
			|	(ConstructName())*
			)
		)
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ConstructName() : {/*@bgen(jjtree) ConstructName */
                         COOLConstructName jjtn000 = new COOLConstructName(this, JJTCONSTRUCTNAME);
                         boolean jjtc000 = true;
                         jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t;}
{/*@bgen(jjtree) ConstructName */
        try {
/*@egen*/
	(	t=<SYMBOL> 
	|	t=<INSTANCE> 
	)/*@bgen(jjtree)*/
          {
            jjtree.closeNodeScope(jjtn000, true);
            jjtc000 = false;
          }
/*@egen*/ { jjtn000.setName(t.image); }/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

//<port-construct> ::= deftemplate_construct | defclass | defglobal | deffunction | defgeneric
void PortConstruct()       : {}
{
	( LOOKAHEAD(2) <DEFTEMPLATE_CONSTRUCT> | <DEFCLASS> | <DEFGLOBAL> | <DEFFUNCTION> | <DEFGENERIC> )
}

/* constraint Attributes */

//<constraint-attribute> ::= <type-attribute> | <allowed-constant-attribute> | 
//	<range-attribute> | <cardinality-attribute>
void ConstraintAttribute(TemplateSlot ts)       : { }
{
	( LOOKAHEAD(2)
		TypeAttribute(ts)
	|	AllowedConstantAttribute()
	|	RangeAttribute()
	|	CardinalityAttribute()
	)
}

//<type-attribute> ::= (type <type-specification>)
void TypeAttribute(TemplateSlot ts)       : { }
{
	<TYPE> TypeSpecification(ts)
}

///////////////////
// Use EnumSets here

//<type-specification> ::= <allowed-type>+ | ?VARIABLE
void TypeSpecification(TemplateSlot ts)        : {}
{
	(AllowedType(ts))+ | <VARIABLE_TYPE>
}

//<allowed-type> ::= SYMBOL | STRING | LEXEME | INTEGER | FLOAT | NUMBER |
//	INSTANCE-NAME | INSTANCE-ADDRESS | INSTANCE | EXTERNAL-ADDRESS | FACT-ADDRESS | DATETIME
void AllowedType(TemplateSlot ts)        : {}
{
	(	<SYMBOL_TYPE> { ts.setValueType(JamochaType.IDENTIFIER); }
	|	<STRING_TYPE> { ts.setValueType(JamochaType.STRING); }
	|	<DATETIME_TYPE>	{ ts.setValueType(JamochaType.DATETIME); }
	|	<LEXEME_TYPE> { ts.setValueType(JamochaType.IDENTIFIER); }
	| 	<INTEGER_TYPE> { ts.setValueType(JamochaType.LONG); }
	| 	<FLOAT_TYPE> { ts.setValueType(JamochaType.DOUBLE); }
	|	<NUMBER_TYPE> { ts.setValueType(JamochaType.DOUBLE); }
	|	<INSTANCE_NAME_TYPE> { ts.setValueType(JamochaType.UNDEFINED); }
	| 	<INSTANCE_ADDRESS_TYPE> { ts.setValueType(JamochaType.UNDEFINED); }
	|	<INSTANCE_TYPE> { ts.setValueType(JamochaType.UNDEFINED); }
	|	<EXTERNAL_ADDRESS_TYPE> { ts.setValueType(JamochaType.UNDEFINED); }
	|	<FACT_ADDRESS_TYPE> { ts.setValueType(JamochaType.FACT_ID); }
	|   <DATETIME> { ts.setValueType(JamochaType.DATETIME); }
	)
}

// <allowed-constant-attribute> ::= (allowed-symbols <symbol-list>) | (allowed-strings <string-list>) |
//	(allowed-lexemes <lexeme-list> | (allowed-integers <integer-list>) | (allowed-floats <float-list>) |
//	(allowed-numbers <number-list>) | (allowed-instance-names <instance-list>) |
//	(allowed-classes <class-name-list>) | (allowed-values <value-list>)
void AllowedConstantAttribute()       : {}
{
	(
		<ALLOWED_SYMBOLS> SymbolList()		|
		<ALLOWED_STRINGS> StringList()		|
		<ALLOWED_LEXEMES> LexemeList()		|
		<ALLOWED_INTEGERS> IntegerList()	|
		<ALLOWED_FLOATS> FloatList()		|
		<ALLOWED_NUMBERS> NumberList()		|
		<ALLOWED_INSTANCES> InstanceList()	|
		<ALLOWED_CLASSES> ClassNameList()	|
		<ALLOWED_VALUES> ValueList()		
	)
}

//<symbol-list> ::= <symbol>+ | ?VARIABLE
void SymbolList()       : {}
{
	(<SYMBOL>)+ | <VARIABLE_TYPE>
}

//<string-list> ::= <string>+ | ?VARIABLE
void StringList()       : {}
{
	(<STRING>)+ | <VARIABLE_TYPE>
}

//<lexeme-list> ::= <lexeme>+ | ?VARIABLE
void LexemeList()       : {}
{
	(Lexeme())+ | <VARIABLE_TYPE>
}

//<integer-list> ::= <integer>+ | ?VARIABLE
void IntegerList()       : {}
{
	(<INTEGER>)+ | <VARIABLE_TYPE>
}

//<float-list> ::= <float>+ | ?VARIABLE
void FloatList()       : {}
{
	(<FLOAT>)+ | <VARIABLE_TYPE>
}

//<number-list> ::= <number>+ | ?VARIABLE
void NumberList()       : {}
{
	(Number())+ | <VARIABLE_TYPE>
}

//<instance-name-list> ::= <instance-name>+ | ?VARIABLE
void InstanceList()       : {}
{
	(<INSTANCE>)+ | <VARIABLE_TYPE>
}

//<class-name-list> ::= <class-name>+ | ?VARIABLE
void ClassNameList()       : { Token t; }
{
	( 
		t = <SYMBOL>
	)+ 
	|
	<VARIABLE_TYPE>
}

//<value-list> ::= <constant>+ | ?VARIABLE
void ValueList()       : {}
{
	(Constant())+ | <VARIABLE_TYPE>
}

//<range-attribute> ::= (range <range-specification> <range-specification>)
void RangeAttribute()       : {}
{
	<RANGE> RangeSpecification() RangeSpecification()
}

//<range-specification> ::= <number> | ?VARIABLE
void RangeSpecification()        : {}
{
	Number() | <VARIABLE_TYPE>
}

//<cardinality-attribute> ::= (cardinality <cardinality-specification> <cardinality-specification>)
void CardinalityAttribute()        : {}
{
	<CARDINALITY> CardinalitySpecification() CardinalitySpecification()
}

//<cardinality-specification> ::= <integer> | ?VARIABLE
void CardinalitySpecification()      : {}
{
	Integer() | <VARIABLE_TYPE>
}

