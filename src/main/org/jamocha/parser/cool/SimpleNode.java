/* Generated By:JJTree: Do not edit this line. SimpleNode.java */

package org.jamocha.parser.cool;

/** AST Node representing a Symbol.<br>
 *  This file is the only Node-Subclass that contains special (not jjtree generated) methods
 *  and attributes so the whole class tree can be produced only from COOL.jjt and this file.<br>
 *  <list>
 *	<li> The "name" attribute indicates the left hand side of a production of the CLIPS grammar.
 *	<li> The other attributes are set tu null if they are not defined needed and can be accessed by
 *		methods which have the prefix CLIPS. (This is only to keep the class structure simple and
 *		cover all needed functionality of a node in this class.) The names of the attributes correspond
 *		to the names used in the CLIPS grammar specifications and maybe can have different context.
 *	</list>
 *	@author jjTree
 *	@author Ory Chowaw-Liebman
 *	@author Ulrich Loup
 */
public class SimpleNode implements Node
{
	//ATTRIBUTES

	protected Node parent;
	protected Node[] children;
	protected int id;
	protected COOLParser parser;
	protected String name;

	//additional attributes needed by some nodes (standard-value = null)

	protected String CLIPSname, CLIPSname2, CLIPScomment, CLIPSindex;
	protected java.util.ArrayList<String> CLIPSclasslist, CLIPSportlist;

	//CONSTRUCTORS
	public SimpleNode(int id)
	{
		this.id = id;
		this.name = "";
		this.CLIPSname = null;
		this.CLIPSname2 = null;
		this.CLIPScomment = null;
		this.CLIPSindex = null;
		this.CLIPSclasslist = null;
		this.CLIPSportlist = null;
		this.CLIPSportlist = null;
	}

	public SimpleNode(COOLParser parser, int id)
	{
		this(id);
		this.parser = parser;
	}

	//SELECTORS

	/** Sets node name.
	 *@param name new node name
	 */
	public void setName(String name){ this.name = name; }

	/** Gets node name.
	 *@return node name
	 */
	public String getName() { return this.name; }
	
	public void jjtSetParent(Node parent) { this.parent = parent; }

	public Node jjtGetParent() { return this.parent; }

	//additional selectors/methods according to additional attributes
	
	/** Sets CLIPS name.
	 *@param CLIPSname new CLIPS name
	 */
	public void setCLIPSName(String CLIPSname){ this.CLIPSname = CLIPSname; }

	/** Gets CLIPS name of this node.
	 *@return CLIPS name
	 */
	public String getCLIPSName() { return this.CLIPSname; }
	
	/** Sets another CLIPS name (cf. defmessagehandler-construct).
	 *@param CLIPSname new CLIPS name
	 */
	public void setCLIPSName2(String CLIPSname){ this.CLIPSname2 = CLIPSname; }

	/** Gets second CLIPS name of this node.
	 *@return CLIPS name
	 */
	public String getCLIPSName2() { return this.CLIPSname2; }
	
	/** Sets Comment String
	 *@param CLIPScomment comment String information for that node
	 */
	public void setCLIPSComment(String CLIPScomment) { this.CLIPScomment = CLIPScomment; }

	/** Gets Comment String
	 *@return comment String information for that node (if set, otherwise null)
	 */
	public String getCLIPSComment() { return this.CLIPScomment; }

	/** Sets Method Index (cf. clipsbasic programmers guide section 8.4.2)
	 *@param CLIPSindex method index
	 */
	public void setCLIPSIndex(String CLIPSindex) { this.CLIPSindex = CLIPSindex; }

	/** Gets Method Index (cf. clipsbasic programmers guide section 8.4.2)
	 *@return method index
	 */
	public String getCLIPSIndex() { return this.CLIPSindex; }

	/** Adds a class name to the list (and instanciates the list if null yet)
	 *@param CLIPSclassname classname to be added
	 */
	public void addCLIPSClassname(String CLIPSclassname)
	{
		if(this.CLIPSclasslist == null)this.CLIPSclasslist = new java.util.ArrayList<String>();
		this.CLIPSclasslist.add(CLIPSclassname);
	}

	/** Returns class list as an array or null if empty.
	 *@return class list as an array or null if empty
	 */
	public String[] getCLIPSClasslist()
	{
		if(this.CLIPSclasslist == null) return null;
		String[] classarray = new String[this.CLIPSclasslist.size()];
		return this.CLIPSclasslist.toArray(classarray);
	}

	/** Adds a port name to the list (and instanciates the list if null yet).
	 *@param CLIPSportname portname to be added
	 */
	public void addCLIPSPortname(String CLIPSportname)
	{
		if(this.CLIPSportlist == null)this.CLIPSportlist = new java.util.ArrayList<String>();
		this.CLIPSportlist.add(CLIPSportname);
	}

	/** Returns port list as an array or null if empty.
	 *@return port list as an array or null if empty
	 */
	public String[] getCLIPSPortlist()
	{
		if(this.CLIPSportlist == null) return null;
		String[] portarray = new String[this.CLIPSportlist.size()];
		return this.CLIPSportlist.toArray(portarray);
	}
	
	//METHODS

	public void jjtOpen() {	}

	public void jjtClose() { }

	//Tree Management Functions

	public void jjtAddChild(Node n, int i)
	{
		if (children == null)
		{
			children = new Node[i + 1];
		}
		else if (i >= children.length)
		{
			Node c[] = new Node[i + 1];
			System.arraycopy(children, 0, c, 0, children.length);
			children = c;
		}
		children[i] = n;
	}

	public Node jjtGetChild(int i)
	{
		return children[i];
	}

	public int jjtGetNumChildren()
	{
		return (children == null) ? 0 : children.length;
	}

	/* You can override these two methods in subclasses of SimpleNode to
	   customize the way the node appears when the tree is dumped.  If
	   your output uses more than one line you should override
	   toString(String), otherwise overriding toString() is probably all
	   you need to do. */


	/** Returning a string representation for this node considering the node
	 * attributes that are not null.
	 *@return string representation for this node
	 */
	public String toString()
	{
		String out = "";
		if(this.CLIPSname != null) out += this.CLIPSname;
		if(this.CLIPSname2 != null) out += " "+this.CLIPSname2;
		if(this.CLIPScomment != null) out += ", "+this.CLIPScomment+"";
		if(this.CLIPSindex != null) out += ", index:"+this.CLIPSindex;
		if(this.CLIPSclasslist != null)
		{
			out += ", classlist:";
			for( String s : this.CLIPSclasslist ) out += s + " ";
			out = out.substring(0, out.length()-1);
		}
		if(this.CLIPSportlist != null)
		{
			out += ", portlist:";
			for( String s : this.CLIPSportlist ) out += s + " ";
			out = out.substring(0, out.length()-1);
		}
		return this.name+"< "+out+" >";
	}

	/** Returning the string representation defined by toString() extended by
	 * the specified prefix..
	 *@return string representation with prefix
	 */
	public String toString(String prefix)
	{
		return prefix + this.toString();
	}

	/* Override this method if you want to customize how the node dumps
	   out its children. */

	public void dump(String prefix)
	{
		System.out.println(toString(prefix));
		if (children != null)
		{
			for (int i = 0; i < children.length; ++i)
			{
				SimpleNode n = (SimpleNode)children[i];
				if (n != null)
				{
					n.dump(prefix + " ");
				}
			}
		}
	}

// 	/** Some nodes may have local data (e.g. classes and functions)
//	 */
//	public CLIPSData getLocal(String name)
//	{
//		if(this.parent == null) return null;
//		return parent.getLocal(name);
//	}
//
	/** Get this node's ID, as defined by jjTree.
	*/
	public int getId()
	{
		return this.id;
	}

//	/** Compare two syntax trees, returns true if both trees have the
//	 *	same structure build from the same nodes.
//	 */
//	public boolean compareTree(Node n)
//	{
//		int i;
//		// Do both nodes have the same id?
//		if( this.id != n.getId()) return false;
//		// Do both nodes have the same name? (All nodes have a name, it defaults to the empty string.
//		// This can differentiate numbers and such...)
//		if (this.getName()!=n.getName()) return false;
//		// Do both nodes have the same number of children?
//		if (this.jjtGetNumChildren()!=n.jjtGetNumChildren()) return false;
//		// Do both nodes have the same children?
//		for (i=0;i<this.jjtGetNumChildren();i++)
//			if (!this.jjtGetChild(i).compareTree(n.jjtGetChild(i))) return false;
//		// Yes, they do
//		return true;
//	}

	/** Traverses the syntax tree
	 */
	public void visit()
	{
		//for(int i = 0; i < this.jjtGetNumChildren(); i++)
		//	this.jjtGetChild(0).visit();
	}

//	public CLIPSData execute()
//	{
//		// Just execute first child. More comples Nodes have to override this anyways.
//		return jjtGetChild(0).execute();
//	}
}

