/* Generated By:JJTree&JavaCC: Do not edit this line. COOLParser.java */
package org.jamocha.parser.cool;

import java.util.ArrayList;

import org.jamocha.parser.JamochaType;
import org.jamocha.parser.Parser;
import org.jamocha.parser.ParserUtils;
import org.jamocha.parser.Expression;

import org.jamocha.rete.Rete;
import org.jamocha.rete.AbstractSlot;
import org.jamocha.rete.Fact;
import org.jamocha.rete.TemplateSlot;
import org.jamocha.rule.*;

/** This is the jjTree Parser Class. Use Start() to parse an expression or construct of the 
	COOL programming langauge, and retrieve the Syntax tree returned as a class of type Node
	(or SimpleNode, or COOLStart).
	The actual parser is generated by jjTree (which generates the node classes for rules, if
	they don't exist) and JavaCC. Most funcitonality lies within the nodes, which therefore
	most not be deleted!! Regenerated nodes will lack members used in the semanic actions!
	Some nodes only contain very little information (as ittle as half a bit :-), so these
	tules do not generate rules, but preferably set the information directly in a class as 
	close as posible to the engine.
	See also class SimpleNode for information on Syntax Trees.
	Note that productions like lists of floats or sets of types should directly produce
	engine compatible classes or java lists, EnumSets and such.
*/
public class COOLParser implements/*@bgen(jjtree)*/ COOLParserTreeConstants,Parser, COOLParserConstants {/*@bgen(jjtree)*/
  protected JJTCOOLParserState jjtree = new JJTCOOLParserState();
        public Expression nextExpression() throws ParseException {
                return Start();
        }

        public static void main(String args[])
        {
                boolean verbose = (args != null && args.length == 1 && "verbose".equals(args[0]));
                if(!verbose)System.out.println("Note: For verbose output type \"java Main verbose\".\n");
                System.out.print("COOL> ");
                Rete engine = new Rete();
                COOLParser p = new COOLParser(System.in);
                try
                {
                while (true)
                        {
                                COOLStart n = p.Start();
                                if (n==null) System.exit(0);
                                n.dump(" ");
                                System.out.println(n.getValue(engine).toString());
                        }
                }
                catch (Exception e)
                {
                        System.err.println("ERROR: " + e.getMessage());
                        if(verbose)e.printStackTrace();
                }
        }

/* TODO (From Clips Manual):
Data Types:
<file-name> ::= A symbol or string which is a valid file name (including path information)
	for the operating system under which CLIPS is running
<slot-name> ::= A valid deftemplate_construct slot name
<...-name> ::= A <symbol> where the ellipsis indicate what the symbol represents.
	For example, <rule-name> is a symbol which represents the name of a rule.
*/

/**********************************************
 * Cool Grammar Specs.
 */

/** Start rule is one construct at a time, Parser reads constructs into list.
	No need to create nodes for Start, Defcon and Funcon rule.*/
  final public COOLStart Start() throws ParseException {
                     /*@bgen(jjtree) Start */
  COOLStart jjtn000 = new COOLStart(this, JJTSTART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACE:
      case INTEGER:
      case FLOAT:
      case DATETIME:
      case STRING:
      case INSTANCE:
      case GLOBALVAR:
      case SINGLEVAR:
      case MULTIVAR:
      case SYMBOL:
        if (jj_2_1(2)) {
          Construct();
        } else {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case LBRACE:
          case INTEGER:
          case FLOAT:
          case DATETIME:
          case STRING:
          case INSTANCE:
          case GLOBALVAR:
          case SINGLEVAR:
          case MULTIVAR:
          case SYMBOL:
            Expression();
            break;
          default:
            jj_la1[0] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
            jjtree.closeNodeScope(jjtn000, true);
            jjtc000 = false;
            {if (true) return jjtn000;}
        break;
      case 0:
        jj_consume_token(0);
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                  {if (true) return null;}
        break;
      default:
        jj_la1[1] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       {if (true) throw (RuntimeException)jjte000;}
     }
     if (jjte000 instanceof ParseException) {
       {if (true) throw (ParseException)jjte000;}
     }
     {if (true) throw (Error)jjte000;}
    } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
    }
    throw new Error("Missing return statement in function");
  }

/*
<number> ::= <float> | <integer> 
<lexeme> ::= <symbol> | <string>
<constant> ::= <datetime> | <symbol> | <string> | <integer> | <float> | <instance-name>
*/
  final public Node Float() throws ParseException {
                /*@bgen(jjtree) Float */
                 COOLFloat jjtn000 = new COOLFloat(this, JJTFLOAT);
                 boolean jjtc000 = true;
                 jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(FLOAT);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                jjtn000.setName(t.image);
                {if (true) return jjtn000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public Node Integer() throws ParseException {
                  /*@bgen(jjtree) Integer */
                   COOLInteger jjtn000 = new COOLInteger(this, JJTINTEGER);
                   boolean jjtc000 = true;
                   jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(INTEGER);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                jjtn000.setName(t.image);
                {if (true) return jjtn000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public Node DateTime() throws ParseException {
                   /*@bgen(jjtree) DateTime */
                    COOLDateTime jjtn000 = new COOLDateTime(this, JJTDATETIME);
                    boolean jjtc000 = true;
                    jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(DATETIME);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                jjtn000.setName(t.image);
                {if (true) return jjtn000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public Node Number() throws ParseException {
                        Node n;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FLOAT:
      n = Float();
      break;
    case INTEGER:
      n = Integer();
      break;
    default:
      jj_la1[2] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
            {if (true) return n;}
    throw new Error("Missing return statement in function");
  }

  final public Node Symbol() throws ParseException {
                 /*@bgen(jjtree) Symbol */
                  COOLSymbol jjtn000 = new COOLSymbol(this, JJTSYMBOL);
                  boolean jjtc000 = true;
                  jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(SYMBOL);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                jjtn000.setName(t.image);
                {if (true) return jjtn000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public Node String() throws ParseException {
                 /*@bgen(jjtree) String */
                  COOLString jjtn000 = new COOLString(this, JJTSTRING);
                  boolean jjtc000 = true;
                  jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(STRING);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                jjtn000.setName(ParserUtils.getStringLiteral(t.image));
                {if (true) return jjtn000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public Node Lexeme() throws ParseException {
                        Node n;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case STRING:
      n = String();
      break;
    case SYMBOL:
      n = Symbol();
      break;
    default:
      jj_la1[3] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
            {if (true) return n;}
    throw new Error("Missing return statement in function");
  }

  final public Node Instance() throws ParseException {
                   /*@bgen(jjtree) Instance */
                    COOLInstance jjtn000 = new COOLInstance(this, JJTINSTANCE);
                    boolean jjtc000 = true;
                    jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(INSTANCE);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                jjtn000.setName(t.image);
                {if (true) return jjtn000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public Node Constant() throws ParseException {
                        Node n;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DATETIME:
      n = DateTime();
      break;
    case SYMBOL:
      n = Symbol();
      break;
    case STRING:
      n = String();
      break;
    case INTEGER:
      n = Integer();
      break;
    case FLOAT:
      n = Float();
      break;
    case INSTANCE:
      n = Instance();
      break;
    default:
      jj_la1[4] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
            {if (true) return n;}
    throw new Error("Missing return statement in function");
  }

  final public void Comment() throws ParseException {
    String();
  }

/*
<function-name> ::= Any symbol which corresponds to a system or user defined function, a
	deffunction name, or a defgeneric name
	( Ory: I understand this to be a <SYMBOL> token )
<file-name> ::= A symbol or string which is a valid file name (including path information)
	for the operating system under which CLIPS is running

<variable> ::= <single-field-variable> | <multifield-variable> | <global-variable>
<function-call> ::= (<function-name> <expression>*)
<expression> ::= <constant> | <variable> | <function-call>
<action> ::= <expression>
*/

// This is used exactly then when only the variables value is needed
  final public Node SingleVariable() throws ParseException {
                         /*@bgen(jjtree) SingleVariable */
                          COOLSingleVariable jjtn000 = new COOLSingleVariable(this, JJTSINGLEVARIABLE);
                          boolean jjtc000 = true;
                          jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(SINGLEVAR);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtn000.setName(t.image); {if (true) return jjtn000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

// This is used exactly then when only the variables value is needed
  final public Node GlobalVariable() throws ParseException {
                         /*@bgen(jjtree) GlobalVariable */
                          COOLGlobalVariable jjtn000 = new COOLGlobalVariable(this, JJTGLOBALVARIABLE);
                          boolean jjtc000 = true;
                          jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(GLOBALVAR);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtn000.setName(t.image); {if (true) return jjtn000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

// This is used exactly then when only the variables contents are needed
  final public Node MultiVariable() throws ParseException {
                        /*@bgen(jjtree) MultiVariable */
                         COOLMultiVariable jjtn000 = new COOLMultiVariable(this, JJTMULTIVARIABLE);
                         boolean jjtc000 = true;
                         jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(MULTIVAR);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtn000.setName(t.image); {if (true) return jjtn000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

// This is used exactly then when only the variables value is needed
  final public Node Variable() throws ParseException {
                          Node n;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SINGLEVAR:
      n = SingleVariable();
      break;
    case MULTIVAR:
      n = MultiVariable();
      break;
    case GLOBALVAR:
      n = GlobalVariable();
      break;
    default:
      jj_la1[5] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
            {if (true) return n;}
    throw new Error("Missing return statement in function");
  }

  final public Node FunctionCall() throws ParseException {
                              Token t; Node n;
    jj_consume_token(LBRACE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ASSERT:
      n = AssertFunc();
      break;
    case RETRACT:
      n = RetractFunc();
      break;
    case FIND_FACT_BY_FACT:
      n = FindFactByFactFunc();
      break;
    case IF:
      n = IfElseFunc();
      break;
    case SYMBOL:
      n = AnyFunction();
      break;
    default:
      jj_la1[6] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(RBRACE);
                {if (true) return n;}
    throw new Error("Missing return statement in function");
  }

  final public Node AnyFunction() throws ParseException {
                     /*@bgen(jjtree) AnyFunction */
                      COOLAnyFunction jjtn000 = new COOLAnyFunction(this, JJTANYFUNCTION);
                      boolean jjtc000 = true;
                      jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(SYMBOL);
          jjtn000.setName(t.image);
      label_1:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LBRACE:
        case INTEGER:
        case FLOAT:
        case DATETIME:
        case STRING:
        case INSTANCE:
        case GLOBALVAR:
        case SINGLEVAR:
        case MULTIVAR:
        case SYMBOL:
          ;
          break;
        default:
          jj_la1[7] = jj_gen;
          break label_1;
        }
        Expression();
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public Node Expression() throws ParseException {
                            Node n;
    if (jj_2_2(2)) {
      n = Constant();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case GLOBALVAR:
      case SINGLEVAR:
      case MULTIVAR:
        n = Variable();
        break;
      case LBRACE:
        n = FunctionCall();
        break;
      default:
        jj_la1[8] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
            {if (true) return n;}
    throw new Error("Missing return statement in function");
  }

////////////////////////////////////////////////////
// Special functions wich are defined by CLIPS to have
// a non-standart syntax (e.g. not all parameters are expressions)
  final public Node AssertFunc() throws ParseException {
                     /*@bgen(jjtree) AssertFunc */
  COOLAssertFunc jjtn000 = new COOLAssertFunc(this, JJTASSERTFUNC);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(ASSERT);
      label_2:
      while (true) {
        RHSPattern();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LBRACE:
          ;
          break;
        default:
          jj_la1[9] = jj_gen;
          break label_2;
        }
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

////////////////////////////////////////////////////
// Special functions wich are defined by CLIPS to have
// a non-standart syntax (e.g. not all parameters are expressions)
  final public Node FindFactByFactFunc() throws ParseException {
                             /*@bgen(jjtree) FindFactByFactFunc */
  COOLFindFactByFactFunc jjtn000 = new COOLFindFactByFactFunc(this, JJTFINDFACTBYFACTFUNC);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(FIND_FACT_BY_FACT);
      label_3:
      while (true) {
        RHSPattern();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LBRACE:
          ;
          break;
        default:
          jj_la1[10] = jj_gen;
          break label_3;
        }
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public Node RetractFunc() throws ParseException {
                      /*@bgen(jjtree) RetractFunc */
  COOLRetractFunc jjtn000 = new COOLRetractFunc(this, JJTRETRACTFUNC);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(RETRACT);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STAR:
        jj_consume_token(STAR);
        break;
      default:
        jj_la1[12] = jj_gen;
        label_4:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case LBRACE:
          case INTEGER:
          case FLOAT:
          case DATETIME:
          case STRING:
          case INSTANCE:
          case GLOBALVAR:
          case SINGLEVAR:
          case MULTIVAR:
          case SYMBOL:
            ;
            break;
          default:
            jj_la1[11] = jj_gen;
            break label_4;
          }
          Expression();
        }
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public Node IfElseFunc() throws ParseException {
                     /*@bgen(jjtree) IfElseFunc */
                      COOLIfElseFunc jjtn000 = new COOLIfElseFunc(this, JJTIFELSEFUNC);
                      boolean jjtc000 = true;
                      jjtree.openNodeScope(jjtn000);Node n;
    try {
      jj_consume_token(IF);
      Expression();
      jj_consume_token(THEN);
      n = ActionList();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ELSE:
        jj_consume_token(ELSE);
        n = ActionList();
        break;
      default:
        jj_la1[13] = jj_gen;
        ;
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public Node WhileFunc() throws ParseException {
                    /*@bgen(jjtree) WhileFunc */
  COOLWhileFunc jjtn000 = new COOLWhileFunc(this, JJTWHILEFUNC);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(WHILE);
      Expression();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DO:
        jj_consume_token(DO);
        break;
      default:
        jj_la1[14] = jj_gen;
        ;
      }
      ActionList();
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public Node LoopForCntFunc() throws ParseException {
                         /*@bgen(jjtree) LoopForCntFunc */
  COOLLoopForCntFunc jjtn000 = new COOLLoopForCntFunc(this, JJTLOOPFORCNTFUNC);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(LOOP_FOR_COUNT);
      jj_consume_token(LBRACE);
      SingleVariable();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACE:
      case INTEGER:
      case FLOAT:
      case DATETIME:
      case STRING:
      case INSTANCE:
      case GLOBALVAR:
      case SINGLEVAR:
      case MULTIVAR:
      case SYMBOL:
        Expression();

        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LBRACE:
        case INTEGER:
        case FLOAT:
        case DATETIME:
        case STRING:
        case INSTANCE:
        case GLOBALVAR:
        case SINGLEVAR:
        case MULTIVAR:
        case SYMBOL:
          Expression();

          break;
        default:
          jj_la1[15] = jj_gen;
          ;
        }
        break;
      default:
        jj_la1[16] = jj_gen;
        ;
      }
      jj_consume_token(RBRACE);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DO:
        jj_consume_token(DO);
        break;
      default:
        jj_la1[17] = jj_gen;
        ;
      }
      ActionList();
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public Node SwitchCaseFunc() throws ParseException {
                         /*@bgen(jjtree) SwitchCaseFunc */
  COOLSwitchCaseFunc jjtn000 = new COOLSwitchCaseFunc(this, JJTSWITCHCASEFUNC);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(SWITCH);
      Expression();
      label_5:
      while (true) {
        if (jj_2_3(2)) {
          ;
        } else {
          break label_5;
        }
        CaseStatement();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACE:
        jj_consume_token(LBRACE);
        jj_consume_token(DEFAULT_ATR);
        ActionList();
        break;
      default:
        jj_la1[18] = jj_gen;
        ;
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public void CaseStatement() throws ParseException {
                        /*@bgen(jjtree) CaseStatement */
  COOLCaseStatement jjtn000 = new COOLCaseStatement(this, JJTCASESTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(LBRACE);
      jj_consume_token(CASE);
      Expression();
      jj_consume_token(THEN);
      ActionList();
      jj_consume_token(RBRACE);
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

/** Dummy Defined in CLIPS programmers guide... */
  final public void Action() throws ParseException {
    Expression();
  }

/** Main Handler for Definition constructs.
	Note it contains the parantheses for the constructs
*/
  final public void Construct() throws ParseException {
    jj_consume_token(LBRACE);
    if (jj_2_4(2)) {
      DeffactsConstruct();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DEFTEMPLATE:
        DeftemplateConstruct();
        break;
      case DEFGLOBAL:
        DefglobalConstruct();
        break;
      case DEFRULE:
        DefruleConstruct();
        break;
      case DEFFUNCTION:
        DeffunctionConstruct();
        break;
      case DEFGENERIC:
        DefgenericConstruct();
        break;
      case DEFMETHOD:
        DefmethodConstruct();
        break;
      case DEFCLASS:
        DefclassConstruct();
        break;
      case DEFMESSAGEHANDLER:
        DefmessageHandlerConstruct();
        break;
      case DEFINSTANCES:
        DefinstancesConstruct();
        break;
      case DEFMODULE:
        DefmoduleConstruct();
        break;
      default:
        jj_la1[19] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    jj_consume_token(RBRACE);
  }

/* Deffacts construct: 
	<deffacts-construct> ::= (deffacts <deffacts-name> [<comment>] <RHS-pattern>*) 
*/
  final public void DeffactsConstruct() throws ParseException {
                           /*@bgen(jjtree) DeffactsConstruct */
                            COOLDeffactsConstruct jjtn000 = new COOLDeffactsConstruct(this, JJTDEFFACTSCONSTRUCT);
                            boolean jjtc000 = true;
                            jjtree.openNodeScope(jjtn000);Token t;
    try {
      jj_consume_token(DEFFACTS);
      t = jj_consume_token(SYMBOL);
        jjtn000.setName(t.image);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STRING:
        t = jj_consume_token(STRING);
                  jjtn000.setDocString(ParserUtils.getStringLiteral(t.image));
        break;
      default:
        jj_la1[20] = jj_gen;
        ;
      }
      label_6:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LBRACE:
          ;
          break;
        default:
          jj_la1[21] = jj_gen;
          break label_6;
        }
        RHSPattern();
      }
    } catch (Throwable jjte000) {
        if (jjtc000) {
          jjtree.clearNodeScope(jjtn000);
          jjtc000 = false;
        } else {
          jjtree.popNode();
        }
        if (jjte000 instanceof RuntimeException) {
          {if (true) throw (RuntimeException)jjte000;}
        }
        if (jjte000 instanceof ParseException) {
          {if (true) throw (ParseException)jjte000;}
        }
        {if (true) throw (Error)jjte000;}
    } finally {
        if (jjtc000) {
          jjtree.closeNodeScope(jjtn000, true);
        }
    }
  }

/* Deftemplate construct
<deftemplate-construct> ::= (deftemplate <deftemplate-name> [<comment>] <slot-definition>*)
<slot-definition> ::= <single-slot-definition> | <multislot-definition> 
<single-slot-definition> ::= (slot <slot-name> <template-attribute>*)
<multislot-definition> ::= (multislot <slot-name> <template-attribute>*)
<template-attribute> ::= <default-attribute> | <constraint-attribute>
<default-attribute> ::= (default ?DERIVE | ?NONE | <expression>*) | (default-dynamic <expression>*)
*/
  final public void DeftemplateConstruct() throws ParseException {
                              /*@bgen(jjtree) DeftemplateConstruct */
                               COOLDeftemplateConstruct jjtn000 = new COOLDeftemplateConstruct(this, JJTDEFTEMPLATECONSTRUCT);
                               boolean jjtc000 = true;
                               jjtree.openNodeScope(jjtn000);Token t; AbstractSlot s;
    try {
      jj_consume_token(DEFTEMPLATE);
      t = jj_consume_token(SYMBOL);
                        jjtn000.setName(t.image);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STRING:
        t = jj_consume_token(STRING);
                          jjtn000.setDocString(ParserUtils.getStringLiteral(t.image));
        break;
      default:
        jj_la1[22] = jj_gen;
        ;
      }
      label_7:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LBRACE:
          ;
          break;
        default:
          jj_la1[23] = jj_gen;
          break label_7;
        }
        s = SlotDefinition();
                                             jjtn000.addSlot(s);
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

//<slot-definition> ::= <single-slot-definition> | <multislot-definition>
  final public AbstractSlot SlotDefinition() throws ParseException {
                                        AbstractSlot ret;
    jj_consume_token(LBRACE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SLOT:
      ret = SingleSlotDefinition();
      break;
    case MULTISLOT:
      ret = MultislotDefinition();
      break;
    default:
      jj_la1[24] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(RBRACE);
          {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

//<single-slot-definition> ::= (slot <slot-name> <template-attribute>*)
  final public AbstractSlot SingleSlotDefinition() throws ParseException {
        Token t;
        TemplateSlot ts = new TemplateSlot();
    jj_consume_token(SLOT);
    t = jj_consume_token(SYMBOL);
                ts.setName(t.image); //<slot-name>

    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACE:
        ;
        break;
      default:
        jj_la1[25] = jj_gen;
        break label_8;
      }
      TemplateAttribute(ts);
    }
          {if (true) return ts;}
    throw new Error("Missing return statement in function");
  }

//<multislot-definition> ::= (multislot <slot-name> <template-attribute>*)
  final public AbstractSlot MultislotDefinition() throws ParseException {
        Token t;
        TemplateSlot ts = new TemplateSlot();
        ts.setMultiSlot(true);
    jj_consume_token(MULTISLOT);
    t = jj_consume_token(SYMBOL);
          ts.setName(t.image);
    label_9:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACE:
        ;
        break;
      default:
        jj_la1[26] = jj_gen;
        break label_9;
      }
      TemplateAttribute(ts);
    }
                 {if (true) return ts;}
    throw new Error("Missing return statement in function");
  }

//<template-attribute> ::= <default-attribute> | <constraint-attribute>
  final public void TemplateAttribute(TemplateSlot ts) throws ParseException {
    jj_consume_token(LBRACE);
    if (jj_2_5(2)) {
      DefaultAttribute(ts);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DYNAMIC_ATR:
        DynamicAttribute(ts);
        break;
      case TYPE:
      case ALLOWED_SYMBOLS:
      case ALLOWED_STRINGS:
      case ALLOWED_LEXEMES:
      case ALLOWED_INTEGERS:
      case ALLOWED_FLOATS:
      case ALLOWED_NUMBERS:
      case ALLOWED_INSTANCES:
      case ALLOWED_CLASSES:
      case ALLOWED_VALUES:
      case RANGE:
      case CARDINALITY:
        ConstraintAttribute(ts);
        break;
      default:
        jj_la1[27] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    jj_consume_token(RBRACE);
  }

// Create a dummy node to have a list of attributes
  final public Node Attributes() throws ParseException {
                   /*@bgen(jjtree) Attributes */
  COOLAttributes jjtn000 = new COOLAttributes(this, JJTATTRIBUTES);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      label_10:
      while (true) {
        if (jj_2_6(3)) {
          ;
        } else {
          break label_10;
        }
        Expression();
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

//<default-attribute> ::= (default ?DERIVE | ?NONE | <expression>*) | (default-dynamic <expression>*)
  final public void DefaultAttribute(TemplateSlot ts) throws ParseException {
                                                 Node n;
    jj_consume_token(DEFAULT_ATR);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ATR_DERIVE:
      jj_consume_token(ATR_DERIVE);
                                       ts.setDefaultDerive();
      break;
    case ATR_NONE:
      jj_consume_token(ATR_NONE);
      break;
    default:
      jj_la1[28] = jj_gen;
      n = Attributes();
                                         ts.setStaticDefaultExpression(n);
    }
  }

  final public void DynamicAttribute(TemplateSlot ts) throws ParseException {
                                                 Node n;
    jj_consume_token(DYNAMIC_ATR);
    n = Attributes();
                                 ts.setDynamicDefaultExpression(n);
  }

/* Fact Specification
<RHS-pattern> ::= <ordered-RHS-pattern> | <template-RHS-pattern>
<ordered-RHS-pattern> ::= (<symbol> <RHS-field>+)
<template-RHS-pattern> ::= (<deftemplate-name> <RHS-slot>*)
<RHS-slot> ::= <single-field-RHS-slot> | <multifield-RHS-slot>
<single-field-RHS-slot> ::= (<slot-name> <RHS-field>)
<multifield-RHS-slot> ::= (<slot-name> <RHS-field>*)
<RHS-field> ::= <variable> | <constant> | <function-call>
*/
  final public void RHSPattern() throws ParseException {
                            Token t;
    jj_consume_token(LBRACE);
    t = jj_consume_token(SYMBOL);
                TemplateRHSPattern(t.image);
        //	else OrderedRHSPattern(t.image);
        // currently ordered RHS aren't implemented

    jj_consume_token(RBRACE);
  }

//<ordered-RHS-pattern> ::= (<symbol> <RHS-field>+)
  final public Fact OrderedRHSPattern(String name) throws ParseException {
                                       /*@bgen(jjtree) OrderedRHSPattern */
                                        COOLOrderedRHSPattern jjtn000 = new COOLOrderedRHSPattern(this, JJTORDEREDRHSPATTERN);
                                        boolean jjtc000 = true;
                                        jjtree.openNodeScope(jjtn000);jjtn000.setName(name);
    try {
      label_11:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LBRACE:
        case INTEGER:
        case FLOAT:
        case DATETIME:
        case STRING:
        case INSTANCE:
        case GLOBALVAR:
        case SINGLEVAR:
        case MULTIVAR:
        case SYMBOL:
          ;
          break;
        default:
          jj_la1[29] = jj_gen;
          break label_11;
        }
        Expression();
      }
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

//<template-RHS-pattern> ::= (<deftemplate-name> <RHS-slot>*)
  final public void TemplateRHSPattern(String name) throws ParseException {
                                       /*@bgen(jjtree) TemplateRHSPattern */
                                         COOLTemplateRHSPattern jjtn000 = new COOLTemplateRHSPattern(this, JJTTEMPLATERHSPATTERN);
                                         boolean jjtc000 = true;
                                         jjtree.openNodeScope(jjtn000);jjtn000.setName(name);
    try {
      label_12:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LBRACE:
          ;
          break;
        default:
          jj_la1[30] = jj_gen;
          break label_12;
        }
        RHSSlot();
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

//<RHS-slot> ::= <single-field-RHS-slot> | <multifield-RHS-slot>
//<single-field-RHS-slot> ::= (<slot-name> <RHS-field>)
//<multifield-RHS-slot> ::= (<slot-name> <RHS-field>*)
  final public void RHSSlot() throws ParseException {
                  /*@bgen(jjtree) RHSSlot */
                   COOLRHSSlot jjtn000 = new COOLRHSSlot(this, JJTRHSSLOT);
                   boolean jjtc000 = true;
                   jjtree.openNodeScope(jjtn000);Token t;
    try {
      jj_consume_token(LBRACE);
      t = jj_consume_token(SYMBOL);
          jjtn000.setName(t.image);
      label_13:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LBRACE:
        case INTEGER:
        case FLOAT:
        case DATETIME:
        case STRING:
        case INSTANCE:
        case GLOBALVAR:
        case SINGLEVAR:
        case MULTIVAR:
        case SYMBOL:
          ;
          break;
        default:
          jj_la1[31] = jj_gen;
          break label_13;
        }
        Expression();
      }
      jj_consume_token(RBRACE);
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

//<RHS-field> ::= <variable> | <constant> | <function-call>
// Same as expression
/*void RHSField() #void : {}
{
    Variable() | Constant() | FunctionCall()
}*/

/* Defrule Construct
<defrule-construct> 
	::= (defrule <rule-name> [<comment>] [<declaration>] <conditional-element>* => <action>*) 
<declaration> ::= (declare <rule-property>+)
<rule-property> ::= (salience <integer-expression>) | (auto-focus <boolean-symbol>)
<boolean-symbol> ::= TRUE | FALSE
<conditional-element> ::= <pattern-CE> | <assigned-pattern-CE> | <not-CE> | <and-CE> | <or-CE> |
	<logical-CE> | <test-CE> | <exists-CE> | <forall-CE>
<pattern-CE> ::= <ordered-pattern-CE> | <template-pattern-CE> | <object-pattern-CE>
<assigned-pattern-CE> ::= <single-field-variable> <- <pattern-CE>
<not-CE> ::= (not <conditional-element>)
<and-CE> ::= (and <conditional-element>+)
<or-CE> ::= (or <conditional-element>+)
<logical-CE> ::= (logical <conditional-element>+)
<test-CE> ::= (test <function-call>)
<exists-CE> ::= (exists <conditional-element>+)
<forall-CE> ::= (forall <conditional-element> <conditional-element>+)
<ordered-pattern-CE> ::= (<symbol> <constraint>*)
<template-pattern-CE> ::= (<deftemplate-name> <LHS-slot>*)
<object-pattern-CE> ::= (object <attribute-constraint>*)
<attribute-constraint> ::= (is-a <constraint>) | (name <constraint>) | (<slot-name> <constraint>*)
<LHS-slot> ::= <single-field-LHS-slot> | <multifield-LHS-slot>
<single-field-LHS-slot> ::= (<slot-name> <constraint>)
<multifield-LHS-slot> ::= (<slot-name> <constraint>*)
<constraint> ::= ? | $? | <connected-constraint>
<connected-constraint>::= <single-constraint> | <single-constraint> & <connected-constraint> |
	<single-constraint> | <connected-constraint>
<single-constraint> ::= <term> | ~<term>
<term> ::= <constant> | <single-field-variable> | <multifield-variable> | 
	:<function-call> | =<function-call>
*/
  final public void DefruleConstruct() throws ParseException {
                          /*@bgen(jjtree) DefruleConstruct */
                           COOLDefruleConstruct jjtn000 = new COOLDefruleConstruct(this, JJTDEFRULECONSTRUCT);
                           boolean jjtc000 = true;
                           jjtree.openNodeScope(jjtn000);Token t; Node n; Condition ce;
    try {
      jj_consume_token(DEFRULE);
      t = jj_consume_token(SYMBOL);
          jjtn000.setName(t.image);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STRING:
        t = jj_consume_token(STRING);
                       jjtn000.setDocString(ParserUtils.getStringLiteral(t.image));
        break;
      default:
        jj_la1[32] = jj_gen;
        ;
      }
      if (jj_2_7(3)) {
        Declaration(jjtn000);
        label_14:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case LBRACE:
            ;
            break;
          default:
            jj_la1[33] = jj_gen;
            break label_14;
          }
          ce = ConditionalElement();
                                                                   jjtn000.addCondition(ce);
        }
      } else {
        label_15:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case LBRACE:
            ;
            break;
          default:
            jj_la1[34] = jj_gen;
            break label_15;
          }
          ce = ConditionalElement();
                                   jjtn000.addCondition(ce);
        }
      }
      jj_consume_token(ARROW);
      n = ActionList();
                         jjtree.closeNodeScope(jjtn000, true);
                         jjtc000 = false;
                         jjtn000.setRuleActions(n);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

////////////////////////////
// Conditional elements should not produce nodes, 
// but conditions as in package org.jamocha.rule

// Create Dummy node to have fixed number of chlidren in Defrule
/*Node CEList():{} 
{ 
	(ConditionalElement())* {}
	{ return jjtThis; }
}
*/

// Create Dummy node to have fixed number of children in Defrule
  final public Node ActionList() throws ParseException {
                   /*@bgen(jjtree) ActionList */
  COOLActionList jjtn000 = new COOLActionList(this, JJTACTIONLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      label_16:
      while (true) {
        if (jj_2_8(2)) {
          ;
        } else {
          break label_16;
        }
        Expression();
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

/*
// Create Dummy node to have fixed number of children later
Node CEList2():{} 
{ 
	(ConditionalElement())+ 
	{ return jjtThis; }
}
*/

//<declaration> ::= (declare <rule-property>+)
  final public void Declaration(COOLDefruleConstruct r) throws ParseException {
    jj_consume_token(LBRACE);
    jj_consume_token(DECLARE);
    label_17:
    while (true) {
      RuleProperty(r);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACE:
        ;
        break;
      default:
        jj_la1[35] = jj_gen;
        break label_17;
      }
    }
    jj_consume_token(RBRACE);
  }

//<rule-property> ::= (salience <integer-expression>) | (auto-focus <boolean-symbol>)
  final public void RuleProperty(COOLDefruleConstruct r) throws ParseException {
                                                   Node n;
    jj_consume_token(LBRACE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SALIENCE:
      jj_consume_token(SALIENCE);
      //todo:        <integer-expression>
                              // Ory: Just use expression and check for it being an integer at runtime (it could use global variables)
                              // Need to determine salience at runtime!!
                              n = Expression();
                                         r.setSalienceExpression(n);

      break;
    case AUTOFOCUS:
      jj_consume_token(AUTOFOCUS);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TRUE:
        jj_consume_token(TRUE);
                                 r.setAutoFocus(true);
        break;
      case FALSE:
        jj_consume_token(FALSE);
                                  r.setAutoFocus(false);
        break;
      default:
        jj_la1[36] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[37] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(RBRACE);
  }

//<boolean-symbol> ::= TRUE | FALSE
  final public void BooleanSymbol() throws ParseException {
                        /*@bgen(jjtree) BooleanSymbol */
                         COOLBooleanSymbol jjtn000 = new COOLBooleanSymbol(this, JJTBOOLEANSYMBOL);
                         boolean jjtc000 = true;
                         jjtree.openNodeScope(jjtn000);Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TRUE:
        t = jj_consume_token(TRUE);
                   jjtree.closeNodeScope(jjtn000, true);
                   jjtc000 = false;
                   jjtn000.setName(t.image); jjtn000.setToTrue();
        break;
      case FALSE:
        t = jj_consume_token(FALSE);
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                    jjtn000.setName(t.image); jjtn000.setToFalse();
        break;
      default:
        jj_la1[38] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

//<conditional-element> ::= <pattern-CE> | <assigned-pattern-CE> | <not-CE> | <and-CE> | <or-CE> |
//                          <logical-CE> | <test-CE> | <exists-CE> | <forall-CE>
  final public Condition ConditionalElement() throws ParseException {
                                         Condition ce;
    jj_consume_token(LBRACE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OBJECT:
    case SYMBOL:
      ce = PatternCE();
      break;
    case SINGLEVAR:
      ce = AssignedPatternCE();
      break;
    case NOT:
    case AND:
    case OR:
      ce = BooleanFunction();
      break;
    case LOGICAL:
      ce = LogicalCE();
      break;
    case TEST:
      ce = TestCE();
      break;
    case EXISTS:
      ce = ExistsCE();
      break;
    case FORALL:
      ce = ForallCE();
      break;
    default:
      jj_la1[39] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(RBRACE);
          {if (true) return ce;}
    throw new Error("Missing return statement in function");
  }

// Create and return conditions
  final public Condition BooleanFunction() throws ParseException {
                                      Condition ce=null,child;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NOT:
      jj_consume_token(NOT);

      child = ConditionalElement();

      break;
    case AND:
    case OR:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AND:
        jj_consume_token(AND);
                                        ce=new AndCondition();
        label_18:
        while (true) {
          child = ConditionalElement();

          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case LBRACE:
            ;
            break;
          default:
            jj_la1[40] = jj_gen;
            break label_18;
          }
        }
        break;
      case OR:
        jj_consume_token(OR);
                                       ce=new AndCondition();
        label_19:
        while (true) {
          child = ConditionalElement();

          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case LBRACE:
            ;
            break;
          default:
            jj_la1[41] = jj_gen;
            break label_19;
          }
        }
        break;
      default:
        jj_la1[42] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[43] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                  {if (true) return ce;}
    throw new Error("Missing return statement in function");
  }

//<pattern-CE> ::= <ordered-pattern-CE> | <template-pattern-CE> | <object-pattern-CE>
// Create and return conditions
  final public Condition PatternCE() throws ParseException {
                                 Condition ce;
    if (jj_2_9(2)) {
      ce = OrderedPatternCE();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SYMBOL:
        ce = TemplatePatternCE();
        break;
      case OBJECT:
        ce = ObjectPatternCE();
        break;
      default:
        jj_la1[44] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
            {if (true) return ce;}
    throw new Error("Missing return statement in function");
  }

//<assigned-pattern-CE> ::= <single-field-variable> <- <pattern-CE>
// Create and return conditions 	--	NOT IMPLEMENTED!!
  final public Condition AssignedPatternCE() throws ParseException {
    SingleVariable();
    jj_consume_token(ASSIGN);
    PatternCE();
        {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

//<logical-CE> ::= (logical <conditional-element>+)
// Create and return conditions	--	NOT IMPLEMENTED!!
  final public Condition LogicalCE() throws ParseException {
    jj_consume_token(LOGICAL);
    label_20:
    while (true) {
      ConditionalElement();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACE:
        ;
        break;
      default:
        jj_la1[45] = jj_gen;
        break label_20;
      }
    }
      {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

//<test-CE> ::= (test <function-call>)
// Create and return conditions (needs to initialize function 
// before execution, thus it gets a node
  final public Condition TestCE() throws ParseException {
                      /*@bgen(jjtree) TestCE */
                       COOLTestCE jjtn000 = new COOLTestCE(this, JJTTESTCE);
                       boolean jjtc000 = true;
                       jjtree.openNodeScope(jjtn000);TestCondition ce=new TestCondition(); Token t;
    try {
      jj_consume_token(TEST);
      t = jj_consume_token(SYMBOL);
                             jjtn000.setName(t.image); jjtn000.setCondition(ce);
            jjtree.closeNodeScope(jjtn000, true);
            jjtc000 = false;
            {if (true) return ce;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

//<exists-CE> ::= (exists <conditional-element>+)
// Create and return conditions
  final public Condition ExistsCE() throws ParseException {
        Condition child;
        ExistCondition ce=new ExistCondition();
    jj_consume_token(EXISTS);
    label_21:
    while (true) {
      child = ConditionalElement();
                                             ce.addNestedConditionElement(child);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACE:
        ;
        break;
      default:
        jj_la1[46] = jj_gen;
        break label_21;
      }
    }
      {if (true) return ce;}
    throw new Error("Missing return statement in function");
  }

//<forall-CE> ::= (forall <conditional-element> <conditional-element>+)
// Create and return conditions	--	NOT IMPLEMENTED!!
  final public Condition ForallCE() throws ParseException {
    jj_consume_token(FORALL);
    ConditionalElement();
    label_22:
    while (true) {
      ConditionalElement();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACE:
        ;
        break;
      default:
        jj_la1[47] = jj_gen;
        break label_22;
      }
    }
                 {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

// TODO finish 
//<ordered-pattern-CE> ::= (<symbol> <constraint>*)
  final public Condition OrderedPatternCE() throws ParseException {
        Token t;
        Condition ce=null;
    t = jj_consume_token(SYMBOL);
    label_23:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INTEGER:
      case FLOAT:
      case DATETIME:
      case STRING:
      case INSTANCE:
      case SFWILDCARD:
      case MFWILDCARD:
      case TILDE:
      case COLON:
      case EQUALS:
      case SINGLEVAR:
      case MULTIVAR:
      case SYMBOL:
        ;
        break;
      default:
        jj_la1[48] = jj_gen;
        break label_23;
      }
      Constraint();
    }
                          {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

// TODO finish 
//<template-pattern-CE> ::= (<deftemplate-name> <LHS-slot>*)
  final public Condition TemplatePatternCE() throws ParseException {
        Token t;
        Condition ce=null;
    t = jj_consume_token(SYMBOL);

    label_24:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SYMBOL:
        ;
        break;
      default:
        jj_la1[49] = jj_gen;
        break label_24;
      }
      LHSSlot();
    }
                  {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

//<object-pattern-CE> ::= (object <attribute-constraint>*)
// Create and return conditions (use exist condition!!)
  final public Condition ObjectPatternCE() throws ParseException {
        ObjectCondition ce=new ObjectCondition();
        Constraint c;
    jj_consume_token(OBJECT);
    label_25:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACE:
        ;
        break;
      default:
        jj_la1[50] = jj_gen;
        break label_25;
      }
      c = AttributeConstraint();
                          ce.addConstraint(c);
    }
                          {if (true) return ce;}
    throw new Error("Missing return statement in function");
  }

//<attribute-constraint> ::= (is-a <constraint>) | (name <constraint>) | (<slot-name> <constraint>*)
// Create and return conditions (Are these implemented??)
  final public Constraint AttributeConstraint() throws ParseException {
        Token t;
        Constraint c=null;
    jj_consume_token(LBRACE);
    t = jj_consume_token(SYMBOL);

    label_26:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INTEGER:
      case FLOAT:
      case DATETIME:
      case STRING:
      case INSTANCE:
      case SFWILDCARD:
      case MFWILDCARD:
      case TILDE:
      case COLON:
      case EQUALS:
      case SINGLEVAR:
      case MULTIVAR:
      case SYMBOL:
        ;
        break;
      default:
        jj_la1[51] = jj_gen;
        break label_26;
      }
      Constraint();
    }
    jj_consume_token(RBRACE);
          {if (true) return c;}
    throw new Error("Missing return statement in function");
  }

// Functionally identical !?
//<single-field-LHS-slot> ::= (<slot-name> <constraint>)
//<multifield-LHS-slot> ::= (<slot-name> <constraint>*)
//<LHS-slot> ::= <single-field-LHS-slot> | <multifield-LHS-slot>
  final public void LHSSlot() throws ParseException {
                   /*@bgen(jjtree) LHSSlot */
                    COOLLHSSlot jjtn000 = new COOLLHSSlot(this, JJTLHSSLOT);
                    boolean jjtc000 = true;
                    jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(SYMBOL);
          jjtn000.setName(t.image);
      label_27:
      while (true) {
        if (jj_2_10(2)) {
          ;
        } else {
          break label_27;
        }
        Constraint();
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

//<constraint> ::= ? | $? | <connected-constraint>
  final public void Constraint() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SFWILDCARD:
      SingleFieldWildcard();
      break;
    case MFWILDCARD:
      MultiFieldWildcard();
      break;
    case INTEGER:
    case FLOAT:
    case DATETIME:
    case STRING:
    case INSTANCE:
    case TILDE:
    case COLON:
    case EQUALS:
    case SINGLEVAR:
    case MULTIVAR:
    case SYMBOL:
      ConnectedConstraint();
      break;
    default:
      jj_la1[52] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void SingleFieldWildcard() throws ParseException {
                              /*@bgen(jjtree) SingleFieldWildcard */
  COOLSingleFieldWildcard jjtn000 = new COOLSingleFieldWildcard(this, JJTSINGLEFIELDWILDCARD);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(SFWILDCARD);
    } finally {
                                    if (jjtc000) {
                                      jjtree.closeNodeScope(jjtn000, true);
                                    }
    }
  }

  final public void MultiFieldWildcard() throws ParseException {
                             /*@bgen(jjtree) MultiFieldWildcard */
  COOLMultiFieldWildcard jjtn000 = new COOLMultiFieldWildcard(this, JJTMULTIFIELDWILDCARD);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(MFWILDCARD);
    } finally {
                                   if (jjtc000) {
                                     jjtree.closeNodeScope(jjtn000, true);
                                   }
    }
  }

//<connected-constraint>::= <single-constraint> | <single-constraint> & <connected-constraint> |
//	<single-constraint> | <connected-constraint>

// THIS IS WRONG: Ampersands and lines can be mixed!!
  final public void ConnectedConstraint() throws ParseException {
                              /*@bgen(jjtree) ConnectedConstraint */
  COOLConnectedConstraint jjtn000 = new COOLConnectedConstraint(this, JJTCONNECTEDCONSTRAINT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      Term();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AMPERSAND:
      case LINE:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case AMPERSAND:
          jj_consume_token(AMPERSAND);
          ConnectedConstraint();
                                                      jjtn000.setTypeAnd();
          break;
        case LINE:
          jj_consume_token(LINE);
          ConnectedConstraint();
                                                 jjtn000.setTypeOr();
          break;
        default:
          jj_la1[53] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[54] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
                  if (jjtc000) {
                    jjtree.clearNodeScope(jjtn000);
                    jjtc000 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte000 instanceof RuntimeException) {
                    {if (true) throw (RuntimeException)jjte000;}
                  }
                  if (jjte000 instanceof ParseException) {
                    {if (true) throw (ParseException)jjte000;}
                  }
                  {if (true) throw (Error)jjte000;}
    } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                  }
    }
  }

//<term> ::= <constant> | <single-field-variable> | <multifield-variable> | 
//	:<function-call> | =<function-call>
  final public void Term() throws ParseException {
                /*@bgen(jjtree) Term */
  COOLTerm jjtn000 = new COOLTerm(this, JJTTERM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TILDE:
        jj_consume_token(TILDE);
                          jjtn000.setNegate(true);
        break;
      default:
        jj_la1[55] = jj_gen;
        ;
      }
      if (jj_2_11(3)) {
        Constant();
                             jjtree.closeNodeScope(jjtn000, true);
                             jjtc000 = false;
                             jjtn000.setType(COOLTerm.T_CONST);
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SINGLEVAR:
          SingleVariable();
                           jjtree.closeNodeScope(jjtn000, true);
                           jjtc000 = false;
                           jjtn000.setType(COOLTerm.T_SINGLE);
          break;
        case MULTIVAR:
          MultiVariable();
                          jjtree.closeNodeScope(jjtn000, true);
                          jjtc000 = false;
                          jjtn000.setType(COOLTerm.T_MULTI);
          break;
        case COLON:
          jj_consume_token(COLON);
          FunctionCall();
                                    jjtree.closeNodeScope(jjtn000, true);
                                    jjtc000 = false;
                                    jjtn000.setType(COOLTerm.T_COLON);
          break;
        case EQUALS:
          jj_consume_token(EQUALS);
          FunctionCall();
                                     jjtree.closeNodeScope(jjtn000, true);
                                     jjtc000 = false;
                                     jjtn000.setType(COOLTerm.T_EQ);
          break;
        default:
          jj_la1[56] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

/* Defglobal Construct
<defglobal-construct> ::= (defglobal [<defmodule-name>] <global-assignment>*)
<global-assignment> ::= <global-variable> = <expression>
<global-variable> ::= ?*<symbol>*
*/

//<defglobal-construct> ::= (defglobal [<defmodule-name>] <global-assignment>*)
  final public void DefglobalConstruct() throws ParseException {
                             /*@bgen(jjtree) DefglobalConstruct */
                              COOLDefglobalConstruct jjtn000 = new COOLDefglobalConstruct(this, JJTDEFGLOBALCONSTRUCT);
                              boolean jjtc000 = true;
                              jjtree.openNodeScope(jjtn000);Token t;
    try {
      jj_consume_token(DEFGLOBAL);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SYMBOL:
        t = jj_consume_token(SYMBOL);
              jjtn000.setName(t.image);
        break;
      default:
        jj_la1[57] = jj_gen;
        ;
      }
      label_28:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case GLOBALVAR:
          ;
          break;
        default:
          jj_la1[58] = jj_gen;
          break label_28;
        }
        GlobalAssignment();
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

//<global-assignment> ::= <global-variable> = <expression>
  final public void GlobalAssignment() throws ParseException {
                            /*@bgen(jjtree) GlobalAssignment */
                             COOLGlobalAssignment jjtn000 = new COOLGlobalAssignment(this, JJTGLOBALASSIGNMENT);
                             boolean jjtc000 = true;
                             jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(GLOBALVAR);
          jjtn000.setName(t.image);
      jj_consume_token(EQUALS);
      Expression();
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

/* Deffunction Construct
<deffunction-construct> 
	::= (deffunction <name> [<comment>] (<regular-parameter>* [<wildcard-parameter>]) <action>*)
<regular-parameter> ::= <single-field-variable>
<wildcard-parameter> ::= <multifield-variable>
*/

//<deffunction-construct> 
//	::= (deffunction <name> [<comment>] (<regular-parameter>* [<wildcard-parameter>]) <action>*)
  final public void DeffunctionConstruct() throws ParseException {
 /*@bgen(jjtree) DeffunctionConstruct */
        COOLDeffunctionConstruct jjtn000 = new COOLDeffunctionConstruct(this, JJTDEFFUNCTIONCONSTRUCT);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);Token t;
        Node n;
        ArrayList list = new ArrayList();
    try {
      jj_consume_token(DEFFUNCTION);
      t = jj_consume_token(SYMBOL);
          jjtn000.setName(t.image); jjtn000.hasMultiVars(false);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STRING:
        t = jj_consume_token(STRING);
                          jjtn000.setDocString(ParserUtils.getStringLiteral(t.image));
        break;
      default:
        jj_la1[59] = jj_gen;
        ;
      }
      jj_consume_token(LBRACE);
      label_29:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SINGLEVAR:
          ;
          break;
        default:
          jj_la1[60] = jj_gen;
          break label_29;
        }
        t = jj_consume_token(SINGLEVAR);
                                                  list.add(t.image);
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MULTIVAR:
        t = jj_consume_token(MULTIVAR);
                                 list.add(t.image); jjtn000.hasMultiVars(true);
        break;
      default:
        jj_la1[61] = jj_gen;
        ;
      }
      jj_consume_token(RBRACE);
      n = ActionList();
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                        jjtn000.SetFunctionParams(list);
                        jjtn000.setFunctionActions(n);
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

/* Ignored, produces multifield variable directly
//<wildcard-parameter> ::= <multifield-variable>
void WildcardParameter()  #void : {}
{
    <MULTIVAR>
}
*/

/* Defgeneric Construct
<defgeneric-construct> ::= (defgeneric <name> [<comment>])
*/
  final public void DefgenericConstruct() throws ParseException {
                              /*@bgen(jjtree) DefgenericConstruct */
                               COOLDefgenericConstruct jjtn000 = new COOLDefgenericConstruct(this, JJTDEFGENERICCONSTRUCT);
                               boolean jjtc000 = true;
                               jjtree.openNodeScope(jjtn000);Token t;
    try {
      jj_consume_token(DEFGENERIC);
      t = jj_consume_token(SYMBOL);
          jjtn000.setName(t.image);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STRING:
        t = jj_consume_token(STRING);
                          jjtn000.setDocString(ParserUtils.getStringLiteral(t.image));
        break;
      default:
        jj_la1[62] = jj_gen;
        ;
      }
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

/* Defmethod Construct
<defmethod-construct> ::= (defmethod <name> [<index>] [<comment>] (<parameter-restriction>*
	[<wildcard-parameter-restriction>]) <action>*)
<parameter-restriction> ::= <single-field-variable> | (<single-field-variable> <type>* [<query>])
<wildcard-parameter-restriction> ::= <multifield-variable> | (<multifield-variable> <type>* [<query>])
<type> ::= <class-name>
<query> ::= <global-variable> | <function-call>
*/

/////////////////////////////////////
  final public void DefmethodConstruct() throws ParseException {
                             /*@bgen(jjtree) DefmethodConstruct */
                              COOLDefmethodConstruct jjtn000 = new COOLDefmethodConstruct(this, JJTDEFMETHODCONSTRUCT);
                              boolean jjtc000 = true;
                              jjtree.openNodeScope(jjtn000);Token t;
    try {
      jj_consume_token(DEFMETHOD);
      t = jj_consume_token(SYMBOL);
          jjtn000.setName(t.image);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INTEGER:
        t = jj_consume_token(INTEGER);
                  jjtn000.setIndex(t.image);
        break;
      default:
        jj_la1[63] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STRING:
        t = jj_consume_token(STRING);
                  jjtn000.setDocString(ParserUtils.getStringLiteral(t.image));
        break;
      default:
        jj_la1[64] = jj_gen;
        ;
      }
      jj_consume_token(LBRACE);
      label_30:
      while (true) {
        if (jj_2_12(2)) {
          ;
        } else {
          break label_30;
        }
        ParameterRestriction();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACE:
      case MULTIVAR:
        WildcardParameterRestriction();
        break;
      default:
        jj_la1[65] = jj_gen;
        ;
      }
      jj_consume_token(RBRACE);
      ActionList();
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

//<parameter-restriction> ::= <single-field-variable> | (<single-field-variable> <type>* [<query>])
  final public void ParameterRestriction() throws ParseException {
                               /*@bgen(jjtree) ParameterRestriction */
  COOLParameterRestriction jjtn000 = new COOLParameterRestriction(this, JJTPARAMETERRESTRICTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      if (jj_2_13(2)) {
        jj_consume_token(SINGLEVAR);
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LBRACE:
          jj_consume_token(LBRACE);
          jj_consume_token(SINGLEVAR);
          label_31:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case SYMBOL:
              ;
              break;
            default:
              jj_la1[66] = jj_gen;
              break label_31;
            }
            Type();
          }
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case LBRACE:
          case GLOBALVAR:
            Query();
            break;
          default:
            jj_la1[67] = jj_gen;
            ;
          }
          jj_consume_token(RBRACE);
          break;
        default:
          jj_la1[68] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

//<wildcard-parameter-restriction> ::= <multifield-variable> | (<multifield-variable> <type>* [<query>])
  final public void WildcardParameterRestriction() throws ParseException {
                                       /*@bgen(jjtree) WildcardParameterRestriction */
  COOLWildcardParameterRestriction jjtn000 = new COOLWildcardParameterRestriction(this, JJTWILDCARDPARAMETERRESTRICTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      if (jj_2_14(2)) {
        jj_consume_token(MULTIVAR);
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LBRACE:
          jj_consume_token(LBRACE);
          jj_consume_token(MULTIVAR);
          label_32:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case SYMBOL:
              ;
              break;
            default:
              jj_la1[69] = jj_gen;
              break label_32;
            }
            Type();
          }
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case LBRACE:
          case GLOBALVAR:
            Query();
            break;
          default:
            jj_la1[70] = jj_gen;
            ;
          }
          jj_consume_token(RBRACE);
          break;
        default:
          jj_la1[71] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

//<type> ::= <class-name>
  final public void Type() throws ParseException {
               /*@bgen(jjtree) Type */
                COOLType jjtn000 = new COOLType(this, JJTTYPE);
                boolean jjtc000 = true;
                jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(SYMBOL);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtn000.setName(t.image);
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

//<query> ::= <global-variable> | <function-call>
  final public void Query() throws ParseException {
                /*@bgen(jjtree) Query */
                 COOLQuery jjtn000 = new COOLQuery(this, JJTQUERY);
                 boolean jjtc000 = true;
                 jjtree.openNodeScope(jjtn000);Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case GLOBALVAR:
        GlobalVariable();
        break;
      case LBRACE:
        FunctionCall();
        break;
      default:
        jj_la1[72] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
                  if (jjtc000) {
                    jjtree.clearNodeScope(jjtn000);
                    jjtc000 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte000 instanceof RuntimeException) {
                    {if (true) throw (RuntimeException)jjte000;}
                  }
                  if (jjte000 instanceof ParseException) {
                    {if (true) throw (ParseException)jjte000;}
                  }
                  {if (true) throw (Error)jjte000;}
    } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                  }
    }
  }

/*	Defclass Construct
<defclass-construct> ::= (defclass <name> [<comment>] (is-a <superclass-name>+)
	[<role>] [<pattern-match-role>] <slot>* <handler-documentation>*)
<role> ::= (role concrete | abstract)
<pattern-match-role> ::= (pattern-match reactive | non-reactive)
<slot> ::= (slot <name> <facet>*) | (single-slot <name> <facet>*) | (multislot <name> <facet>*)
<facet> ::= <default-facet> | <storage-facet> | <access-facet> | <propagation-facet> | 
	<source-facet> | <pattern-match-facet> | <visibility-facet> | 
	<create-accessor-facet> <override-message-facet> | <constraint-attribute>
<default-facet> ::= (default ?DERIVE | ?NONE | <expression>*) | (default-dynamic <expression>*)
<storage-facet> ::= (storage local | shared) 
<access-facet> ::= (access read-write | read-only | initialize-only) 
<propagation-facet> ::= (propagation inherit | no-inherit)
<source-facet> ::= (source exclusive | composite)
<pattern-match-facet> ::= (pattern-match reactive | non-reactive)
<visibility-facet> ::= (visibility private | public)
<create-accessor-facet> ::= (create-accessor ?NONE | read | write | read-write)
<override-message-facet> ::= (override-message ?DEFAULT | <message-name>)
<handler-documentation> ::= (message-handler <name> [<handler-type>])
<handler-type> ::= primary | around | before | after
*/
//<defclass-construct> ::= (defclass <name> [<comment>] (is-a <superclass-name>+)
//	[<role>] [<pattern-match-role>] <slot>* <handler-documentation>*)
  final public void DefclassConstruct() throws ParseException {
                            /*@bgen(jjtree) DefclassConstruct */
                             COOLDefclassConstruct jjtn000 = new COOLDefclassConstruct(this, JJTDEFCLASSCONSTRUCT);
                             boolean jjtc000 = true;
                             jjtree.openNodeScope(jjtn000);Token t;
    try {
      jj_consume_token(DEFCLASS);
      t = jj_consume_token(SYMBOL);
          jjtn000.setName(t.image);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STRING:
        t = jj_consume_token(STRING);
                  jjtn000.setDocString(ParserUtils.getStringLiteral(t.image));
        break;
      default:
        jj_la1[73] = jj_gen;
        ;
      }
      jj_consume_token(LBRACE);
      jj_consume_token(IS_A);
      label_33:
      while (true) {
        t = jj_consume_token(SYMBOL);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SYMBOL:
          ;
          break;
        default:
          jj_la1[74] = jj_gen;
          break label_33;
        }
      }
      jj_consume_token(RBRACE);
      if (jj_2_15(2)) {
        Role(jjtn000);
      } else {
        ;
      }
      if (jj_2_16(2)) {
        PatternMatchRole(jjtn000);
      } else {
        ;
      }
      label_34:
      while (true) {
        if (jj_2_17(2)) {
          ;
        } else {
          break label_34;
        }
        Slot();
      }
      label_35:
      while (true) {
        if (jj_2_18(2)) {
          ;
        } else {
          break label_35;
        }
        HandlerDocumentation();
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

// JUST SET ATTRIBUTE
//<role> ::= (role concrete | abstract)
  final public void Role(COOLDefclassConstruct c) throws ParseException {
    jj_consume_token(LBRACE);
    jj_consume_token(ROLE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CONCRETE:
      jj_consume_token(CONCRETE);
                                     c.setConcrete();
      break;
    case ABSTRACT:
      jj_consume_token(ABSTRACT);
                                     c.setAbstract();
      break;
    default:
      jj_la1[75] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(RBRACE);
  }

// JUST SET ATTRIBUTE
//<pattern-match-role> ::= (pattern-match reactive | non-reactive)
  final public void PatternMatchRole(COOLDefclassConstruct c) throws ParseException {
    jj_consume_token(LBRACE);
    jj_consume_token(PATTERN_MATCH);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case REACTIVE:
      jj_consume_token(REACTIVE);
                                     c.setReactive();
      break;
    case NON_REACTIVE:
      jj_consume_token(NON_REACTIVE);
                                         c.setNonReactive();
      break;
    default:
      jj_la1[76] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(RBRACE);
  }

// JUST SET RULE ATTRIBUTE?
//<slot> ::= (slot <name> <facet>*) | (single-slot <name> <facet>*) | (multislot <name> <facet>*)
  final public TemplateSlot Slot() throws ParseException {
                              Token t; TemplateSlot ts=new TemplateSlot();
    jj_consume_token(LBRACE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SLOT:
      jj_consume_token(SLOT);
                                 ts.setMultiSlot(false);
      break;
    case SINGLE_SLOT:
      jj_consume_token(SINGLE_SLOT);
                                        ts.setMultiSlot(false);
      break;
    case MULTISLOT:
      jj_consume_token(MULTISLOT);
                                      ts.setMultiSlot(true);
      break;
    default:
      jj_la1[77] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    t = jj_consume_token(SYMBOL);
                        ts.setName(t.image);
    label_36:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACE:
        ;
        break;
      default:
        jj_la1[78] = jj_gen;
        break label_36;
      }
      Facet(ts);
    }
    jj_consume_token(RBRACE);
          {if (true) return ts;}
    throw new Error("Missing return statement in function");
  }

//<facet> ::= <default-facet> | <storage-facet> | <access-facet> | <propagation-facet> | 
//	<source-facet> | <pattern-match-facet> | <visibility-facet> | 
//	<create-accessor-facet> <override-message-facet> | <constraint-attribute>
  final public void Facet(TemplateSlot ts) throws ParseException {
    jj_consume_token(LBRACE);
    if (jj_2_19(2)) {
      DefaultFacet(ts);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STORAGE:
        StorageFacet(ts);
        break;
      case ACCESS:
        AccessFacet(ts);
        break;
      case PROPAGATION:
        PropagationFacet(ts);
        break;
      case SOURCE:
      case COMPOSITE:
        SourceFacet(ts);
        break;
      case PATTERN_MATCH:
        PatternMatchFacet(ts);
        break;
      case VISIBILITY:
        VisibilityFacet(ts);
        break;
      case CREATE_ACCESSOR:
        CreateAccessorFacet(ts);
        break;
      case OVERRIDE_MESSAGE:
        OverrideMessageFacet(ts);
        break;
      case TYPE:
      case ALLOWED_SYMBOLS:
      case ALLOWED_STRINGS:
      case ALLOWED_LEXEMES:
      case ALLOWED_INTEGERS:
      case ALLOWED_FLOATS:
      case ALLOWED_NUMBERS:
      case ALLOWED_INSTANCES:
      case ALLOWED_CLASSES:
      case ALLOWED_VALUES:
      case RANGE:
      case CARDINALITY:
        ConstraintAttribute(ts);
        break;
      default:
        jj_la1[79] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    jj_consume_token(RBRACE);
  }

//<default-facet> ::= (default ?DERIVE | ?NONE | <expression>*) | (default-dynamic <expression>*)
  final public void DefaultFacet(TemplateSlot ts) throws ParseException {
                                             Node n;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DEFAULT_ATR:
      jj_consume_token(DEFAULT_ATR);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ATR_DERIVE:
        jj_consume_token(ATR_DERIVE);
                                       ts.setDefaultDerive();
        break;
      case ATR_NONE:
        jj_consume_token(ATR_NONE);
        break;
      default:
        jj_la1[80] = jj_gen;
        n = Attributes();
                                     ts.setStaticDefaultExpression(n);
      }
      break;
    case DYNAMIC_ATR:
      jj_consume_token(DYNAMIC_ATR);
      n = Attributes();
                                 ts.setDynamicDefaultExpression(n);
      break;
    default:
      jj_la1[81] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

// JUST SET RULE ATTRIBUTE
//<storage-facet> ::= (storage local | shared)
  final public void StorageFacet(TemplateSlot ts) throws ParseException {
    jj_consume_token(STORAGE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LOCAL:
      jj_consume_token(LOCAL);
      break;
    case SHARED:
      jj_consume_token(SHARED);
      break;
    default:
      jj_la1[82] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

// JUST SET RULE ATTRIBUTE
//<access-facet> ::= (access read-write | read-only | initialize-only)
  final public void AccessFacet(TemplateSlot ts) throws ParseException {
    jj_consume_token(ACCESS);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case READ_WRITE:
      jj_consume_token(READ_WRITE);
      break;
    case READ_ONLY:
      jj_consume_token(READ_ONLY);
      break;
    case INITIALIZE_ONLY:
      jj_consume_token(INITIALIZE_ONLY);
      break;
    default:
      jj_la1[83] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

// JUST SET ATTRIBUTE
//<propagation-facet> ::= (propagation inherit | no-inherit)
  final public void PropagationFacet(TemplateSlot ts) throws ParseException {
    jj_consume_token(PROPAGATION);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INHERIT:
      jj_consume_token(INHERIT);
      break;
    case NO_INHERIT:
      jj_consume_token(NO_INHERIT);
      break;
    default:
      jj_la1[84] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

// JUST SET ATTRIBUTE
//<source-facet> ::= (source exclusive | composite)
  final public void SourceFacet(TemplateSlot ts) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SOURCE:
      jj_consume_token(SOURCE);
      jj_consume_token(EXCLUSIVE);
      break;
    case COMPOSITE:
      jj_consume_token(COMPOSITE);
      break;
    default:
      jj_la1[85] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

// JUST SET ATTRIBUTE
//<pattern-match-facet> ::= (pattern-match reactive | non-reactive)
  final public void PatternMatchFacet(TemplateSlot ts) throws ParseException {
    jj_consume_token(PATTERN_MATCH);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case REACTIVE:
      jj_consume_token(REACTIVE);
      break;
    case NON_REACTIVE:
      jj_consume_token(NON_REACTIVE);
      break;
    default:
      jj_la1[86] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

// JUST SET RULE ATTRIBUTE
//<visibility-facet> ::= (visibility private | public)
  final public void VisibilityFacet(TemplateSlot ts) throws ParseException {
    jj_consume_token(VISIBILITY);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PRIVATE:
      jj_consume_token(PRIVATE);
      break;
    case PUBLIC:
      jj_consume_token(PUBLIC);
      break;
    default:
      jj_la1[87] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

// JUST SET RULE ATTRIBUTE
//<create-accessor-facet> ::= (create-accessor ?NONE | read | write | read-write)
  final public void CreateAccessorFacet(TemplateSlot ts) throws ParseException {
    jj_consume_token(CREATE_ACCESSOR);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ATR_NONE:
      jj_consume_token(ATR_NONE);
      break;
    case READ:
      jj_consume_token(READ);
      break;
    case WRITE:
      jj_consume_token(WRITE);
      break;
    case READ_WRITE:
      jj_consume_token(READ_WRITE);
      break;
    default:
      jj_la1[88] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

// JUST SET RULE ATTRIBUTE
//<override-message-facet> ::= (override-message ?DEFAULT | <message-name>)
  final public void OverrideMessageFacet(TemplateSlot ts) throws ParseException {
                                                     Token t;
    jj_consume_token(OVERRIDE_MESSAGE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ATR_DEFAULT:
      jj_consume_token(ATR_DEFAULT);
      break;
    case STRING:
      t = jj_consume_token(STRING);
      break;
    default:
      jj_la1[89] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

//<handler-documentation> ::= (message-handler <name> [<handler-type>])
  final public void HandlerDocumentation() throws ParseException {
                                      Token t; int i=-1;
    jj_consume_token(MESSAGE_HANDLER);
    t = jj_consume_token(SYMBOL);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PRIMARY:
    case AROUND:
    case BEFORE:
    case AFTER:
      i = HandlerType();
      break;
    default:
      jj_la1[90] = jj_gen;
      ;
    }
  }

// JUST RETURN TYPE
//<handler-type> ::= primary | around | before | after
  final public int HandlerType() throws ParseException {
                            int i=-1;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PRIMARY:
      jj_consume_token(PRIMARY);
                                  i=0;
      break;
    case AROUND:
      jj_consume_token(AROUND);
                                  i=1;
      break;
    case BEFORE:
      jj_consume_token(BEFORE);
                                  i=2;
      break;
    case AFTER:
      jj_consume_token(AFTER);
                                  i=3;
      break;
    default:
      jj_la1[91] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
          {if (true) return i;}
    throw new Error("Missing return statement in function");
  }

/* 	Defmessage-handler Construct
	<defmessage-handler-construct> 
		::= (defmessage-handler <class-name> <message-name> [<handler-type>] 
			[<comment>] (<parameter>* [<wildcard-parameter>]) <action>*)
	<handler-type> ::= around | before | primary | after
	<parameter> ::= <single-field-variable>
	<wildcard-parameter> ::= <multifield-variable>
*/

//<defmessage-handler-construct> 
//	::= (defmessage-handler <class-name> <message-name> [<handler-type>] 
//		[<comment>] (<parameter>* [<wildcard-parameter>]) <action>*)
  final public void DefmessageHandlerConstruct() throws ParseException {
                                     /*@bgen(jjtree) DefmessageHandlerConstruct */
                                      COOLDefmessageHandlerConstruct jjtn000 = new COOLDefmessageHandlerConstruct(this, JJTDEFMESSAGEHANDLERCONSTRUCT);
                                      boolean jjtc000 = true;
                                      jjtree.openNodeScope(jjtn000);Token t;
    try {
      jj_consume_token(DEFMESSAGEHANDLER);
      t = jj_consume_token(SYMBOL);
          jjtn000.setClassName(t.image);
      //name
              t = jj_consume_token(SYMBOL);
          jjtn000.setName(t.image);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PRIMARY:
      case AROUND:
      case BEFORE:
      case AFTER:
        HandlerType();
        break;
      default:
        jj_la1[92] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STRING:
        t = jj_consume_token(STRING);
                  jjtn000.setDocString(ParserUtils.getStringLiteral(t.image));
        break;
      default:
        jj_la1[93] = jj_gen;
        ;
      }
      jj_consume_token(LBRACE);
      label_37:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SINGLEVAR:
          ;
          break;
        default:
          jj_la1[94] = jj_gen;
          break label_37;
        }
        SingleVariable();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MULTIVAR:
        MultiVariable();
        break;
      default:
        jj_la1[95] = jj_gen;
        ;
      }
      jj_consume_token(RBRACE);
      ActionList();
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

/*	Definstances Construct
	<definstances-construct> ::= (definstances <definstances-name> [active] [<comment>] <instance-template>*)
	<instance-template> ::= (<instance-definition>)
	<instance-definition> ::= <instance-name-expression> of <class-name-expression> <slot-override>*
	<slot-override> ::= (<slot-name-expression> <expression>*)
*/

//<definstances-construct> ::= (definstances <definstances-name> [active] [<comment>] <instance-template>*)
  final public void DefinstancesConstruct() throws ParseException {
                                /*@bgen(jjtree) DefinstancesConstruct */
                                 COOLDefinstancesConstruct jjtn000 = new COOLDefinstancesConstruct(this, JJTDEFINSTANCESCONSTRUCT);
                                 boolean jjtc000 = true;
                                 jjtree.openNodeScope(jjtn000);Token t;
    try {
      jj_consume_token(DEFINSTANCES);
      t = jj_consume_token(SYMBOL);
          jjtn000.setName(t.image);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ACTIVE:
        jj_consume_token(ACTIVE);
        break;
      default:
        jj_la1[96] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STRING:
        t = jj_consume_token(STRING);
                  jjtn000.setDocString(ParserUtils.getStringLiteral(t.image));
        break;
      default:
        jj_la1[97] = jj_gen;
        ;
      }
      label_38:
      while (true) {
        if (jj_2_20(2)) {
          ;
        } else {
          break label_38;
        }
        InstanceTemplate();
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

//<instance-template> ::= (<instance-definition>)
  final public void InstanceTemplate() throws ParseException {
    jj_consume_token(LBRACE);
    InstanceDefinition();
    jj_consume_token(RBRACE);
  }

//<instance-definition> ::= <instance-name-expression> of <class-name-expression> <slot-override>*
  final public void InstanceDefinition() throws ParseException {
                                    Token t;
    // Should have two expressions returning the correct types, not symbols!!
            t = jj_consume_token(SYMBOL);
    jj_consume_token(OF);
    t = jj_consume_token(SYMBOL);
    label_39:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACE:
        ;
        break;
      default:
        jj_la1[98] = jj_gen;
        break label_39;
      }
      SlotOverride();
    }
  }

//<slot-override> ::= (<slot-name-expression> <expression>*)
  final public void SlotOverride() throws ParseException {
                              Token t;
    jj_consume_token(LBRACE);
    t = jj_consume_token(SYMBOL);
    ActionList();
    jj_consume_token(RBRACE);
  }

/*	Defmodule Construct
	<defmodule-construct> ::= (defmodule <module-name> [<comment>] <port-specification>*)
	<port-specification> ::= (export <port-item>) | (import <module-name> <port-item>)
	<port-item> ::= ?ALL | ?NONE | <port-construct> ?ALL | 
		<port-construct> ?NONE | <port-construct> <construct-name>+
	<port-construct> ::= deftemplate_construct | defclass | defglobal | deffunction | defgeneric
*/

//<defmodule-construct> ::= (defmodule <module-name> [<comment>] <port-specification>*)
  final public void DefmoduleConstruct() throws ParseException {
                             /*@bgen(jjtree) DefmoduleConstruct */
                              COOLDefmoduleConstruct jjtn000 = new COOLDefmoduleConstruct(this, JJTDEFMODULECONSTRUCT);
                              boolean jjtc000 = true;
                              jjtree.openNodeScope(jjtn000);Token t;
    try {
      jj_consume_token(DEFMODULE);
      t = jj_consume_token(SYMBOL);
          jjtn000.setName(t.image);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SYMBOL:
        t = jj_consume_token(SYMBOL);
                  jjtn000.setDocString(t.image);
        break;
      default:
        jj_la1[99] = jj_gen;
        ;
      }
      label_40:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LBRACE:
        case IMPORT:
          ;
          break;
        default:
          jj_la1[100] = jj_gen;
          break label_40;
        }
        PortSpecification();
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

//<port-specification> ::= (export <port-item>) | (import <module-name> <port-item>)
  final public void PortSpecification() throws ParseException {
                            /*@bgen(jjtree) PortSpecification */
                             COOLPortSpecification jjtn000 = new COOLPortSpecification(this, JJTPORTSPECIFICATION);
                             boolean jjtc000 = true;
                             jjtree.openNodeScope(jjtn000);Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACE:
        jj_consume_token(LBRACE);
        jj_consume_token(EXPORT);
        PortItem();
        break;
      case IMPORT:
        jj_consume_token(IMPORT);
        t = jj_consume_token(SYMBOL);
                  jjtn000.setName(t.image);
        PortItem();
        jj_consume_token(RBRACE);
        break;
      default:
        jj_la1[101] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

//			(
//				t = <SYMBOL>
//				{ jjtThis.addCLIPSPortname(t.image); }
//			)+

//<port-item> ::= ?ALL | ?NONE | <port-construct> ?ALL | 
//	<port-construct> ?NONE | <port-construct> <construct-name>+
  final public void PortItem() throws ParseException {
                   /*@bgen(jjtree) PortItem */
                    COOLPortItem jjtn000 = new COOLPortItem(this, JJTPORTITEM);
                    boolean jjtc000 = true;
                    jjtree.openNodeScope(jjtn000);Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ATR_ALL:
        jj_consume_token(ATR_ALL);
        break;
      case ATR_NONE:
        jj_consume_token(ATR_NONE);
        break;
      case DEFTEMPLATE_CONSTRUCT:
      case DEFFUNCTION:
      case DEFGENERIC:
      case DEFCLASS:
      case DEFGLOBAL:
        PortConstruct();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ATR_ALL:
          jj_consume_token(ATR_ALL);
          break;
        case ATR_NONE:
          jj_consume_token(ATR_NONE);
          break;
        default:
          jj_la1[103] = jj_gen;
          label_41:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case INSTANCE:
            case SYMBOL:
              ;
              break;
            default:
              jj_la1[102] = jj_gen;
              break label_41;
            }
            ConstructName();
          }
        }
        break;
      default:
        jj_la1[104] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void ConstructName() throws ParseException {
                        /*@bgen(jjtree) ConstructName */
                         COOLConstructName jjtn000 = new COOLConstructName(this, JJTCONSTRUCTNAME);
                         boolean jjtc000 = true;
                         jjtree.openNodeScope(jjtn000);Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SYMBOL:
        t = jj_consume_token(SYMBOL);
        break;
      case INSTANCE:
        t = jj_consume_token(INSTANCE);
        break;
      default:
        jj_la1[105] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
            jjtree.closeNodeScope(jjtn000, true);
            jjtc000 = false;
            jjtn000.setName(t.image);
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

//<port-construct> ::= deftemplate_construct | defclass | defglobal | deffunction | defgeneric
  final public void PortConstruct() throws ParseException {
    if (jj_2_21(2)) {
      jj_consume_token(DEFTEMPLATE_CONSTRUCT);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DEFCLASS:
        jj_consume_token(DEFCLASS);
        break;
      case DEFGLOBAL:
        jj_consume_token(DEFGLOBAL);
        break;
      case DEFFUNCTION:
        jj_consume_token(DEFFUNCTION);
        break;
      case DEFGENERIC:
        jj_consume_token(DEFGENERIC);
        break;
      default:
        jj_la1[106] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

/* constraint Attributes */

//<constraint-attribute> ::= <type-attribute> | <allowed-constant-attribute> | 
//	<range-attribute> | <cardinality-attribute>
  final public void ConstraintAttribute(TemplateSlot ts) throws ParseException {
    if (jj_2_22(2)) {
      TypeAttribute(ts);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ALLOWED_SYMBOLS:
      case ALLOWED_STRINGS:
      case ALLOWED_LEXEMES:
      case ALLOWED_INTEGERS:
      case ALLOWED_FLOATS:
      case ALLOWED_NUMBERS:
      case ALLOWED_INSTANCES:
      case ALLOWED_CLASSES:
      case ALLOWED_VALUES:
        AllowedConstantAttribute();
        break;
      case RANGE:
        RangeAttribute();
        break;
      case CARDINALITY:
        CardinalityAttribute();
        break;
      default:
        jj_la1[107] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

//<type-attribute> ::= (type <type-specification>)
  final public void TypeAttribute(TemplateSlot ts) throws ParseException {
    jj_consume_token(TYPE);
    TypeSpecification(ts);
  }

///////////////////
// Use EnumSets here

//<type-specification> ::= <allowed-type>+ | ?VARIABLE
  final public void TypeSpecification(TemplateSlot ts) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DATETIME:
    case SYMBOL_TYPE:
    case STRING_TYPE:
    case DATETIME_TYPE:
    case LEXEME_TYPE:
    case INTEGER_TYPE:
    case FLOAT_TYPE:
    case NUMBER_TYPE:
    case INSTANCE_NAME_TYPE:
    case INSTANCE_ADDRESS_TYPE:
    case INSTANCE_TYPE:
    case EXTERNAL_ADDRESS_TYPE:
    case FACT_ADDRESS_TYPE:
      label_42:
      while (true) {
        AllowedType(ts);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DATETIME:
        case SYMBOL_TYPE:
        case STRING_TYPE:
        case DATETIME_TYPE:
        case LEXEME_TYPE:
        case INTEGER_TYPE:
        case FLOAT_TYPE:
        case NUMBER_TYPE:
        case INSTANCE_NAME_TYPE:
        case INSTANCE_ADDRESS_TYPE:
        case INSTANCE_TYPE:
        case EXTERNAL_ADDRESS_TYPE:
        case FACT_ADDRESS_TYPE:
          ;
          break;
        default:
          jj_la1[108] = jj_gen;
          break label_42;
        }
      }
      break;
    case VARIABLE_TYPE:
      jj_consume_token(VARIABLE_TYPE);
      break;
    default:
      jj_la1[109] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

//<allowed-type> ::= SYMBOL | STRING | LEXEME | INTEGER | FLOAT | NUMBER |
//	INSTANCE-NAME | INSTANCE-ADDRESS | INSTANCE | EXTERNAL-ADDRESS | FACT-ADDRESS | DATETIME
  final public void AllowedType(TemplateSlot ts) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SYMBOL_TYPE:
      jj_consume_token(SYMBOL_TYPE);
                                ts.setValueType(JamochaType.IDENTIFIER);
      break;
    case STRING_TYPE:
      jj_consume_token(STRING_TYPE);
                                ts.setValueType(JamochaType.STRING);
      break;
    case DATETIME_TYPE:
      jj_consume_token(DATETIME_TYPE);
                                  ts.setValueType(JamochaType.DATETIME);
      break;
    case LEXEME_TYPE:
      jj_consume_token(LEXEME_TYPE);
                                ts.setValueType(JamochaType.IDENTIFIER);
      break;
    case INTEGER_TYPE:
      jj_consume_token(INTEGER_TYPE);
                                 ts.setValueType(JamochaType.LONG);
      break;
    case FLOAT_TYPE:
      jj_consume_token(FLOAT_TYPE);
                               ts.setValueType(JamochaType.DOUBLE);
      break;
    case NUMBER_TYPE:
      jj_consume_token(NUMBER_TYPE);
                                ts.setValueType(JamochaType.DOUBLE);
      break;
    case INSTANCE_NAME_TYPE:
      jj_consume_token(INSTANCE_NAME_TYPE);
                                       ts.setValueType(JamochaType.UNDEFINED);
      break;
    case INSTANCE_ADDRESS_TYPE:
      jj_consume_token(INSTANCE_ADDRESS_TYPE);
                                          ts.setValueType(JamochaType.UNDEFINED);
      break;
    case INSTANCE_TYPE:
      jj_consume_token(INSTANCE_TYPE);
                                  ts.setValueType(JamochaType.UNDEFINED);
      break;
    case EXTERNAL_ADDRESS_TYPE:
      jj_consume_token(EXTERNAL_ADDRESS_TYPE);
                                          ts.setValueType(JamochaType.UNDEFINED);
      break;
    case FACT_ADDRESS_TYPE:
      jj_consume_token(FACT_ADDRESS_TYPE);
                                      ts.setValueType(JamochaType.FACT_ID);
      break;
    case DATETIME:
      jj_consume_token(DATETIME);
                         ts.setValueType(JamochaType.DATETIME);
      break;
    default:
      jj_la1[110] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

// <allowed-constant-attribute> ::= (allowed-symbols <symbol-list>) | (allowed-strings <string-list>) |
//	(allowed-lexemes <lexeme-list> | (allowed-integers <integer-list>) | (allowed-floats <float-list>) |
//	(allowed-numbers <number-list>) | (allowed-instance-names <instance-list>) |
//	(allowed-classes <class-name-list>) | (allowed-values <value-list>)
  final public void AllowedConstantAttribute() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ALLOWED_SYMBOLS:
      jj_consume_token(ALLOWED_SYMBOLS);
      SymbolList();
      break;
    case ALLOWED_STRINGS:
      jj_consume_token(ALLOWED_STRINGS);
      StringList();
      break;
    case ALLOWED_LEXEMES:
      jj_consume_token(ALLOWED_LEXEMES);
      LexemeList();
      break;
    case ALLOWED_INTEGERS:
      jj_consume_token(ALLOWED_INTEGERS);
      IntegerList();
      break;
    case ALLOWED_FLOATS:
      jj_consume_token(ALLOWED_FLOATS);
      FloatList();
      break;
    case ALLOWED_NUMBERS:
      jj_consume_token(ALLOWED_NUMBERS);
      NumberList();
      break;
    case ALLOWED_INSTANCES:
      jj_consume_token(ALLOWED_INSTANCES);
      InstanceList();
      break;
    case ALLOWED_CLASSES:
      jj_consume_token(ALLOWED_CLASSES);
      ClassNameList();
      break;
    case ALLOWED_VALUES:
      jj_consume_token(ALLOWED_VALUES);
      ValueList();
      break;
    default:
      jj_la1[111] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

//<symbol-list> ::= <symbol>+ | ?VARIABLE
  final public void SymbolList() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SYMBOL:
      label_43:
      while (true) {
        jj_consume_token(SYMBOL);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SYMBOL:
          ;
          break;
        default:
          jj_la1[112] = jj_gen;
          break label_43;
        }
      }
      break;
    case VARIABLE_TYPE:
      jj_consume_token(VARIABLE_TYPE);
      break;
    default:
      jj_la1[113] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

//<string-list> ::= <string>+ | ?VARIABLE
  final public void StringList() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case STRING:
      label_44:
      while (true) {
        jj_consume_token(STRING);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case STRING:
          ;
          break;
        default:
          jj_la1[114] = jj_gen;
          break label_44;
        }
      }
      break;
    case VARIABLE_TYPE:
      jj_consume_token(VARIABLE_TYPE);
      break;
    default:
      jj_la1[115] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

//<lexeme-list> ::= <lexeme>+ | ?VARIABLE
  final public void LexemeList() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case STRING:
    case SYMBOL:
      label_45:
      while (true) {
        Lexeme();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case STRING:
        case SYMBOL:
          ;
          break;
        default:
          jj_la1[116] = jj_gen;
          break label_45;
        }
      }
      break;
    case VARIABLE_TYPE:
      jj_consume_token(VARIABLE_TYPE);
      break;
    default:
      jj_la1[117] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

//<integer-list> ::= <integer>+ | ?VARIABLE
  final public void IntegerList() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER:
      label_46:
      while (true) {
        jj_consume_token(INTEGER);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case INTEGER:
          ;
          break;
        default:
          jj_la1[118] = jj_gen;
          break label_46;
        }
      }
      break;
    case VARIABLE_TYPE:
      jj_consume_token(VARIABLE_TYPE);
      break;
    default:
      jj_la1[119] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

//<float-list> ::= <float>+ | ?VARIABLE
  final public void FloatList() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FLOAT:
      label_47:
      while (true) {
        jj_consume_token(FLOAT);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case FLOAT:
          ;
          break;
        default:
          jj_la1[120] = jj_gen;
          break label_47;
        }
      }
      break;
    case VARIABLE_TYPE:
      jj_consume_token(VARIABLE_TYPE);
      break;
    default:
      jj_la1[121] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

//<number-list> ::= <number>+ | ?VARIABLE
  final public void NumberList() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER:
    case FLOAT:
      label_48:
      while (true) {
        Number();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case INTEGER:
        case FLOAT:
          ;
          break;
        default:
          jj_la1[122] = jj_gen;
          break label_48;
        }
      }
      break;
    case VARIABLE_TYPE:
      jj_consume_token(VARIABLE_TYPE);
      break;
    default:
      jj_la1[123] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

//<instance-name-list> ::= <instance-name>+ | ?VARIABLE
  final public void InstanceList() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INSTANCE:
      label_49:
      while (true) {
        jj_consume_token(INSTANCE);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case INSTANCE:
          ;
          break;
        default:
          jj_la1[124] = jj_gen;
          break label_49;
        }
      }
      break;
    case VARIABLE_TYPE:
      jj_consume_token(VARIABLE_TYPE);
      break;
    default:
      jj_la1[125] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

//<class-name-list> ::= <class-name>+ | ?VARIABLE
  final public void ClassNameList() throws ParseException {
                               Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SYMBOL:
      label_50:
      while (true) {
        t = jj_consume_token(SYMBOL);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SYMBOL:
          ;
          break;
        default:
          jj_la1[126] = jj_gen;
          break label_50;
        }
      }
      break;
    case VARIABLE_TYPE:
      jj_consume_token(VARIABLE_TYPE);
      break;
    default:
      jj_la1[127] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

//<value-list> ::= <constant>+ | ?VARIABLE
  final public void ValueList() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER:
    case FLOAT:
    case DATETIME:
    case STRING:
    case INSTANCE:
    case SYMBOL:
      label_51:
      while (true) {
        Constant();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case INTEGER:
        case FLOAT:
        case DATETIME:
        case STRING:
        case INSTANCE:
        case SYMBOL:
          ;
          break;
        default:
          jj_la1[128] = jj_gen;
          break label_51;
        }
      }
      break;
    case VARIABLE_TYPE:
      jj_consume_token(VARIABLE_TYPE);
      break;
    default:
      jj_la1[129] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

//<range-attribute> ::= (range <range-specification> <range-specification>)
  final public void RangeAttribute() throws ParseException {
    jj_consume_token(RANGE);
    RangeSpecification();
    RangeSpecification();
  }

//<range-specification> ::= <number> | ?VARIABLE
  final public void RangeSpecification() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER:
    case FLOAT:
      Number();
      break;
    case VARIABLE_TYPE:
      jj_consume_token(VARIABLE_TYPE);
      break;
    default:
      jj_la1[130] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

//<cardinality-attribute> ::= (cardinality <cardinality-specification> <cardinality-specification>)
  final public void CardinalityAttribute() throws ParseException {
    jj_consume_token(CARDINALITY);
    CardinalitySpecification();
    CardinalitySpecification();
  }

//<cardinality-specification> ::= <integer> | ?VARIABLE
  final public void CardinalitySpecification() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER:
      Integer();
      break;
    case VARIABLE_TYPE:
      jj_consume_token(VARIABLE_TYPE);
      break;
    default:
      jj_la1[131] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  final private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  final private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  final private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  final private boolean jj_2_5(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_5(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(4, xla); }
  }

  final private boolean jj_2_6(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_6(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(5, xla); }
  }

  final private boolean jj_2_7(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_7(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(6, xla); }
  }

  final private boolean jj_2_8(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_8(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(7, xla); }
  }

  final private boolean jj_2_9(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_9(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(8, xla); }
  }

  final private boolean jj_2_10(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_10(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(9, xla); }
  }

  final private boolean jj_2_11(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_11(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(10, xla); }
  }

  final private boolean jj_2_12(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_12(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(11, xla); }
  }

  final private boolean jj_2_13(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_13(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(12, xla); }
  }

  final private boolean jj_2_14(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_14(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(13, xla); }
  }

  final private boolean jj_2_15(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_15(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(14, xla); }
  }

  final private boolean jj_2_16(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_16(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(15, xla); }
  }

  final private boolean jj_2_17(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_17(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(16, xla); }
  }

  final private boolean jj_2_18(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_18(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(17, xla); }
  }

  final private boolean jj_2_19(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_19(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(18, xla); }
  }

  final private boolean jj_2_20(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_20(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(19, xla); }
  }

  final private boolean jj_2_21(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_21(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(20, xla); }
  }

  final private boolean jj_2_22(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_22(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(21, xla); }
  }

  final private boolean jj_3R_65() {
    if (jj_scan_token(MESSAGE_HANDLER)) return true;
    if (jj_scan_token(SYMBOL)) return true;
    return false;
  }

  final private boolean jj_3R_114() {
    if (jj_scan_token(STRING)) return true;
    return false;
  }

  final private boolean jj_3R_147() {
    if (jj_scan_token(TILDE)) return true;
    return false;
  }

  final private boolean jj_3R_122() {
    if (jj_scan_token(SFWILDCARD)) return true;
    return false;
  }

  final private boolean jj_3R_123() {
    if (jj_scan_token(MFWILDCARD)) return true;
    return false;
  }

  final private boolean jj_3R_151() {
    if (jj_scan_token(EQUALS)) return true;
    if (jj_3R_120()) return true;
    return false;
  }

  final private boolean jj_3R_150() {
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_120()) return true;
    return false;
  }

  final private boolean jj_3R_149() {
    if (jj_3R_140()) return true;
    return false;
  }

  final private boolean jj_3R_148() {
    if (jj_3R_139()) return true;
    return false;
  }

  final private boolean jj_3R_113() {
    if (jj_scan_token(SYMBOL)) return true;
    return false;
  }

  final private boolean jj_3_11() {
    if (jj_3R_53()) return true;
    return false;
  }

  final private boolean jj_3R_136() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_147()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3_11()) {
    jj_scanpos = xsp;
    if (jj_3R_148()) {
    jj_scanpos = xsp;
    if (jj_3R_149()) {
    jj_scanpos = xsp;
    if (jj_3R_150()) {
    jj_scanpos = xsp;
    if (jj_3R_151()) return true;
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_153() {
    if (jj_scan_token(LINE)) return true;
    return false;
  }

  final private boolean jj_3R_137() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_152()) {
    jj_scanpos = xsp;
    if (jj_3R_153()) return true;
    }
    return false;
  }

  final private boolean jj_3R_152() {
    if (jj_scan_token(AMPERSAND)) return true;
    return false;
  }

  final private boolean jj_3R_172() {
    if (jj_scan_token(LBRACE)) return true;
    return false;
  }

  final private boolean jj_3R_92() {
    if (jj_3R_123()) return true;
    return false;
  }

  final private boolean jj_3R_124() {
    if (jj_3R_136()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_137()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_86() {
    if (jj_3R_118()) return true;
    return false;
  }

  final private boolean jj_3R_85() {
    if (jj_scan_token(ATR_DERIVE)) return true;
    return false;
  }

  final private boolean jj_3R_112() {
    if (jj_scan_token(DATETIME)) return true;
    return false;
  }

  final private boolean jj_3_10() {
    if (jj_3R_60()) return true;
    return false;
  }

  final private boolean jj_3R_115() {
    if (jj_scan_token(INTEGER)) return true;
    return false;
  }

  final private boolean jj_3R_56() {
    if (jj_scan_token(DEFAULT_ATR)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_85()) {
    jj_scanpos = xsp;
    if (jj_scan_token(38)) {
    jj_scanpos = xsp;
    if (jj_3R_86()) return true;
    }
    }
    return false;
  }

  final private boolean jj_3R_91() {
    if (jj_3R_122()) return true;
    return false;
  }

  final private boolean jj_3R_60() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_91()) {
    jj_scanpos = xsp;
    if (jj_3R_92()) {
    jj_scanpos = xsp;
    if (jj_3R_93()) return true;
    }
    }
    return false;
  }

  final private boolean jj_3R_116() {
    if (jj_scan_token(FLOAT)) return true;
    return false;
  }

  final private boolean jj_3_6() {
    if (jj_3R_57()) return true;
    return false;
  }

  final private boolean jj_3R_118() {
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_6()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3_5() {
    if (jj_3R_56()) return true;
    return false;
  }

  final private boolean jj_3_1() {
    if (jj_3R_52()) return true;
    return false;
  }

  final private boolean jj_3R_125() {
    if (jj_scan_token(ATR_DERIVE)) return true;
    return false;
  }

  final private boolean jj_3R_126() {
    if (jj_3R_118()) return true;
    return false;
  }

  final private boolean jj_3R_90() {
    if (jj_3R_60()) return true;
    return false;
  }

  final private boolean jj_3R_99() {
    if (jj_scan_token(DYNAMIC_ATR)) return true;
    if (jj_3R_118()) return true;
    return false;
  }

  final private boolean jj_3R_98() {
    if (jj_scan_token(DEFAULT_ATR)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_125()) {
    jj_scanpos = xsp;
    if (jj_scan_token(38)) {
    jj_scanpos = xsp;
    if (jj_3R_126()) return true;
    }
    }
    return false;
  }

  final private boolean jj_3R_66() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_98()) {
    jj_scanpos = xsp;
    if (jj_3R_99()) return true;
    }
    return false;
  }

  final private boolean jj_3_19() {
    if (jj_3R_66()) return true;
    return false;
  }

  final private boolean jj_3R_59() {
    if (jj_scan_token(SYMBOL)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_90()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_97() {
    if (jj_scan_token(MULTISLOT)) return true;
    return false;
  }

  final private boolean jj_3R_96() {
    if (jj_scan_token(SINGLE_SLOT)) return true;
    return false;
  }

  final private boolean jj_3R_95() {
    if (jj_scan_token(SLOT)) return true;
    return false;
  }

  final private boolean jj_3R_102() {
    if (jj_scan_token(DEFTEMPLATE)) return true;
    return false;
  }

  final private boolean jj_3R_64() {
    if (jj_scan_token(LBRACE)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_95()) {
    jj_scanpos = xsp;
    if (jj_3R_96()) {
    jj_scanpos = xsp;
    if (jj_3R_97()) return true;
    }
    }
    return false;
  }

  final private boolean jj_3R_78() {
    if (jj_3R_111()) return true;
    return false;
  }

  final private boolean jj_3R_55() {
    if (jj_scan_token(DEFFACTS)) return true;
    if (jj_scan_token(SYMBOL)) return true;
    return false;
  }

  final private boolean jj_3R_77() {
    if (jj_3R_110()) return true;
    return false;
  }

  final private boolean jj_3R_76() {
    if (jj_3R_109()) return true;
    return false;
  }

  final private boolean jj_3R_75() {
    if (jj_3R_108()) return true;
    return false;
  }

  final private boolean jj_3R_74() {
    if (jj_3R_107()) return true;
    return false;
  }

  final private boolean jj_3R_73() {
    if (jj_3R_106()) return true;
    return false;
  }

  final private boolean jj_3R_63() {
    if (jj_scan_token(LBRACE)) return true;
    if (jj_scan_token(PATTERN_MATCH)) return true;
    return false;
  }

  final private boolean jj_3R_170() {
    if (jj_scan_token(FACT_ADDRESS_TYPE)) return true;
    return false;
  }

  final private boolean jj_3R_72() {
    if (jj_3R_105()) return true;
    return false;
  }

  final private boolean jj_3R_169() {
    if (jj_scan_token(EXTERNAL_ADDRESS_TYPE)) return true;
    return false;
  }

  final private boolean jj_3R_71() {
    if (jj_3R_104()) return true;
    return false;
  }

  final private boolean jj_3R_168() {
    if (jj_scan_token(INSTANCE_TYPE)) return true;
    return false;
  }

  final private boolean jj_3R_70() {
    if (jj_3R_103()) return true;
    return false;
  }

  final private boolean jj_3R_167() {
    if (jj_scan_token(INSTANCE_ADDRESS_TYPE)) return true;
    return false;
  }

  final private boolean jj_3R_171() {
    if (jj_scan_token(DATETIME)) return true;
    return false;
  }

  final private boolean jj_3R_69() {
    if (jj_3R_102()) return true;
    return false;
  }

  final private boolean jj_3R_166() {
    if (jj_scan_token(INSTANCE_NAME_TYPE)) return true;
    return false;
  }

  final private boolean jj_3R_165() {
    if (jj_scan_token(NUMBER_TYPE)) return true;
    return false;
  }

  final private boolean jj_3R_164() {
    if (jj_scan_token(FLOAT_TYPE)) return true;
    return false;
  }

  final private boolean jj_3R_163() {
    if (jj_scan_token(INTEGER_TYPE)) return true;
    return false;
  }

  final private boolean jj_3R_162() {
    if (jj_scan_token(LEXEME_TYPE)) return true;
    return false;
  }

  final private boolean jj_3R_161() {
    if (jj_scan_token(DATETIME_TYPE)) return true;
    return false;
  }

  final private boolean jj_3R_160() {
    if (jj_scan_token(STRING_TYPE)) return true;
    return false;
  }

  final private boolean jj_3R_159() {
    if (jj_scan_token(SYMBOL_TYPE)) return true;
    return false;
  }

  final private boolean jj_3_4() {
    if (jj_3R_55()) return true;
    return false;
  }

  final private boolean jj_3R_62() {
    if (jj_scan_token(LBRACE)) return true;
    if (jj_scan_token(ROLE)) return true;
    return false;
  }

  final private boolean jj_3R_52() {
    if (jj_scan_token(LBRACE)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_4()) {
    jj_scanpos = xsp;
    if (jj_3R_69()) {
    jj_scanpos = xsp;
    if (jj_3R_70()) {
    jj_scanpos = xsp;
    if (jj_3R_71()) {
    jj_scanpos = xsp;
    if (jj_3R_72()) {
    jj_scanpos = xsp;
    if (jj_3R_73()) {
    jj_scanpos = xsp;
    if (jj_3R_74()) {
    jj_scanpos = xsp;
    if (jj_3R_75()) {
    jj_scanpos = xsp;
    if (jj_3R_76()) {
    jj_scanpos = xsp;
    if (jj_3R_77()) {
    jj_scanpos = xsp;
    if (jj_3R_78()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3_18() {
    if (jj_3R_65()) return true;
    return false;
  }

  final private boolean jj_3_17() {
    if (jj_3R_64()) return true;
    return false;
  }

  final private boolean jj_3R_154() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_159()) {
    jj_scanpos = xsp;
    if (jj_3R_160()) {
    jj_scanpos = xsp;
    if (jj_3R_161()) {
    jj_scanpos = xsp;
    if (jj_3R_162()) {
    jj_scanpos = xsp;
    if (jj_3R_163()) {
    jj_scanpos = xsp;
    if (jj_3R_164()) {
    jj_scanpos = xsp;
    if (jj_3R_165()) {
    jj_scanpos = xsp;
    if (jj_3R_166()) {
    jj_scanpos = xsp;
    if (jj_3R_167()) {
    jj_scanpos = xsp;
    if (jj_3R_168()) {
    jj_scanpos = xsp;
    if (jj_3R_169()) {
    jj_scanpos = xsp;
    if (jj_3R_170()) {
    jj_scanpos = xsp;
    if (jj_3R_171()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3_16() {
    if (jj_3R_63()) return true;
    return false;
  }

  final private boolean jj_3_15() {
    if (jj_3R_62()) return true;
    return false;
  }

  final private boolean jj_3R_138() {
    if (jj_3R_154()) return true;
    return false;
  }

  final private boolean jj_3R_101() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_127()) {
    jj_scanpos = xsp;
    if (jj_scan_token(68)) return true;
    }
    return false;
  }

  final private boolean jj_3R_127() {
    Token xsp;
    if (jj_3R_138()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_138()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3_9() {
    if (jj_3R_59()) return true;
    return false;
  }

  final private boolean jj_3R_54() {
    if (jj_scan_token(LBRACE)) return true;
    if (jj_scan_token(CASE)) return true;
    return false;
  }

  final private boolean jj_3R_68() {
    if (jj_scan_token(TYPE)) return true;
    if (jj_3R_101()) return true;
    return false;
  }

  final private boolean jj_3_3() {
    if (jj_3R_54()) return true;
    return false;
  }

  final private boolean jj_3R_108() {
    if (jj_scan_token(DEFCLASS)) return true;
    return false;
  }

  final private boolean jj_3_22() {
    if (jj_3R_68()) return true;
    return false;
  }

  final private boolean jj_3_21() {
    if (jj_scan_token(DEFTEMPLATE_CONSTRUCT)) return true;
    return false;
  }

  final private boolean jj_3R_173() {
    if (jj_3R_57()) return true;
    return false;
  }

  final private boolean jj_3R_145() {
    if (jj_scan_token(IF)) return true;
    if (jj_3R_57()) return true;
    return false;
  }

  final private boolean jj_3R_156() {
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_173()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3_14() {
    if (jj_scan_token(MULTIVAR)) return true;
    return false;
  }

  final private boolean jj_3R_94() {
    if (jj_scan_token(LBRACE)) return true;
    if (jj_scan_token(SINGLEVAR)) return true;
    return false;
  }

  final private boolean jj_3_12() {
    if (jj_3R_61()) return true;
    return false;
  }

  final private boolean jj_3R_143() {
    if (jj_scan_token(RETRACT)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(139)) {
    jj_scanpos = xsp;
    if (jj_3R_156()) return true;
    }
    return false;
  }

  final private boolean jj_3R_157() {
    if (jj_3R_172()) return true;
    return false;
  }

  final private boolean jj_3R_144() {
    if (jj_scan_token(FIND_FACT_BY_FACT)) return true;
    Token xsp;
    if (jj_3R_157()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_157()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3_13() {
    if (jj_scan_token(SINGLEVAR)) return true;
    return false;
  }

  final private boolean jj_3R_61() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_13()) {
    jj_scanpos = xsp;
    if (jj_3R_94()) return true;
    }
    return false;
  }

  final private boolean jj_3R_121() {
    if (jj_scan_token(LBRACE)) return true;
    return false;
  }

  final private boolean jj_3R_89() {
    if (jj_3R_121()) return true;
    return false;
  }

  final private boolean jj_3R_155() {
    if (jj_3R_172()) return true;
    return false;
  }

  final private boolean jj_3R_111() {
    if (jj_scan_token(DEFMODULE)) return true;
    return false;
  }

  final private boolean jj_3R_142() {
    if (jj_scan_token(ASSERT)) return true;
    Token xsp;
    if (jj_3R_155()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_155()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_88() {
    if (jj_3R_120()) return true;
    return false;
  }

  final private boolean jj_3R_87() {
    if (jj_3R_119()) return true;
    return false;
  }

  final private boolean jj_3R_58() {
    if (jj_scan_token(LBRACE)) return true;
    if (jj_scan_token(DECLARE)) return true;
    Token xsp;
    if (jj_3R_89()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_89()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3_2() {
    if (jj_3R_53()) return true;
    return false;
  }

  final private boolean jj_3_8() {
    if (jj_3R_57()) return true;
    return false;
  }

  final private boolean jj_3R_57() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_2()) {
    jj_scanpos = xsp;
    if (jj_3R_87()) {
    jj_scanpos = xsp;
    if (jj_3R_88()) return true;
    }
    }
    return false;
  }

  final private boolean jj_3R_158() {
    if (jj_3R_57()) return true;
    return false;
  }

  final private boolean jj_3R_135() {
    if (jj_3R_146()) return true;
    return false;
  }

  final private boolean jj_3R_107() {
    if (jj_scan_token(DEFMETHOD)) return true;
    return false;
  }

  final private boolean jj_3R_134() {
    if (jj_3R_145()) return true;
    return false;
  }

  final private boolean jj_3R_146() {
    if (jj_scan_token(SYMBOL)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_158()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_132() {
    if (jj_3R_143()) return true;
    return false;
  }

  final private boolean jj_3R_131() {
    if (jj_3R_142()) return true;
    return false;
  }

  final private boolean jj_3R_133() {
    if (jj_3R_144()) return true;
    return false;
  }

  final private boolean jj_3R_100() {
    if (jj_scan_token(SYMBOL)) return true;
    return false;
  }

  final private boolean jj_3R_130() {
    if (jj_3R_141()) return true;
    return false;
  }

  final private boolean jj_3R_129() {
    if (jj_3R_140()) return true;
    return false;
  }

  final private boolean jj_3R_120() {
    if (jj_scan_token(LBRACE)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_131()) {
    jj_scanpos = xsp;
    if (jj_3R_132()) {
    jj_scanpos = xsp;
    if (jj_3R_133()) {
    jj_scanpos = xsp;
    if (jj_3R_134()) {
    jj_scanpos = xsp;
    if (jj_3R_135()) return true;
    }
    }
    }
    }
    if (jj_scan_token(RBRACE)) return true;
    return false;
  }

  final private boolean jj_3R_128() {
    if (jj_3R_139()) return true;
    return false;
  }

  final private boolean jj_3R_67() {
    if (jj_scan_token(LBRACE)) return true;
    if (jj_3R_100()) return true;
    return false;
  }

  final private boolean jj_3R_119() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_128()) {
    jj_scanpos = xsp;
    if (jj_3R_129()) {
    jj_scanpos = xsp;
    if (jj_3R_130()) return true;
    }
    }
    return false;
  }

  final private boolean jj_3R_106() {
    if (jj_scan_token(DEFGENERIC)) return true;
    return false;
  }

  final private boolean jj_3_20() {
    if (jj_3R_67()) return true;
    return false;
  }

  final private boolean jj_3R_140() {
    if (jj_scan_token(MULTIVAR)) return true;
    return false;
  }

  final private boolean jj_3_7() {
    if (jj_3R_58()) return true;
    return false;
  }

  final private boolean jj_3R_110() {
    if (jj_scan_token(DEFINSTANCES)) return true;
    return false;
  }

  final private boolean jj_3R_141() {
    if (jj_scan_token(GLOBALVAR)) return true;
    return false;
  }

  final private boolean jj_3R_139() {
    if (jj_scan_token(SINGLEVAR)) return true;
    return false;
  }

  final private boolean jj_3R_104() {
    if (jj_scan_token(DEFRULE)) return true;
    return false;
  }

  final private boolean jj_3R_105() {
    if (jj_scan_token(DEFFUNCTION)) return true;
    return false;
  }

  final private boolean jj_3R_84() {
    if (jj_3R_117()) return true;
    return false;
  }

  final private boolean jj_3R_83() {
    if (jj_3R_116()) return true;
    return false;
  }

  final private boolean jj_3R_109() {
    if (jj_scan_token(DEFMESSAGEHANDLER)) return true;
    return false;
  }

  final private boolean jj_3R_82() {
    if (jj_3R_115()) return true;
    return false;
  }

  final private boolean jj_3R_81() {
    if (jj_3R_114()) return true;
    return false;
  }

  final private boolean jj_3R_79() {
    if (jj_3R_112()) return true;
    return false;
  }

  final private boolean jj_3R_80() {
    if (jj_3R_113()) return true;
    return false;
  }

  final private boolean jj_3R_53() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_79()) {
    jj_scanpos = xsp;
    if (jj_3R_80()) {
    jj_scanpos = xsp;
    if (jj_3R_81()) {
    jj_scanpos = xsp;
    if (jj_3R_82()) {
    jj_scanpos = xsp;
    if (jj_3R_83()) {
    jj_scanpos = xsp;
    if (jj_3R_84()) return true;
    }
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_117() {
    if (jj_scan_token(INSTANCE)) return true;
    return false;
  }

  final private boolean jj_3R_93() {
    if (jj_3R_124()) return true;
    return false;
  }

  final private boolean jj_3R_103() {
    if (jj_scan_token(DEFGLOBAL)) return true;
    return false;
  }

  public COOLParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  public boolean lookingAhead = false;
  private boolean jj_semLA;
  private int jj_gen;
  final private int[] jj_la1 = new int[132];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static private int[] jj_la1_3;
  static private int[] jj_la1_4;
  static {
      jj_la1_0();
      jj_la1_1();
      jj_la1_2();
      jj_la1_3();
      jj_la1_4();
   }
   private static void jj_la1_0() {
      jj_la1_0 = new int[] {0x270c40,0x270c41,0xc00,0x20000,0x70c00,0x200000,0x0,0x270c40,0x200040,0x40,0x40,0x270c40,0x0,0x0,0x0,0x270c40,0x270c40,0x0,0x40,0xfe800000,0x20000,0x40,0x20000,0x40,0x0,0x40,0x40,0x0,0x0,0x270c40,0x40,0x270c40,0x20000,0x40,0x40,0x40,0x0,0x0,0x0,0x0,0x40,0x40,0x0,0x0,0x0,0x40,0x40,0x40,0x1f0c00,0x0,0x40,0x1f0c00,0x1f0c00,0x0,0x0,0x0,0x0,0x0,0x200000,0x20000,0x0,0x0,0x20000,0x400,0x20000,0x40,0x0,0x200040,0x40,0x0,0x200040,0x40,0x200040,0x20000,0x0,0x0,0x0,0x0,0x40,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20000,0x0,0x0,0x0,0x20000,0x0,0x0,0x0,0x20000,0x40,0x0,0x40,0x40,0x40000,0x0,0x2d000000,0x40000,0x2c000000,0x0,0x10000,0x10000,0x10000,0x0,0x0,0x0,0x20000,0x20000,0x20000,0x20000,0x400,0x400,0x800,0x800,0xc00,0xc00,0x40000,0x40000,0x0,0x0,0x70c00,0x70c00,0xc00,0x400,};
   }
   private static void jj_la1_1() {
      jj_la1_1 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x500,0x0,0x0,0x20008,0x60,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc0000,0x6000,0xc0000,0x1f700000,0x0,0x0,0x600000,0x700000,0x10000000,0x0,0x0,0x0,0x80000000,0x0,0x0,0x80000000,0x80000000,0x0,0x0,0x80000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x700,0x0,0x20000,0x60,0xc,0x0,0x0,0x0,0x0,0x0,0x0,0x40,0x10,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10000,0x10000,0x0,0xc0,0xc2,0x0,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_2() {
      jj_la1_2 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffe0000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc,0x0,0x0,0xc,0xc,0x3,0x3,0x0,0xc,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x60000000,0x0,0x0,0x0,0x8ffe0000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffe0000,0x1ffe0,0x1fff0,0x1ffe0,0x3fe0000,0x0,0x10,0x0,0x10,0x0,0x10,0x0,0x10,0x0,0x10,0x0,0x10,0x0,0x10,0x0,0x10,0x0,0x10,0x10,0x10,};
   }
   private static void jj_la1_3() {
      jj_la1_3 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x70000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x669048,0x0,0x0,0x30,0x980,0x6000,0x28000,0x3,0x180000,0x680,0x0,0xf000000,0xf000000,0xf000000,0x0,0x0,0x0,0x4,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_4() {
      jj_la1_4 = new int[] {0xe000,0xe000,0x0,0x8000,0x8000,0x6000,0x8008,0xe000,0x6000,0x0,0x0,0xe000,0x800,0x20,0x80,0xe000,0xe000,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe000,0x0,0xe000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xa000,0x0,0x0,0x0,0x0,0x8000,0x0,0x0,0x0,0xe000,0x8000,0x0,0xe000,0xe000,0x0,0x0,0x0,0x6000,0x8000,0x0,0x0,0x2000,0x4000,0x0,0x0,0x0,0x4000,0x8000,0x0,0x0,0x8000,0x0,0x0,0x0,0x0,0x8000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2000,0x4000,0x0,0x0,0x0,0x8000,0x0,0x0,0x8000,0x0,0x0,0x8000,0x0,0x0,0x0,0x0,0x0,0x0,0x8000,0x8000,0x0,0x0,0x8000,0x8000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000,0x8000,0x8000,0x8000,0x0,0x0,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[22];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  public COOLParser(java.io.InputStream stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new COOLParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 132; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(java.io.InputStream stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 132; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public COOLParser(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new COOLParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 132; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 132; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public COOLParser(COOLParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 132; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(COOLParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 132; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  final private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }

  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  final public Token getToken(int index) {
    Token t = lookingAhead ? jj_scanpos : token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.Vector jj_expentries = new java.util.Vector();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      boolean exists = false;
      for (java.util.Enumeration e = jj_expentries.elements(); e.hasMoreElements();) {
        int[] oldentry = (int[])(e.nextElement());
        if (oldentry.length == jj_expentry.length) {
          exists = true;
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              exists = false;
              break;
            }
          }
          if (exists) break;
        }
      }
      if (!exists) jj_expentries.addElement(jj_expentry);
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[144];
    for (int i = 0; i < 144; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 132; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
          if ((jj_la1_3[i] & (1<<j)) != 0) {
            la1tokens[96+j] = true;
          }
          if ((jj_la1_4[i] & (1<<j)) != 0) {
            la1tokens[128+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 144; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

  final private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 22; i++) {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
            case 5: jj_3_6(); break;
            case 6: jj_3_7(); break;
            case 7: jj_3_8(); break;
            case 8: jj_3_9(); break;
            case 9: jj_3_10(); break;
            case 10: jj_3_11(); break;
            case 11: jj_3_12(); break;
            case 12: jj_3_13(); break;
            case 13: jj_3_14(); break;
            case 14: jj_3_15(); break;
            case 15: jj_3_16(); break;
            case 16: jj_3_17(); break;
            case 17: jj_3_18(); break;
            case 18: jj_3_19(); break;
            case 19: jj_3_20(); break;
            case 20: jj_3_21(); break;
            case 21: jj_3_22(); break;
          }
        }
        p = p.next;
      } while (p != null);
    }
    jj_rescan = false;
  }

  final private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
