/** Grammar to generate a CLIPS Object Oriented Language (COOL)  parser with jjTree. 
	COOL is the language used by the CLIPS Production system 
		
	This jjTree Grammar creates an abstract synatx tree, based as closely on the 'look'
	of the source code, while the grammar is as close as possible to the specifications.
	This uses lots of rules which do not create nodes...
	
	The Actions  the grammar productions make certain assumptions about the nodes created.
	The following methods should be required by the SimpleNode interface:
		-setName
		-getName
		-execute
	Constructs also have
		-setDocString
		-getDocString
	
	Some Rules do not create Nodes, but instead directly produce data compatible
	with the engine. [ e.g. (autofocus true) is two nodes for 1 bit of information).
	
	Created Nov. 8th, 2006, at the Agent Technologies Practical 2006 at Aachen Technical University.
	
	@author Ory Chowaw-Liebman 
	@author Ulrich Loup
	@todo Can probably be optimized a bit
*/

options {
	MULTI=true;
	STATIC=false;
	NODE_PREFIX="COOL";
	NODE_USES_PARSER=true;
    ERROR_REPORTING = true;
}


/* Java code used for the Parser. */
PARSER_BEGIN(COOLParser)
package org.jamocha.parser.cool;

import java.util.Hashtable;
import java.util.HashSet;
import java.util.Set;
import java.util.Iterator;
import java.util.ArrayList;

import org.jamocha.parser.JamochaValue;
import org.jamocha.parser.JamochaType;
import org.jamocha.parser.Parser;
import org.jamocha.parser.ParserUtils;
import org.jamocha.parser.Expression;

import org.jamocha.rete.Rete;
import org.jamocha.rete.Slot;
import org.jamocha.rete.MultiSlot;
import org.jamocha.rete.AbstractSlot;
import org.jamocha.rete.Function;
import org.jamocha.rete.Fact;
import org.jamocha.rete.TemplateSlot;
import org.jamocha.rule.*;

/** This is the jjTree Parser Class. Use Start() to parse an expression or construct of the 
	COOL programming langauge, and retrieve the Syntax tree returned as a class of type Node
	(or SimpleNode, or COOLStart).
	The actual parser is generated by jjTree (which generates the node classes for rules, if
	they don't exist) and JavaCC. Most funcitonality lies within the nodes, which therefore
	most not be deleted!! Regenerated nodes will lack members used in the semanic actions!
	Some nodes only contain very little information (as ittle as half a bit :-), so these
	tules do not generate rules, but preferably set the information directly in a class as 
	close as posible to the engine.
	See also class SimpleNode for information on Syntax Trees.
	Note that productions like lists of floats or sets of types should directly produce
	engine compatible classes or java lists, EnumSets and such.
*/
public class COOLParser implements Parser{

	/** Hash Table for the names known entities (rules, templates,...)
		Clips BNF uses different tokens for semantically different symbols,
		that is a symbol which is typed, and the type is used to 
	*/
        private Set deftemplates = new HashSet();

        public Expression nextExpression() throws ParseException {
                return Start();
        }

        public static void main(String args[])
        {
                boolean verbose = (args != null && args.length == 1 && "verbose".equals(args[0]));
                if(!verbose)System.out.println("Note: For verbose output type \"java Main verbose\".\n");
                System.out.print("COOL> ");
                Rete engine = new Rete();
                COOLParser p = new COOLParser(System.in);
                try
                {
                while (true)
                        {
                                COOLStart n = p.Start();
                                if (n==null) System.exit(0);
                                n.dump(" ");
                                System.out.println(n.getValue(engine).toString());
                        }
                }
                catch (Exception e)
                {
                        System.err.println("ERROR: " + e.getMessage());
                        if(verbose)e.printStackTrace();
                }
        }



}

PARSER_END(COOLParser)

/**********************************************
 * Lexical Specs
 */


SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
}

SPECIAL_TOKEN : /* COMMENTS */
{
  <SINGLE_LINE_COMMENT: ";" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
}

TOKEN :
{
  < LBRACE: "(" >
| < RBRACE: ")" >| < GE1: ">=" >
| < #DIGIT: ["0"-"9"] >
| < INTEGER: (["+","-"])? (<DIGIT>)+ >
|
  < FLOAT:
        (<DIGIT>)+ "." (<DIGIT>)* (<EXPONENT>)?
      | "." (<DIGIT>)+ (<EXPONENT>)?
      | (<DIGIT>)+ <EXPONENT>
  >
  
| < #EXPONENT: ["e","E"] (["+","-"])? (<DIGIT>)+ >
| < #GMT_OFFSET: ("+"|"-") ( <DIGIT> )? <DIGIT> >
| < #DATE: <DIGIT> <DIGIT> <DIGIT> <DIGIT> "-" <DIGIT> <DIGIT> "-" <DIGIT> <DIGIT> >
| < #TIME: <DIGIT> <DIGIT> ":" <DIGIT> <DIGIT> ( ":" <DIGIT> <DIGIT>)? >
| < DATETIME:  <DATE> ( " " <TIME> (<GMT_OFFSET>)? )? > 
|
  < STRING:
      ("\"" ((~["\"","\\"]) | ("\\" ( ["\\","\""] )))* "\"") |
      ("\'" ((~["\'","\\"]) | ("\\" ( ["\\","\'"] )))* "\'")
  >
| < INSTANCE: "[" <SYMBOL> "]">
| < SFWILDCARD: "?" >
| < MFWILDCARD: "$?" >
| < GLOBALVAR: "?*" <SYMBOL> "*" >
| < DEFFACTS: "deffacts" >
| < DEFTEMPLATE: "deftemplate" >
| < DEFTEMPLATE_CONSTRUCT: "deftemplate_construct" >
| < DEFRULE: "defrule" >
| < DEFFUNCTION: "deffunction" >
| < DEFGENERIC: "defgeneric" >
| < DEFMETHOD: "defmethod" >
| < DEFCLASS: "defclass" >
| < DEFMESSAGEHANDLER: "defmessage-handler" >
| < DEFINSTANCES: "definstances" >
| < DEFMODULE: "defmodule" >
| < DEFGLOBAL: "defglobal" >
| < DEFAULT_ATR: "default" >
| < DYNAMIC_ATR: "default-dynamic" >
| < ATR_DEFAULT: "?DEFAULT" >
| < ATR_DERIVE: "?DERIVE" >
| < ATR_NONE: "?NONE" >
| < ATR_ALL: "?ALL" >
| < SLOT: "slot" >
| < SINGLE_SLOT: "single-slot" >
| < MULTISLOT: "multislot" >
| < ARROW: "=>">
| < DECLARE: "declare" >
| < SALIENCE: "salience" >
| < AUTOFOCUS: "auto-focus" >
| < EXPORT: "export" >
| < IMPORT: "import" >
| <	TYPE: "type" >
| < TRUE: "TRUE" | "true" | "True" >
| < FALSE: "FALSE" | "false" | "False" >
| < NOT: "not" >
| < AND: "and" >
| < OR: "or" >
| < OF: "of" >
| < LOGICAL: "logical" >
| < TEST: "test" >
| < EXISTS: "exists" >
| < FORALL: "forall">
| < OBJECT: "object" >
| < IS_A: "is-a" >
//| < NAME: "name" >
| < ASSIGN: "<-" >
| < TILDE: "~" >
| < AMPERSAND: "&" >
| < LINE: "|" >
| < COLON: ":" >
| < EQUALS: "=" >
| < VARIABLE_TYPE: "?VARIABLE" >
| < SYMBOL_TYPE: "SYMBOL" >
| < STRING_TYPE: "STRING" >
| < DATETIME_TYPE: "DATETIME" >
| < LEXEME_TYPE: "LEXEME" >
| < INTEGER_TYPE: "INTEGER" >
| < FLOAT_TYPE: "FLOAT" >
| < NUMBER_TYPE: "NUMBER" >
| < INSTANCE_NAME_TYPE: "INSTANCE-NAME" >
| < INSTANCE_ADDRESS_TYPE: "INSTANCE-ADDRESS" >
| < INSTANCE_TYPE: "INSTANCE" >
| < EXTERNAL_ADDRESS_TYPE: "EXTERNAL-ADDRESS" >
| < FACT_ADDRESS_TYPE: "FACT-ADDRESS" >
| < ALLOWED_SYMBOLS: "allowed-symbols" >
| < ALLOWED_STRINGS: "allowed-strings" >
| < ALLOWED_LEXEMES: "allowed-lexemes" >
| < ALLOWED_INTEGERS: "allowed-integers" >
| < ALLOWED_FLOATS: "allowed-floats" >
| < ALLOWED_NUMBERS: "allowed-numbers" >
| < ALLOWED_INSTANCES: "allowed-instances" >
| < ALLOWED_CLASSES: "allowed-classes" >
| < ALLOWED_VALUES: "allowed-values" >
| < RANGE: "range" >
| < CARDINALITY: "cardinality" >
| < ROLE: "role" >
| < CONCRETE: "concrete" >
| < ABSTRACT: "abstract" >
| < PATTERN_MATCH: "pattern-match" >
| < REACTIVE: "reactive" >
| < NON_REACTIVE: "non-reactive" >
| < ACTIVE: "active" >
| < STORAGE: "storage" >
| < LOCAL: "local" >
| < SHARED: "shared" >
| < ACCESS: "access" >
| < READ_WRITE: "read-write" >
| < READ_ONLY: "read-only" >
| < READ: "read" >
| < WRITE: "write" >
| < INITIALIZE_ONLY: "initialize-only" >
| < PROPAGATION: "propagation" >
| < INHERIT: "inherit" >
| < NO_INHERIT: "no-inherit" >
| < SOURCE: "source" >
| < EXCLUSIVE: "exclusive" >
| < COMPOSITE: "composite" >
| < VISIBILITY: "visibility" >
| < PRIVATE: "private" >
| < PUBLIC: "public" >
| < CREATE_ACCESSOR: "create-accessor" >
| < OVERRIDE_MESSAGE: "override-message" >
| < MESSAGE_HANDLER: "message-handler" >
| < PRIMARY: "primary" >
| < AROUND: "around" >
| < BEFORE: "before" >
| < AFTER: "after" >
	// Special functions
| < ASSERT: "assert" >
| < RETRACT: "retract" >
| < MODIFY: "modify" >
| < DUPLICATE: "duplicate" >
| < FACT_RELATION: "fact-relation" >
| < FACT_SLOT_VALUE: "fact-slot-value" >
| < IF: "if" >
| < THEN: "then" >
| < ELSE: "else" >
| < WHILE: "while" >
| < DO: "do" >
| < LOOP_FOR_COUNT: "loop-for-count" >
| < SWITCH: "switch" >
| < CASE: "case" >
| < STAR: "*">
  // If you think this is ugly, you are right. See CLIPS Basic Progrmmers Guide:
  // "Numbers are symbols, but treated different. Instances are symbols, but treated different." 
| < #VARSYMBOL:  ["a"-"z","A"-"Z"] (~[" ","\r","\n","\t","\"","\'","(",")","&","|","<","~",";"])* >
| < SINGLEVAR: ("?" <VARSYMBOL>) >
| < MULTIVAR: ("$?" <VARSYMBOL>) >
| < SYMBOL:  
	(~[" ","\r","\n","\t","\"","\'","(",")","&","|","$","?","~",";","0"-"9","="])
	|(
		(~[" ","\r","\n","\t","\"","\'","(",")","&","|","$","?","~",";","[","="])
		(~[" ","\r","\n","\t","\"","\'","(",")","&","|","?","~",";","0"-"9"])*
		(~[" ","\r","\n","\t","\"","\'","(",")","&","|","<","~",";" ])*
		(~[" ","\r","\n","\t","\"","\'","(",")","&","|","$","?","~",";","]"])? 
	)
	|(
		(~[" ","\r","\n","\t","\"","\'","(",")","&","|","$","?","~",";","="])
		(~[" ","\r","\n","\t","\"","\'","(",")","&","|","?","~",";","0"-"9"])*
		(~[" ","\r","\n","\t","\"","\'","(",")","&","|","<","~",";" ])*
		(~[" ","\r","\n","\t","\"","\'","(",")","&","|","$","?","~",";","]"])+ 
	)
  >

}

/* TODO (From Clips Manual):
Data Types:
<file-name> ::= A symbol or string which is a valid file name (including path information)
	for the operating system under which CLIPS is running
<slot-name> ::= A valid deftemplate_construct slot name
<...-name> ::= A <symbol> where the ellipsis indicate what the symbol represents.
	For example, <rule-name> is a symbol which represents the name of a rule.
*/

/**********************************************
 * Cool Grammar Specs.
 */

/** Start rule is one construct at a time, Parser reads constructs into list.
	No need to create nodes for Start, Defcon and Funcon rule.*/
COOLStart Start() : {}
{
	
   ( LOOKAHEAD(2)
	Construct() | Expression()
	
	) { return jjtThis; }
	| <EOF> { return null; }
}


/*
<number> ::= <float> | <integer> 
<lexeme> ::= <symbol> | <string>
<constant> ::= <datetime> | <symbol> | <string> | <integer> | <float> | <instance-name>
*/


Node Float() : { Token t; }
{
	t=<FLOAT>
	{
		jjtThis.setName(t.image); 
		return jjtThis;
	}
}

Node Integer() : { Token t; }
{
	t=<INTEGER>
	{
		jjtThis.setName(t.image); 
		return jjtThis;
	}
}

Node DateTime() : { Token t; }
{
	t=<DATETIME>
	{
		jjtThis.setName(t.image);
		return jjtThis;
	}
}


Node Number() #void : { Node n; }
{	
	(	n=Float()
	|	n=Integer() 
	) { return n; }
}

Node Symbol() : { Token t;}
{
	t=<SYMBOL>
	{
		jjtThis.setName(t.image); 
		return jjtThis;
	}
}

Node String() : { Token t; }
{
	t=<STRING>
	{
		jjtThis.setName(ParserUtils.getStringLiteral(t.image)); 
		return jjtThis;
	}

}


Node Lexeme() #void : { Node n; }
{	
	(	n=String()
	|	n=Symbol() 
	) { return n; }
}

Node Instance() : { Token t; }
{
	t=<INSTANCE>
	{ 
		jjtThis.setName(t.image);
		return jjtThis;
	}
}

Node Constant() #void:{ Node n; }
{ 	
	(
		n=DateTime()
	|   n=Symbol()
	|	n=String()
	|	n=Integer()
	|	n=Float()
	|	n=Instance() 
	) { return n; }
}

void Comment() #void : {}
{	
    String()
}

/*
<function-name> ::= Any symbol which corresponds to a system or user defined function, a
	deffunction name, or a defgeneric name
	( Ory: I understand this to be a <SYMBOL> token )
<file-name> ::= A symbol or string which is a valid file name (including path information)
	for the operating system under which CLIPS is running

<variable> ::= <single-field-variable> | <multifield-variable> | <global-variable>
<function-call> ::= (<function-name> <expression>*)
<expression> ::= <constant> | <variable> | <function-call>
<action> ::= <expression>
*/

// This is used exactly then when only the variables value is needed
Node SingleVariable() : { Token t; } 
{
	t=<SINGLEVAR>
	{ jjtThis.setName(t.image); return jjtThis;}
}

// This is used exactly then when only the variables value is needed
Node GlobalVariable() : { Token t; } 
{
	t=<GLOBALVAR>
	{ jjtThis.setName(t.image); return jjtThis;}
}

// This is used exactly then when only the variables contents are needed
Node MultiVariable() : { Token t; } 
{
	t=<MULTIVAR>
	{ jjtThis.setName(t.image); return jjtThis;}
}

// This is used exactly then when only the variables value is needed
Node Variable() #void : { Node n; }
{	
	(	n=SingleVariable()
	|	n=MultiVariable()
	|	n=GlobalVariable() 
	) { return n;}
}

Node FunctionCall() #void : { Token t; Node n;}
{
	"(" (
		( n=AssertFunc() )
	|	( n=RetractFunc() )
	|	( n=IfElseFunc() )
	|	( n=AnyFunction() )
	) ")" { return n; }
}

Node AnyFunction() :{ Token t; }
{
	t=<SYMBOL> 
	{ jjtThis.setName(t.image); }
	(Expression())* 
	{ return jjtThis; }
}

Node Expression() #void : { Node n; } 
{	
	(	LOOKAHEAD(2)
		n=Constant()
	|	n=Variable()
	|	n=FunctionCall() 
	) { return n; }
}

////////////////////////////////////////////////////
// Special functions wich are defined by CLIPS to have
// a non-standart syntax (e.g. not all parameters are expressions)
Node AssertFunc() : {}
{
	<ASSERT>
	(RHSPattern())+
	{ return jjtThis; }
}

Node RetractFunc() : {}
{
	<RETRACT>
	(
		<STAR>	// Retract all
	|	(
			(Expression())*		// Integers and 'retract-specifiers' see BPG
		)
	)
//	RHSPattern()+
	{ return jjtThis; }
}

Node IfElseFunc() : { Node n;}
{
	<IF>
	Expression()
	<THEN>
	n=ActionList()
	[
		<ELSE>
		n=ActionList()
	]
	{ return jjtThis; }
}

Node WhileFunc() : {}
{
	<WHILE>
	Expression()
	[<DO>]
	ActionList()
	{ return jjtThis; }
}

Node LoopForCntFunc() : {}
{
	<LOOP_FOR_COUNT>
	(
		"("
		SingleVariable()
		[
			Expression() { /*End Index for node*/ }
		[ Expression() { /*End Index for node, move previous to start*/ } ]
		]
		")"
	)
	[<DO>]
	ActionList()
	{ return jjtThis; }
}

Node SwitchCaseFunc() : {}
{
	<SWITCH>
	Expression()	// Test Expression
	(	LOOKAHEAD(2)
		CaseStatement()
	)*
	([	
		"(" <DEFAULT_ATR> ActionList()
	])
	{ return jjtThis; }
}

void CaseStatement() : {}
{
	"(" 
		<CASE> 
		Expression()	// Comparison Expression
		<THEN> 
		ActionList()
	")"
}

/** Dummy Defined in CLIPS programmers guide... */
void Action() #void : {} {  Expression() }


/** Main Handler for Definition constructs.
	Note it contains the parantheses for the constructs
*/
void Construct() #void : {}
{
	"("
	( LOOKAHEAD(2)
		DeffactsConstruct()
	|	DeftemplateConstruct()
	|	DefglobalConstruct()
	|	DefruleConstruct()
	|	DeffunctionConstruct()
	|	DefgenericConstruct()
	|	DefmethodConstruct()
 	|	DefclassConstruct()
	|	DefmessageHandlerConstruct()
	|	DefinstancesConstruct()
	|	DefmoduleConstruct()
	)
	")"
}

/* Deffacts construct: 
	<deffacts-construct> ::= (deffacts <deffacts-name> [<comment>] <RHS-pattern>*) 
*/
void DeffactsConstruct() :{ Token t; }
{
      <DEFFACTS>
      t = <SYMBOL>
      { jjtThis.setName(t.image); }
      [
		t=<STRING>
		{ jjtThis.setDocString(ParserUtils.getStringLiteral(t.image)); }
	  ]
      (RHSPattern())*
}

/* Deftemplate construct
<deftemplate-construct> ::= (deftemplate <deftemplate-name> [<comment>] <slot-definition>*)
<slot-definition> ::= <single-slot-definition> | <multislot-definition> 
<single-slot-definition> ::= (slot <slot-name> <template-attribute>*)
<multislot-definition> ::= (multislot <slot-name> <template-attribute>*)
<template-attribute> ::= <default-attribute> | <constraint-attribute>
<default-attribute> ::= (default ?DERIVE | ?NONE | <expression>*) | (default-dynamic <expression>*)
*/
void DeftemplateConstruct() :{ Token t; AbstractSlot s;}
{
        <DEFTEMPLATE>
        t = <SYMBOL>
        { 
			jjtThis.setName(t.image); 
			deftemplates.add(t.image);
		}
	    [
			t=<STRING>
			{ jjtThis.setDocString(ParserUtils.getStringLiteral(t.image)); }
		]
        (
			s=SlotDefinition() { jjtThis.addSlot(s); }
        )*
}

//<slot-definition> ::= <single-slot-definition> | <multislot-definition>
AbstractSlot SlotDefinition() #void : { AbstractSlot ret;}
{
    ( 
		"(" ( ret=SingleSlotDefinition() | ret=MultislotDefinition() ) ")" 
    )	{ return ret; }
}

//<single-slot-definition> ::= (slot <slot-name> <template-attribute>*)
AbstractSlot SingleSlotDefinition() #void :
{ 
	Token t;
	TemplateSlot ts = new TemplateSlot();
}
{
	<SLOT>
	t = <SYMBOL>
	{ 
		ts.setName(t.image); //<slot-name>
	}
	(
		TemplateAttribute(ts)
	)*
	{ return ts; }
}

//<multislot-definition> ::= (multislot <slot-name> <template-attribute>*)
AbstractSlot MultislotDefinition() #void :
{ 
	Token t; 
	TemplateSlot ts = new TemplateSlot();
	ts.setMultiSlot(true);
}
{
        <MULTISLOT>
        t = <SYMBOL>
        { ts.setName(t.image); }//<slot-name>
        (
			TemplateAttribute(ts)
		)*
		{return ts;}
}

//<template-attribute> ::= <default-attribute> | <constraint-attribute>
void TemplateAttribute(TemplateSlot ts) #void : { }
{
	<LBRACE>
	(	LOOKAHEAD(2)
	    DefaultAttribute(ts) 
	| 	DynamicAttribute(ts)
	|	ConstraintAttribute(ts)
	) 
	<RBRACE>
}

// Create a dummy node to have a list of attributes
Node Attributes():{} 
{ 
	(	LOOKAHEAD(3)
		Expression()
	)+ 
	{ return jjtThis; }
}

//<default-attribute> ::= (default ?DERIVE | ?NONE | <expression>*) | (default-dynamic <expression>*)
void DefaultAttribute(TemplateSlot ts) #void : { Node n;}
{
		<DEFAULT_ATR>
		(	
			<ATR_DERIVE> { ts.setDefaultDerive(); }
		|	<ATR_NONE> // { ts.setDefaultNone(); }
		|	n=Attributes() { ts.setStaticDefaultExpression(n); }
		)
}



void DynamicAttribute(TemplateSlot ts) #void : { Node n;}
{
	<DYNAMIC_ATR> 
	(	
		n=Attributes() { ts.setDynamicDefaultExpression(n); }
	)
}

/* Fact Specification
<RHS-pattern> ::= <ordered-RHS-pattern> | <template-RHS-pattern>
<ordered-RHS-pattern> ::= (<symbol> <RHS-field>+)
<template-RHS-pattern> ::= (<deftemplate-name> <RHS-slot>*)
<RHS-slot> ::= <single-field-RHS-slot> | <multifield-RHS-slot>
<single-field-RHS-slot> ::= (<slot-name> <RHS-field>)
<multifield-RHS-slot> ::= (<slot-name> <RHS-field>*)
<RHS-field> ::= <variable> | <constant> | <function-call>
*/
void RHSPattern() #void : { Token t; }
{ 
	"("
	t = <SYMBOL>
	{
		if (deftemplates.contains(t.image)) TemplateRHSPattern(t.image);
		else OrderedRHSPattern(t.image);
	}
    ")" 
    
}

//<ordered-RHS-pattern> ::= (<symbol> <RHS-field>+)
Fact OrderedRHSPattern(String name) : { jjtThis.setName(name);  }
{
    (  Expression() )*	// CLIPS user guide says (assert (duck)) is legal, so does CLIPS interpreter!!
}

//<template-RHS-pattern> ::= (<deftemplate-name> <RHS-slot>*)
void TemplateRHSPattern(String name) :{  jjtThis.setName(name); }
{
        (RHSSlot())*
}

//<RHS-slot> ::= <single-field-RHS-slot> | <multifield-RHS-slot>
//<single-field-RHS-slot> ::= (<slot-name> <RHS-field>)
//<multifield-RHS-slot> ::= (<slot-name> <RHS-field>*)
void RHSSlot() : { Token t; }
{
    "(" 
        t = <SYMBOL>
        { jjtThis.setName(t.image); }	// slot-name
        (Expression())*
    ")"
}

//<RHS-field> ::= <variable> | <constant> | <function-call>
// Same as expression
/*void RHSField() #void : {}
{
    Variable() | Constant() | FunctionCall()
}*/

/* Defrule Construct
<defrule-construct> 
	::= (defrule <rule-name> [<comment>] [<declaration>] <conditional-element>* => <action>*) 
<declaration> ::= (declare <rule-property>+)
<rule-property> ::= (salience <integer-expression>) | (auto-focus <boolean-symbol>)
<boolean-symbol> ::= TRUE | FALSE
<conditional-element> ::= <pattern-CE> | <assigned-pattern-CE> | <not-CE> | <and-CE> | <or-CE> |
	<logical-CE> | <test-CE> | <exists-CE> | <forall-CE>
<pattern-CE> ::= <ordered-pattern-CE> | <template-pattern-CE> | <object-pattern-CE>
<assigned-pattern-CE> ::= <single-field-variable> <- <pattern-CE>
<not-CE> ::= (not <conditional-element>)
<and-CE> ::= (and <conditional-element>+)
<or-CE> ::= (or <conditional-element>+)
<logical-CE> ::= (logical <conditional-element>+)
<test-CE> ::= (test <function-call>)
<exists-CE> ::= (exists <conditional-element>+)
<forall-CE> ::= (forall <conditional-element> <conditional-element>+)
<ordered-pattern-CE> ::= (<symbol> <constraint>*)
<template-pattern-CE> ::= (<deftemplate-name> <LHS-slot>*)
<object-pattern-CE> ::= (object <attribute-constraint>*)
<attribute-constraint> ::= (is-a <constraint>) | (name <constraint>) | (<slot-name> <constraint>*)
<LHS-slot> ::= <single-field-LHS-slot> | <multifield-LHS-slot>
<single-field-LHS-slot> ::= (<slot-name> <constraint>)
<multifield-LHS-slot> ::= (<slot-name> <constraint>*)
<constraint> ::= ? | $? | <connected-constraint>
<connected-constraint>::= <single-constraint> | <single-constraint> & <connected-constraint> |
	<single-constraint> | <connected-constraint>
<single-constraint> ::= <term> | ~<term>
<term> ::= <constant> | <single-field-variable> | <multifield-variable> | 
	:<function-call> | =<function-call>
*/
void DefruleConstruct() :{ Token t; Node n; Condition ce; }
{
  ( <DEFRULE>
	t=<SYMBOL>
	{ jjtThis.setName(t.image); }//name
	[ t=<STRING> { jjtThis.setDocString(ParserUtils.getStringLiteral(t.image)); }	]
	( LOOKAHEAD(3)
		(
			Declaration(jjtThis)
			(
				ce=ConditionalElement()
								{  jjtThis.addCondition(ce); }
			)* 
		) |
		(
			(
				ce=ConditionalElement()
				{  jjtThis.addCondition(ce); }
			)* 
		)
	)
	<ARROW>
	n=ActionList() { jjtThis.setRuleActions(n); }
  )
}

////////////////////////////
// Conditional elements should not produce nodes, 
// but conditions as in package org.jamocha.rule

// Create Dummy node to have fixed number of chlidren in Defrule
/*Node CEList():{} 
{ 
	(ConditionalElement())* {}
	{ return jjtThis; }
}
*/

// Create Dummy node to have fixed number of children in Defrule
Node ActionList():{} 
{ 
	(	LOOKAHEAD(2)
		Expression()
	)* 
	{ return jjtThis; }
}


/*
// Create Dummy node to have fixed number of children later
Node CEList2():{} 
{ 
	(ConditionalElement())+ 
	{ return jjtThis; }
}
*/

//<declaration> ::= (declare <rule-property>+)
void Declaration(COOLDefruleConstruct r) #void : {}
{
    "("
        <DECLARE>
        (RuleProperty(r))+
    ")"
}

//<rule-property> ::= (salience <integer-expression>) | (auto-focus <boolean-symbol>)
void RuleProperty(COOLDefruleConstruct r) #void: { Node n; }
{
    "(" (
		(  <SALIENCE>
			//todo:        <integer-expression>
			// Ory: Just use expression and check for it being an integer at runtime (it could use global variables)
			// Need to determine salience at runtime!!
			n=Expression() { r.setSalienceExpression(n); }
		)
		{ // Set node type to salience, 
		}
     | (	<AUTOFOCUS> 
		(	<TRUE> { r.setAutoFocus(true); }
		|	<FALSE> { r.setAutoFocus(false); } 
		)
	)) ")"
}

//<boolean-symbol> ::= TRUE | FALSE
void BooleanSymbol() : { Token t;}
{
    ( t=<TRUE> ) { jjtThis.setName(t.image); jjtThis.setToTrue();}
    |
    ( t=<FALSE> ) { jjtThis.setName(t.image); jjtThis.setToFalse(); }
}

//<conditional-element> ::= <pattern-CE> | <assigned-pattern-CE> | <not-CE> | <and-CE> | <or-CE> |
//                          <logical-CE> | <test-CE> | <exists-CE> | <forall-CE>
Condition ConditionalElement() #void : { Condition ce; }
{
	"(" 
		(
			ce=PatternCE() 
		|	ce=AssignedPatternCE() 
		|	ce=BooleanFunction() 
		|	ce=LogicalCE() 
		|	ce=TestCE()
		|	ce=ExistsCE()
		|	ce=ForallCE()
		)
	")"
	{ return ce; }	
}

// Create and return conditions
Condition BooleanFunction() #void : { Condition ce=null,child; }
{
	(	(	// Unary operators
			// No not condition and no condition negation ==> can't implement yet
			<NOT> {  }
			child=ConditionalElement() { /*not_ce.addNestedConditionElement(child);*/ }
		)
	|	(	// non-Unary operators
			(
				<AND> { ce=new AndCondition(); }
      			(
					child=ConditionalElement() { /*and_ce.addNestedConditionElement(child); */} 
				)+
			)
		|	(	// No Or condition and no condition negation ==> can't implement yet
				<OR> { ce=new AndCondition(); }
      			(
					child=ConditionalElement() { /*or_ce.addNestedConditionElement(child); */ } 
				)+
			) 
		)
	)	{ return ce; }
		
}

//<pattern-CE> ::= <ordered-pattern-CE> | <template-pattern-CE> | <object-pattern-CE>
// Create and return conditions
Condition  PatternCE() #void : { Condition ce;}
{
	( LOOKAHEAD(2) 
		ce=OrderedPatternCE() 
	|	ce=TemplatePatternCE() 
	|	ce=ObjectPatternCE() 
	) { return ce; }
}

//<assigned-pattern-CE> ::= <single-field-variable> <- <pattern-CE>
// Create and return conditions 	--	NOT IMPLEMENTED!!
Condition AssignedPatternCE() #void : {}
{
	(
		SingleVariable() 
		<ASSIGN>
		PatternCE()
    ) { return null; }
}


//<logical-CE> ::= (logical <conditional-element>+)
// Create and return conditions	--	NOT IMPLEMENTED!!
Condition LogicalCE() #void : {}
{
    <LOGICAL> 
    (
		ConditionalElement()
    )+ 
    { return null; }
}

//<test-CE> ::= (test <function-call>)
// Create and return conditions (needs to initialize function 
// before execution, thus it gets a node
Condition TestCE() : { TestCondition ce=new TestCondition(); Token t;}
{
    ( 
		<TEST>
		t=<SYMBOL> { jjtThis.setName(t.image); jjtThis.setCondition(ce); }
	) { return ce; }
}

//<exists-CE> ::= (exists <conditional-element>+)
// Create and return conditions
Condition ExistsCE() #void : 
{
	Condition child;
	ExistCondition ce=new ExistCondition();
}
{
    <EXISTS> 
    (
		child=ConditionalElement() { ce.addNestedConditionElement(child); }
    )+
    { return ce; }
}

//<forall-CE> ::= (forall <conditional-element> <conditional-element>+)
// Create and return conditions	--	NOT IMPLEMENTED!!
Condition ForallCE() #void : {}
{
	(	<FORALL> 
	ConditionalElement() 
	(ConditionalElement())+
	)	{return null; }
}

// TODO finish 
//<ordered-pattern-CE> ::= (<symbol> <constraint>*)
Condition OrderedPatternCE() #void: 
{ 	
	Token t; 
	Condition ce=null;	// NOT IMPLEMENTED
}
{
        (	
			t=<SYMBOL>
//			{ jjtThis.setName(t.image); }
			(Constraint())*
		)	{ return null; }
}

// TODO finish 
//<template-pattern-CE> ::= (<deftemplate-name> <LHS-slot>*)
Condition TemplatePatternCE() #void: 
{ 
	Token t; 
	Condition ce=null;
}
{
		(
			t=<SYMBOL>
			{  }	//deftemplate-name
			(LHSSlot())*
        )	{ return null; }
}

//<object-pattern-CE> ::= (object <attribute-constraint>*)
// Create and return conditions (use exist condition!!)
Condition ObjectPatternCE() #void : 
{ 
	ObjectCondition ce=new ObjectCondition();
	Constraint c;
}
{
        (	<OBJECT>
        (
			c=AttributeConstraint() 
			{ ce.addConstraint(c); }
		)*
		)	{ return ce; }
}

//<attribute-constraint> ::= (is-a <constraint>) | (name <constraint>) | (<slot-name> <constraint>*)
// Create and return conditions (Are these implemented??)
Constraint AttributeConstraint()  #void :
{ 
	Token t;
	Constraint c=null;
}
{
    "("
		(
			t=<SYMBOL> 
			{  
				// compare symbol to fixed strings, because 'name' can be 
				// used as slot name according to CLIPS user guide
			}
			(Constraint())* 
		)
    ")" { return c; }
}

// Functionally identical !?
//<single-field-LHS-slot> ::= (<slot-name> <constraint>)
//<multifield-LHS-slot> ::= (<slot-name> <constraint>*)
//<LHS-slot> ::= <single-field-LHS-slot> | <multifield-LHS-slot>
void LHSSlot()  : { Token t; }
{
        t=<SYMBOL>
        { jjtThis.setName(t.image); }	//slot-name
		( LOOKAHEAD(2)
			Constraint()
		)*

}

//<constraint> ::= ? | $? | <connected-constraint>
void Constraint() #void : {}
{
    SingleFieldWildcard() | MultiFieldWildcard() | ConnectedConstraint()
}

void SingleFieldWildcard() : {} { <SFWILDCARD> }
void MultiFieldWildcard() : {} { <MFWILDCARD> }

//<connected-constraint>::= <single-constraint> | <single-constraint> & <connected-constraint> |
//	<single-constraint> | <connected-constraint>

// THIS IS WRONG: Ampersands and lines can be mixed!!
void ConnectedConstraint() : {}
{
		Term() 
	[ 
		( <AMPERSAND> ConnectedConstraint() { jjtThis.setTypeAnd(); } )
	|	( <LINE> ConnectedConstraint() { jjtThis.setTypeOr(); } )
	]
}

//<term> ::= <constant> | <single-field-variable> | <multifield-variable> | 
//	:<function-call> | =<function-call>
void Term()  : {}
{
	[	<TILDE>	{ jjtThis.setNegate(true); }
	] 
    ( LOOKAHEAD(3)
		Constant() { jjtThis.setType(COOLTerm.T_CONST); }
    |	SingleVariable() { jjtThis.setType(COOLTerm.T_SINGLE); }
    |	MultiVariable() { jjtThis.setType(COOLTerm.T_MULTI); }
    |	(<COLON> FunctionCall() ) { jjtThis.setType(COOLTerm.T_COLON); }
    |	(<EQUALS> FunctionCall() ) { jjtThis.setType(COOLTerm.T_EQ); } 
    )
}

/* Defglobal Construct
<defglobal-construct> ::= (defglobal [<defmodule-name>] <global-assignment>*)
<global-assignment> ::= <global-variable> = <expression>
<global-variable> ::= ?*<symbol>*
*/

//<defglobal-construct> ::= (defglobal [<defmodule-name>] <global-assignment>*)
void DefglobalConstruct()  :{ Token t; }
{
        <DEFGLOBAL>
        [ 
            t=<SYMBOL>
            { jjtThis.setName(t.image); }	//defmodule-name 
        ]
        (GlobalAssignment())*
}

//<global-assignment> ::= <global-variable> = <expression>
void GlobalAssignment()  : { Token t; }
{
	t=<GLOBALVAR>
	{ jjtThis.setName(t.image); }	// Needs to access variable to set, can not use variable node
    <EQUALS>
    Expression()
}

/* Deffunction Construct
<deffunction-construct> 
	::= (deffunction <name> [<comment>] (<regular-parameter>* [<wildcard-parameter>]) <action>*)
<regular-parameter> ::= <single-field-variable>
<wildcard-parameter> ::= <multifield-variable>
*/

//<deffunction-construct> 
//	::= (deffunction <name> [<comment>] (<regular-parameter>* [<wildcard-parameter>]) <action>*)
void DeffunctionConstruct()  :
{ 
	Token t; 
	Node n; 
	ArrayList list = new ArrayList();
}
{
        <DEFFUNCTION>
        t=<SYMBOL>
        { jjtThis.setName(t.image); jjtThis.hasMultiVars(false);}//name
        [ t=<STRING> 
			{ jjtThis.setDocString(ParserUtils.getStringLiteral(t.image)); }
        ]
        "(" 
            (
				t=<SINGLEVAR>	{ list.add(t.image); }	// Should add strings or such to a java list here
			)*

			[ 
				t=<MULTIVAR> 
				{list.add(t.image); jjtThis.hasMultiVars(true);}
			] 
        ")"
        n=ActionList()
        { 
			jjtThis.SetFunctionParams(list);
			jjtThis.setFunctionActions(n); 
		}
}


/* Ignored, produces multifield variable directly
//<wildcard-parameter> ::= <multifield-variable>
void WildcardParameter()  #void : {}
{
    <MULTIVAR>
}
*/

/* Defgeneric Construct
<defgeneric-construct> ::= (defgeneric <name> [<comment>])
*/
void DefgenericConstruct()  :{ Token t; }
{
        <DEFGENERIC>
        t=<SYMBOL>
        { jjtThis.setName(t.image); }	//name
        [ t=<STRING>
			{ jjtThis.setDocString(ParserUtils.getStringLiteral(t.image)); }
        ]
}

/* Defmethod Construct
<defmethod-construct> ::= (defmethod <name> [<index>] [<comment>] (<parameter-restriction>*
	[<wildcard-parameter-restriction>]) <action>*)
<parameter-restriction> ::= <single-field-variable> | (<single-field-variable> <type>* [<query>])
<wildcard-parameter-restriction> ::= <multifield-variable> | (<multifield-variable> <type>* [<query>])
<type> ::= <class-name>
<query> ::= <global-variable> | <function-call>
*/

/////////////////////////////////////

void DefmethodConstruct() : { Token t; }
{
	<DEFMETHOD>
	t = <SYMBOL>
	{ jjtThis.setName(t.image); }//name
	([
		t = <INTEGER>
		{ jjtThis.setIndex(t.image); }//method index (cf. clipsbasic programmers guide section 8.4.2)
	])
	([
		t = <STRING>
		{ jjtThis.setDocString(ParserUtils.getStringLiteral(t.image)); }//comment
	])
	(
		<LBRACE>
			(	LOOKAHEAD(2)
				ParameterRestriction()
			)*
			[ WildcardParameterRestriction() ]
		<RBRACE>
	)
	// This should be the nodes only subtree
    ActionList()
}

//<parameter-restriction> ::= <single-field-variable> | (<single-field-variable> <type>* [<query>])
void ParameterRestriction() : {}
{
	( LOOKAHEAD(2)
		(
			<SINGLEVAR>
		) |
		(
			<LBRACE>
				<SINGLEVAR> 
				(Type())* 
				[Query()]
			<RBRACE>
		)
	)
}

//<wildcard-parameter-restriction> ::= <multifield-variable> | (<multifield-variable> <type>* [<query>])
void WildcardParameterRestriction() : {}
{
	( LOOKAHEAD(2)
		(
			<MULTIVAR>
		) |
		(
			<LBRACE>
				<MULTIVAR> 
				(Type())* 
				[Query()]
			<RBRACE>
		)
	)
}

//<type> ::= <class-name>
void Type() : { Token t; }
{
	t = <SYMBOL>
	{ jjtThis.setName(t.image); }//class-name
}

//<query> ::= <global-variable> | <function-call>
void Query() : { Token t; }
{
		GlobalVariable()
	|	FunctionCall()
}

/*	Defclass Construct
<defclass-construct> ::= (defclass <name> [<comment>] (is-a <superclass-name>+)
	[<role>] [<pattern-match-role>] <slot>* <handler-documentation>*)
<role> ::= (role concrete | abstract)
<pattern-match-role> ::= (pattern-match reactive | non-reactive)
<slot> ::= (slot <name> <facet>*) | (single-slot <name> <facet>*) | (multislot <name> <facet>*)
<facet> ::= <default-facet> | <storage-facet> | <access-facet> | <propagation-facet> | 
	<source-facet> | <pattern-match-facet> | <visibility-facet> | 
	<create-accessor-facet> <override-message-facet> | <constraint-attribute>
<default-facet> ::= (default ?DERIVE | ?NONE | <expression>*) | (default-dynamic <expression>*)
<storage-facet> ::= (storage local | shared) 
<access-facet> ::= (access read-write | read-only | initialize-only) 
<propagation-facet> ::= (propagation inherit | no-inherit)
<source-facet> ::= (source exclusive | composite)
<pattern-match-facet> ::= (pattern-match reactive | non-reactive)
<visibility-facet> ::= (visibility private | public)
<create-accessor-facet> ::= (create-accessor ?NONE | read | write | read-write)
<override-message-facet> ::= (override-message ?DEFAULT | <message-name>)
<handler-documentation> ::= (message-handler <name> [<handler-type>])
<handler-type> ::= primary | around | before | after
*/
//<defclass-construct> ::= (defclass <name> [<comment>] (is-a <superclass-name>+)
//	[<role>] [<pattern-match-role>] <slot>* <handler-documentation>*)
void DefclassConstruct() : { Token t; }
{
	<DEFCLASS>
	t = <SYMBOL>
	{ jjtThis.setName(t.image); }//name
	[
		t = <STRING>
		{ jjtThis.setDocString(ParserUtils.getStringLiteral(t.image)); }//comment
	]
	<LBRACE>
		<IS_A>
		(
			t = <SYMBOL>
		)+
	<RBRACE>
	[ LOOKAHEAD(2) Role(jjtThis) ]
	[ LOOKAHEAD(2) PatternMatchRole(jjtThis) ]
	( LOOKAHEAD(2) Slot() )*
	( LOOKAHEAD(2) HandlerDocumentation() )*
}


// JUST SET ATTRIBUTE
//<role> ::= (role concrete | abstract)
void Role(COOLDefclassConstruct c) #void : {}
{
	<LBRACE>
		<ROLE> 
		(	<CONCRETE> { c.setConcrete(); }
		|	<ABSTRACT> { c.setAbstract(); }
		)
	<RBRACE>
}

// JUST SET ATTRIBUTE
//<pattern-match-role> ::= (pattern-match reactive | non-reactive)
void PatternMatchRole(COOLDefclassConstruct c) #void : {}
{
	<LBRACE>
		<PATTERN_MATCH> 
		(	<REACTIVE> { c.setReactive(); }
		|	<NON_REACTIVE> { c.setNonReactive(); }
		)
	<RBRACE>
}


// JUST SET RULE ATTRIBUTE?
//<slot> ::= (slot <name> <facet>*) | (single-slot <name> <facet>*) | (multislot <name> <facet>*)
TemplateSlot Slot() #void : { Token t; TemplateSlot ts=new TemplateSlot();}
{
	<LBRACE>
		(
			<SLOT> { ts.setMultiSlot(false); }
		|	<SINGLE_SLOT> { ts.setMultiSlot(false); }
		|	<MULTISLOT> { ts.setMultiSlot(true); }
		)
		t = <SYMBOL>
		{ 
		 	ts.setName(t.image);
		}
		( Facet(ts) )*
	<RBRACE>
	{ return ts; }
}

//<facet> ::= <default-facet> | <storage-facet> | <access-facet> | <propagation-facet> | 
//	<source-facet> | <pattern-match-facet> | <visibility-facet> | 
//	<create-accessor-facet> <override-message-facet> | <constraint-attribute>
void Facet(TemplateSlot ts) #void : {}
{
	<LBRACE> 			// facets all have brackets
		( LOOKAHEAD(2)
			DefaultFacet(ts)
		| 	StorageFacet(ts)
		|	AccessFacet(ts)
		|	PropagationFacet(ts)
		|	SourceFacet(ts)
		|	PatternMatchFacet(ts)
		|	VisibilityFacet(ts)
		|	CreateAccessorFacet(ts)
		|	OverrideMessageFacet(ts)
		|	ConstraintAttribute(ts)
		)
	<RBRACE>
}

//<default-facet> ::= (default ?DERIVE | ?NONE | <expression>*) | (default-dynamic <expression>*)
void DefaultFacet(TemplateSlot ts) #void : { Node n; }
{
	( 	<DEFAULT_ATR>
		(	<ATR_DERIVE> { ts.setDefaultDerive(); }
		|	<ATR_NONE> // { ts.setDefaultNone(); }
		|   n=Attributes() { ts.setStaticDefaultExpression(n); }
		) 
	) 
	|	
	( 	
		<DYNAMIC_ATR> 
		n=Attributes() { ts.setDynamicDefaultExpression(n); }
	)
}


// JUST SET RULE ATTRIBUTE
//<storage-facet> ::= (storage local | shared)
void StorageFacet(TemplateSlot ts) #void  : {}
{
	<STORAGE> 
	(	<LOCAL>  			// { ts.setStorageLocal(true); }
	|	<SHARED> 			// { ts.setStorageLocal(false); }
	)
}
	

// JUST SET RULE ATTRIBUTE
//<access-facet> ::= (access read-write | read-only | initialize-only)
void AccessFacet(TemplateSlot ts) #void : {}
{
	<ACCESS> 
	(	<READ_WRITE>		// { ts.setAccessReadWrite(); }
	|	<READ_ONLY>			// { ts.setAccessRead(); }
	|	<INITIALIZE_ONLY> 	// { ts.setAccessInitialize(); }
	)
}


// JUST SET ATTRIBUTE
//<propagation-facet> ::= (propagation inherit | no-inherit)
void PropagationFacet(TemplateSlot ts) #void : {}
{
	<PROPAGATION> 
	(	<INHERIT> 			// { ts.setInherit(true); }
	| 	<NO_INHERIT> 		// { ts.setInherit(false); }
	)
}


// JUST SET ATTRIBUTE
//<source-facet> ::= (source exclusive | composite)
void SourceFacet(TemplateSlot ts) #void : {}
{
	<SOURCE> <EXCLUSIVE> | <COMPOSITE>
}


// JUST SET ATTRIBUTE
//<pattern-match-facet> ::= (pattern-match reactive | non-reactive)
void PatternMatchFacet(TemplateSlot ts)  #void : {}
{
	<PATTERN_MATCH> 
	(	<REACTIVE> 				// { ts.setMatchReactive(true); }
	|	<NON_REACTIVE> 			// { ts.setMatchReactive(false); }
	)
}


// JUST SET RULE ATTRIBUTE
//<visibility-facet> ::= (visibility private | public)
void VisibilityFacet(TemplateSlot ts) #void : {}
{
	<VISIBILITY> 
	(	<PRIVATE> 				// { ts.setPublic(false); }
	|	<PUBLIC> 				// { ts.setPublic(true); }
	)
}


// JUST SET RULE ATTRIBUTE
//<create-accessor-facet> ::= (create-accessor ?NONE | read | write | read-write)
void CreateAccessorFacet(TemplateSlot ts) #void : {}
{
	<CREATE_ACCESSOR> 
	(	<ATR_NONE> 
	|	<READ> 
	|	<WRITE> 
	|	<READ_WRITE>
	)
}


// JUST SET RULE ATTRIBUTE
//<override-message-facet> ::= (override-message ?DEFAULT | <message-name>)
void OverrideMessageFacet(TemplateSlot ts) #void : { Token t; }
{
	<OVERRIDE_MESSAGE> 
	(	<ATR_DEFAULT> 			// { ts.setMessageDefault(); }
	|	t = <STRING> 			// { ts.setMessageName(ParserUtils.getStringLiteral(t.image)); }
	)
}


//<handler-documentation> ::= (message-handler <name> [<handler-type>])
void HandlerDocumentation() #void : { Token t; int i=-1; }
{
	(
		<MESSAGE_HANDLER>
		t = <SYMBOL>
		[ i=HandlerType() ]
	) 
	
}

// JUST RETURN TYPE
//<handler-type> ::= primary | around | before | after
int HandlerType() #void : { int i=-1; }
{
	(	<PRIMARY>	{ i=0; }
	|	<AROUND>	{ i=1; }
	|	<BEFORE>	{ i=2; }
	|	<AFTER>		{ i=3; }
	)
	{ return i; }
}

/* 	Defmessage-handler Construct
	<defmessage-handler-construct> 
		::= (defmessage-handler <class-name> <message-name> [<handler-type>] 
			[<comment>] (<parameter>* [<wildcard-parameter>]) <action>*)
	<handler-type> ::= around | before | primary | after
	<parameter> ::= <single-field-variable>
	<wildcard-parameter> ::= <multifield-variable>
*/

//<defmessage-handler-construct> 
//	::= (defmessage-handler <class-name> <message-name> [<handler-type>] 
//		[<comment>] (<parameter>* [<wildcard-parameter>]) <action>*)
void DefmessageHandlerConstruct() : { Token t; }
{
	<DEFMESSAGEHANDLER>
	t = <SYMBOL>
	{ jjtThis.setClassName(t.image); }//name
	t = <SYMBOL>
	{ jjtThis.setName(t.image); }//name 2
	[ HandlerType() ]
	[
		t = <STRING>
		{ jjtThis.setDocString(ParserUtils.getStringLiteral(t.image)); }//comment
	]
	<LBRACE>
		(SingleVariable())* //parameter
		[MultiVariable()]
	<RBRACE>
	(ActionList())
}

/*	Definstances Construct
	<definstances-construct> ::= (definstances <definstances-name> [active] [<comment>] <instance-template>*)
	<instance-template> ::= (<instance-definition>)
	<instance-definition> ::= <instance-name-expression> of <class-name-expression> <slot-override>*
	<slot-override> ::= (<slot-name-expression> <expression>*)
*/

//<definstances-construct> ::= (definstances <definstances-name> [active] [<comment>] <instance-template>*)
void DefinstancesConstruct() : { Token t; }
{
	<DEFINSTANCES>
	t = <SYMBOL>
	{ jjtThis.setName(t.image); }//name
	[ <ACTIVE> ]
	[
		t = <STRING>
		{ jjtThis.setDocString(ParserUtils.getStringLiteral(t.image)); }//comment
	]
	(LOOKAHEAD(2) InstanceTemplate())*
}

//<instance-template> ::= (<instance-definition>)
void InstanceTemplate() #void : {}
{
	<LBRACE>
		InstanceDefinition()
	<RBRACE>
}

//<instance-definition> ::= <instance-name-expression> of <class-name-expression> <slot-override>*
void InstanceDefinition() #void : { Token t; }
{
	// Should have two expressions returning the correct types, not symbols!!
	t = <SYMBOL>
//	{ jjtThis.setCLIPSName(t.image); }//instance-name
	<OF>
	t = <SYMBOL>
//	{ jjtThis.setCLIPSName2(t.image); }//class-name
	(SlotOverride())*
}

//<slot-override> ::= (<slot-name-expression> <expression>*)
void SlotOverride() #void : { Token t; }
{
	<LBRACE>
	t = <SYMBOL>	// Should be an expression returning a slot name
//	{ jjtThis.setName(t.image); }//slot-name
	ActionList()
	<RBRACE>
}

/*	Defmodule Construct
	<defmodule-construct> ::= (defmodule <module-name> [<comment>] <port-specification>*)
	<port-specification> ::= (export <port-item>) | (import <module-name> <port-item>)
	<port-item> ::= ?ALL | ?NONE | <port-construct> ?ALL | 
		<port-construct> ?NONE | <port-construct> <construct-name>+
	<port-construct> ::= deftemplate_construct | defclass | defglobal | deffunction | defgeneric
*/

//<defmodule-construct> ::= (defmodule <module-name> [<comment>] <port-specification>*)
void DefmoduleConstruct() : { Token t; }
{
	<DEFMODULE>
	t = <SYMBOL>
	{ jjtThis.setName(t.image); }//name
	[
		t = <SYMBOL>
		{ jjtThis.setDocString(t.image); }//comment
	]
	(PortSpecification())*
}

//<port-specification> ::= (export <port-item>) | (import <module-name> <port-item>)
void PortSpecification() : { Token t; }
{
	<LBRACE>
	(
		<EXPORT>
		PortItem()
	) |
	(
		<IMPORT>
		t = <SYMBOL>
		{ jjtThis.setName(t.image); }//name
		PortItem()
	)
	<RBRACE>
}

//			(
//				t = <SYMBOL>
//				{ jjtThis.addCLIPSPortname(t.image); }
//			)+

//<port-item> ::= ?ALL | ?NONE | <port-construct> ?ALL | 
//	<port-construct> ?NONE | <port-construct> <construct-name>+
void PortItem() : { Token t; }
{
	(	<ATR_ALL> 
	| 	<ATR_NONE> 
	| 	( 
			PortConstruct() 
			(	<ATR_ALL> 
			|	<ATR_NONE> 
			|	(ConstructName())*
			)
		)
	)
}

void ConstructName() : { Token t;}
{
	(	t=<SYMBOL> 
	|	t=<INSTANCE> 
	) { jjtThis.setName(t.image); }
}

//<port-construct> ::= deftemplate_construct | defclass | defglobal | deffunction | defgeneric
void PortConstruct() #void : {}
{
	( LOOKAHEAD(2) <DEFTEMPLATE_CONSTRUCT> | <DEFCLASS> | <DEFGLOBAL> | <DEFFUNCTION> | <DEFGENERIC> )
}

/* constraint Attributes */

//<constraint-attribute> ::= <type-attribute> | <allowed-constant-attribute> | 
//	<range-attribute> | <cardinality-attribute>
void ConstraintAttribute(TemplateSlot ts) #void : { }
{
	( LOOKAHEAD(2)
		TypeAttribute(ts)
	|	AllowedConstantAttribute()
	|	RangeAttribute()
	|	CardinalityAttribute()
	)
}

//<type-attribute> ::= (type <type-specification>)
void TypeAttribute(TemplateSlot ts) #void : { }
{
	<TYPE> TypeSpecification(ts)
}

///////////////////
// Use EnumSets here

//<type-specification> ::= <allowed-type>+ | ?VARIABLE
void TypeSpecification(TemplateSlot ts)  #void : {}
{
	(AllowedType(ts))+ | <VARIABLE_TYPE>
}

//<allowed-type> ::= SYMBOL | STRING | LEXEME | INTEGER | FLOAT | NUMBER |
//	INSTANCE-NAME | INSTANCE-ADDRESS | INSTANCE | EXTERNAL-ADDRESS | FACT-ADDRESS | DATETIME
void AllowedType(TemplateSlot ts)  #void : {}
{
	(	<SYMBOL_TYPE> { ts.setValueType(JamochaType.IDENTIFIER); }
	|	<STRING_TYPE> { ts.setValueType(JamochaType.STRING); }
	|	<DATETIME_TYPE>	{ ts.setValueType(JamochaType.DATETIME); }
	|	<LEXEME_TYPE> { ts.setValueType(JamochaType.IDENTIFIER); }
	| 	<INTEGER_TYPE> { ts.setValueType(JamochaType.LONG); }
	| 	<FLOAT_TYPE> { ts.setValueType(JamochaType.DOUBLE); }
	|	<NUMBER_TYPE> { ts.setValueType(JamochaType.DOUBLE); }
	|	<INSTANCE_NAME_TYPE> { ts.setValueType(JamochaType.UNDEFINED); }
	| 	<INSTANCE_ADDRESS_TYPE> { ts.setValueType(JamochaType.UNDEFINED); }
	|	<INSTANCE_TYPE> { ts.setValueType(JamochaType.UNDEFINED); }
	|	<EXTERNAL_ADDRESS_TYPE> { ts.setValueType(JamochaType.UNDEFINED); }
	|	<FACT_ADDRESS_TYPE> { ts.setValueType(JamochaType.FACT_ID); }
	|   <DATETIME> { ts.setValueType(JamochaType.DATETIME); }
	)
}

// <allowed-constant-attribute> ::= (allowed-symbols <symbol-list>) | (allowed-strings <string-list>) |
//	(allowed-lexemes <lexeme-list> | (allowed-integers <integer-list>) | (allowed-floats <float-list>) |
//	(allowed-numbers <number-list>) | (allowed-instance-names <instance-list>) |
//	(allowed-classes <class-name-list>) | (allowed-values <value-list>)
void AllowedConstantAttribute() #void : {}
{
	(
		<ALLOWED_SYMBOLS> SymbolList()		|
		<ALLOWED_STRINGS> StringList()		|
		<ALLOWED_LEXEMES> LexemeList()		|
		<ALLOWED_INTEGERS> IntegerList()	|
		<ALLOWED_FLOATS> FloatList()		|
		<ALLOWED_NUMBERS> NumberList()		|
		<ALLOWED_INSTANCES> InstanceList()	|
		<ALLOWED_CLASSES> ClassNameList()	|
		<ALLOWED_VALUES> ValueList()		
	)
}

//<symbol-list> ::= <symbol>+ | ?VARIABLE
void SymbolList() #void : {}
{
	(<SYMBOL>)+ | <VARIABLE_TYPE>
}

//<string-list> ::= <string>+ | ?VARIABLE
void StringList() #void : {}
{
	(<STRING>)+ | <VARIABLE_TYPE>
}

//<lexeme-list> ::= <lexeme>+ | ?VARIABLE
void LexemeList() #void : {}
{
	(Lexeme())+ | <VARIABLE_TYPE>
}

//<integer-list> ::= <integer>+ | ?VARIABLE
void IntegerList() #void : {}
{
	(<INTEGER>)+ | <VARIABLE_TYPE>
}

//<float-list> ::= <float>+ | ?VARIABLE
void FloatList() #void : {}
{
	(<FLOAT>)+ | <VARIABLE_TYPE>
}

//<number-list> ::= <number>+ | ?VARIABLE
void NumberList() #void : {}
{
	(Number())+ | <VARIABLE_TYPE>
}

//<instance-name-list> ::= <instance-name>+ | ?VARIABLE
void InstanceList() #void : {}
{
	(<INSTANCE>)+ | <VARIABLE_TYPE>
}

//<class-name-list> ::= <class-name>+ | ?VARIABLE
void ClassNameList() #void : { Token t; }
{
	( 
		t = <SYMBOL>
	)+ 
	|
	<VARIABLE_TYPE>
}

//<value-list> ::= <constant>+ | ?VARIABLE
void ValueList() #void : {}
{
	(Constant())+ | <VARIABLE_TYPE>
}

//<range-attribute> ::= (range <range-specification> <range-specification>)
void RangeAttribute() #void : {}
{
	<RANGE> RangeSpecification() RangeSpecification()
}

//<range-specification> ::= <number> | ?VARIABLE
void RangeSpecification()  #void : {}
{
	Number() | <VARIABLE_TYPE>
}

//<cardinality-attribute> ::= (cardinality <cardinality-specification> <cardinality-specification>)
void CardinalityAttribute()  #void : {}
{
	<CARDINALITY> CardinalitySpecification() CardinalitySpecification()
}

//<cardinality-specification> ::= <integer> | ?VARIABLE
void CardinalitySpecification() #void: {}
{
	Integer() | <VARIABLE_TYPE>
}

