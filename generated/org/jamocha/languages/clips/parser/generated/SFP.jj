/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. SFP.jj */
/*@egen*//*
 * Copyright 2007 Karl-Heinz Krempels, Sebastian Reinartz
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.jamocha.org/
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

 /**

	2007-04-04 : Reduced COOL to the Jamocha Slim Fast Parser (sfp) - Karl-Heinz Krempels, Sebastian Reinartz.
	2006-11-08 : Implemented the COOL Parser - Ulrich Loup, Ory Chowow-Liebman


	The Grammar is based on the CLIPS Object Oriented Language (COOL) used by
	the CLIPS Production system

	@author Karl-Heinz Krempels
**/

options {
	           
	STATIC=false;
	                  
	                      
	                           
	                             
	OUTPUT_DIRECTORY="generated/org/jamocha/languages/clips/parser/generated";
	                 // create Visitor interface
	ERROR_REPORTING = true;
	JDK_VERSION = "8.0";
}


/* Java code used for the Parser. */
PARSER_BEGIN(SFPParser)

/*
 * Copyright 2007 Karl-Heinz Krempels, Sebastian Reinartz
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.jamocha.org/
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package org.jamocha.languages.clips.parser.generated;

import org.jamocha.languages.clips.parser.SFPVisitorImpl;
import org.jamocha.languages.common.ParserUtils;
import org.jamocha.dn.Network;

@SuppressWarnings("all")
public class SFPParser/*@bgen(jjtree)*/implements SFPParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected JJTSFPParserState jjtree = new JJTSFPParserState();

/*@egen*/

	public Object nextExpression() throws ParseException {
		SFPStart n = Start();
		if (n != null) {
			final Network network = new Network();
			Object result = n.jjtAccept(new SFPVisitorImpl(network, network), null);
			if (result != null) {
				return result;
			}
		}
		return null;
	}

	public static void main(String args[]) {
		boolean verbose = (args != null && args.length == 1 && "verbose".equals(args[0]));
		if(!verbose)System.out.println("Note: For verbose output type \"java Main verbose\".\n");
		System.out.print("SFP> ");
		SFPParser p = new SFPParser(System.in);
		try {
			while (true) {
				SFPStart n = p.Start();
				if (n==null) System.exit(0);
				n.dump(" ");
				final Network network = new Network();
				n.jjtAccept(new SFPVisitorImpl(network, network), null);
			}
		}
		catch (Exception e) {
			System.err.println("ERROR: " + e.getMessage());
			if(verbose)e.printStackTrace();
		}
	}
}

PARSER_END(SFPParser)

/**********************************************
 * Lexical Specs
 */


SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
}

SPECIAL_TOKEN : /* COMMENTS */
{
  <SINGLE_LINE_COMMENT: ";" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
}

TOKEN :
{
  < LBRACE: "(" >
| < RBRACE: ")" >
| < #DIGIT: ["0"-"9"] >
| < INTEGER: (["+","-"])? (<DIGIT>)+ >
|
  < FLOAT:
	  (["+","-"])? (<DIGIT>)+ "." (<DIGIT>)* (<EXPONENT>)?
      | (["+","-"])? "." (<DIGIT>)+ (<EXPONENT>)?
      | (["+","-"])? (<DIGIT>)+ <EXPONENT>
  >

| < #EXPONENT: ["e","E"] (["+","-"])? (<DIGIT>)+ >
| < #GMT_OFFSET: ("+"|"-") ( <DIGIT> )? <DIGIT> >
| < #DATE: <DIGIT> <DIGIT> <DIGIT> <DIGIT> "-" <DIGIT> <DIGIT> "-" <DIGIT> <DIGIT> >
| < #TIME: <DIGIT> <DIGIT> ":" <DIGIT> <DIGIT> ( ":" <DIGIT> <DIGIT>)? >
| < DATETIME:  <DATE> ( " " <TIME> (<GMT_OFFSET>)? )? >
| < SILENT: "silent" >
|
  < STRING:
      ("\"" ((~["\"","\\"]) | ("\\" ( ["\\","\""] )))* "\"") |
      ("\'" ((~["\'","\\"]) | ("\\" ( ["\\","\'"] )))* "\'")
  >
| < SFWILDCARD: "?" >
| < MFWILDCARD: "$?" >
| < GLOBALVAR: "?*" <SYMBOL> "*" >
| < DEFFACTS: "deffacts" >
| < DEFTEMPLATE: "deftemplate" >
| < DEFTEMPLATE_CONSTRUCT: "deftemplate_construct" >
| < DEFRULE: "defrule" >
| < DEFRULES: "defrules" >
| < DEFFUNCTION: "deffunction" >
| < FUNCTIONGROUP: "functiongroup">
| < DEFGENERIC: "defgeneric" >
| < DEFMODULE: "defmodule" >
| < DEFGLOBAL: "defglobal" >
| < DEFAULT_ATR: "default" >
| < DYNAMIC_ATR: "default-dynamic" >
| < ATR_DEFAULT: "?DEFAULT" >
| < ATR_DERIVE: "?DERIVE" >
| < ATR_NONE: "?NONE" >
| < ATR_ALL: "?ALL" >
| < SLOT: "slot" >
| < SINGLE_SLOT: "single-slot" >
| < MULTISLOT: "multislot" >
| < ARROW: "=>">
| < SLOWCOMPILE: "slow-compile" >
| < DECLARE: "declare" >
| < SALIENCE: "salience" >
| < TEMPORALVALIDITY: "temporal-validity" >
| < MILLISECOND: "millisecond" >
| < SECOND: "second" >
| < MINUTE: "minute" >
| < HOUR: "hour" >
| < DAY: "day" >
| < MONTH: "month" >
| < YEAR: "year" >
| < WEEKDAY: "weekday" >
| < DURATION: "duration" >
| < AUTOFOCUS: "auto-focus" >
| < RULEVERSION: "rule-version">
| <	TYPE: "type" >
| < TRUE: "TRUE" | "true" | "True" >
| < FALSE: "FALSE" | "false" | "False" >
| < NIL: "NIL" | "Nil" | "nil" >
| < NOT: "not" >
| < AND: "and" >
| < OR: "or" >
| < OF: "of" >
| < LOGICAL: "logical" >
| < TEST: "test" >
| < EXISTS: "exists" >
| < FORALL: "forall">
| < OBJECT: "object" >
| < ASSIGN: "<-" >
| < TILDE: "~" >
| < AMPERSAND: "&" >
| < LINE: "|" >
| < COLON: ":" >
| < EQUALS: "=" >
| < VARIABLE_TYPE: "?VARIABLE" >
| < SYMBOL_TYPE: "SYMBOL" >
| < STRING_TYPE: "STRING" >
| < DATETIME_TYPE: "DATETIME" >
| < LEXEME_TYPE: "LEXEME" >
| < INTEGER_TYPE: "INTEGER" >
| < FLOAT_TYPE: "FLOAT" >
| < NUMBER_TYPE: "NUMBER" >
| < BOOLEAN_TYPE: "BOOLEAN" >
| < EXTERNAL_ADDRESS_TYPE: "EXTERNAL-ADDRESS" >
| < FACT_ADDRESS_TYPE: "FACT-ADDRESS" >
| < ALLOWED_SYMBOLS: "allowed-symbols" >
| < ALLOWED_STRINGS: "allowed-strings" >
| < ALLOWED_LEXEMES: "allowed-lexemes" >
| < ALLOWED_INTEGERS: "allowed-integers" >
| < ALLOWED_FLOATS: "allowed-floats" >
| < ALLOWED_NUMBERS: "allowed-numbers" >
| < ALLOWED_VALUES: "allowed-values" >
| < RANGE: "range" >
| < CARDINALITY: "cardinality" >
| < ACTIVE: "active" >
	// Special functions
| < ASSERT: "assert" >
| < RETRACT: "retract" >
| < FIND_FACT_BY_FACT: "find-fact-by-fact" >
| < MODIFY: "modify" >
| < DUPLICATE: "duplicate" >
| < FACT_RELATION: "fact-relation" >
| < IF: "if" >
| < THEN: "then" >
| < ELSE: "else" >
| < WHILE: "while" >
| < DO: "do" >
| < LOOP_FOR_COUNT: "loop-for-count" >
| < SWITCH: "switch" >
| < CASE: "case" >
//| < STAR: "*">
  // If you think this is ugly, you are right. See CLIPS Basic Progrmmers Guide:
  // "Numbers are symbols, but treated different. Instances are symbols, but treated different."
| < #VARSYMBOL:  ["a"-"z","A"-"Z"] (~[" ","\r","\n","\t","\"","\'","(",")","&","|","<","~",";"])* >
| < SINGLEVAR: ("?" <VARSYMBOL>) >
| < MULTIVAR: ("$?" <VARSYMBOL>) >
| < SYMBOL:
	(~[" ","\r","\n","\t","\"","\'","(",")","&","|","$","?","~",";","0"-"9","="])
	|(
		(~[" ","\r","\n","\t","\"","\'","(",")","&","|","$","?","~",";","[","="])
		(~[" ","\r","\n","\t","\"","\'","(",")","&","|","?","~",";","0"-"9"])*
		(~[" ","\r","\n","\t","\"","\'","(",")","&","|","<","~",";" ])*
		(~[" ","\r","\n","\t","\"","\'","(",")","&","|","$","?","~",";","]"])?
	)
	|(
		(~[" ","\r","\n","\t","\"","\'","(",")","&","|","$","?","~",";","="])
		(~[" ","\r","\n","\t","\"","\'","(",")","&","|","?","~",";","0"-"9"])*
		(~[" ","\r","\n","\t","\"","\'","(",")","&","|","<","~",";" ])*
		(~[" ","\r","\n","\t","\"","\'","(",")","&","|","$","?","~",";","]"])+
	)
  >

}

/* (From Clips Manual):
Data Types:
<file-name> ::= A symbol or string which is a valid file name (including path information)
	for the operating system under which CLIPS is running
<slot-name> ::= A valid deftemplate_construct slot name
<...-name> ::= A <symbol> where the ellipsis indicate what the symbol represents.
	For example, <rule-name> is a symbol which represents the name of a rule.
*/

/**********************************************
 * Cool Grammar Specs.
 */

// Start rule is a construct at a time, the parser reads all the constructs into a list.
SFPStart Start() :
{/*@bgen(jjtree) Start */
  SFPStart jjtn000 = new SFPStart(this, JJTSTART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Start */
   try {
/*@egen*/
   ( LOOKAHEAD(2)
	Construct() | Expression()

	)/*@bgen(jjtree)*/
          {
            jjtree.closeNodeScope(jjtn000, true);
            jjtc000 = false;
          }
/*@egen*/ { return jjtn000; }
	| <EOF>/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                }
/*@egen*/ { return null; }/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}


/*
<number> ::= <float> | <integer>
<lexeme> ::= <symbol> | <string>
<constant> ::= <datetime> | <symbol> | <string> | <integer> | <float>
*/


/**
*		Float
**/

SimpleNode Float() :
{/*@bgen(jjtree) Float */
  SFPFloat jjtn000 = new SFPFloat(this, JJTFLOAT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) Float */
        try {
/*@egen*/
	(
		t=<FLOAT>
	//|	t=<DOUBLE>
	)/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/

	{
		jjtn000.jjtSetValue(t.image);
		return jjtn000;
	}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}



/**
*		Integer
**/

SimpleNode Integer() :
{/*@bgen(jjtree) Integer */
  SFPInteger jjtn000 = new SFPInteger(this, JJTINTEGER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) Integer */
        try {
/*@egen*/
	(
		t=<INTEGER>
	//|	t=<LONG>
	//|	t=<SHORT>
	)/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/

	{
		jjtn000.jjtSetValue(t.image);
		return jjtn000;
	}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}



/**
*		DateTime
**/

SimpleNode DateTime() :
{/*@bgen(jjtree) DateTime */
  SFPDateTime jjtn000 = new SFPDateTime(this, JJTDATETIME);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) DateTime */
        try {
/*@egen*/
	t=<DATETIME>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		jjtn000.jjtSetValue(t.image);
		return jjtn000;
	}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}



/**
*		Number
**/

void Number()       :
{}
{
	(	Float()
	|	Integer()
	)
}



/**
*		Symbol
**/

SimpleNode Symbol() :
{/*@bgen(jjtree) Symbol */
  SFPSymbol jjtn000 = new SFPSymbol(this, JJTSYMBOL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) Symbol */
        try {
/*@egen*/
	t=<SYMBOL>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		jjtn000.jjtSetValue(t.image);
		return jjtn000;
	}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}



/**
*		String
**/

SimpleNode String() :
{/*@bgen(jjtree) String */
  SFPString jjtn000 = new SFPString(this, JJTSTRING);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) String */
        try {
/*@egen*/
	t=<STRING>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		jjtn000.jjtSetValue(ParserUtils.getStringLiteral(t.image));
		return jjtn000;
	}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


/**
*		True
**/

SimpleNode True() :
{/*@bgen(jjtree) True */
  SFPTrue jjtn000 = new SFPTrue(this, JJTTRUE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) True */
        try {
/*@egen*/
	t=<TRUE>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		jjtn000.jjtSetValue(t.image);
		return jjtn000;
	}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

SimpleNode Nil() :
{/*@bgen(jjtree) Nil */
  SFPNil jjtn000 = new SFPNil(this, JJTNIL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) Nil */
        try {
/*@egen*/
	t=<NIL>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		jjtn000.jjtSetValue(t.image);
		return jjtn000;
	}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/**
*		SymbolType
**/

SimpleNode SymbolType() :
{/*@bgen(jjtree) SymbolType */
  SFPSymbolType jjtn000 = new SFPSymbolType(this, JJTSYMBOLTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) SymbolType */
        try {
/*@egen*/
	t=<SYMBOL_TYPE>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		jjtn000.jjtSetValue(t.image);
		return jjtn000;
	}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/**
*		StringType
**/

SimpleNode StringType() :
{/*@bgen(jjtree) StringType */
  SFPStringType jjtn000 = new SFPStringType(this, JJTSTRINGTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) StringType */
        try {
/*@egen*/
	t=<STRING_TYPE>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		jjtn000.jjtSetValue(t.image);
		return jjtn000;
	}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/**
*		DateTimeType
**/

SimpleNode DateTimeType() :
{/*@bgen(jjtree) DateTimeType */
  SFPDateTimeType jjtn000 = new SFPDateTimeType(this, JJTDATETIMETYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) DateTimeType */
        try {
/*@egen*/
	t=<DATETIME_TYPE>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		jjtn000.jjtSetValue(t.image);
		return jjtn000;
	}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/**
*		LexemeType
**/

SimpleNode LexemeType() :
{/*@bgen(jjtree) LexemeType */
  SFPLexemeType jjtn000 = new SFPLexemeType(this, JJTLEXEMETYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) LexemeType */
        try {
/*@egen*/
	t=<LEXEME_TYPE>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		jjtn000.jjtSetValue(t.image);
		return jjtn000;
	}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/**
*		BooleanType
**/

SimpleNode BooleanType() :
{/*@bgen(jjtree) BooleanType */
  SFPBooleanType jjtn000 = new SFPBooleanType(this, JJTBOOLEANTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) BooleanType */
        try {
/*@egen*/
	t=<BOOLEAN_TYPE>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		jjtn000.jjtSetValue(t.image);
		return jjtn000;
	}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/**
*		IntegerType
**/

SimpleNode IntegerType() :
{/*@bgen(jjtree) IntegerType */
  SFPIntegerType jjtn000 = new SFPIntegerType(this, JJTINTEGERTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) IntegerType */
        try {
/*@egen*/
	t=<INTEGER_TYPE>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		jjtn000.jjtSetValue(t.image);
		return jjtn000;
	}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/**
*		FloatType
**/

SimpleNode FloatType() :
{/*@bgen(jjtree) FloatType */
  SFPFloatType jjtn000 = new SFPFloatType(this, JJTFLOATTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) FloatType */
        try {
/*@egen*/
	t=<FLOAT_TYPE>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		jjtn000.jjtSetValue(t.image);
		return jjtn000;
	}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


/**
*		NumberType
**/

SimpleNode NumberType() :
{/*@bgen(jjtree) NumberType */
  SFPNumberType jjtn000 = new SFPNumberType(this, JJTNUMBERTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) NumberType */
        try {
/*@egen*/
	t=<NUMBER_TYPE>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		jjtn000.jjtSetValue(t.image);
		return jjtn000;
	}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


/**
*		FactAddressType
**/

SimpleNode FactAddressType() :
{/*@bgen(jjtree) FactAddressType */
  SFPFactAddressType jjtn000 = new SFPFactAddressType(this, JJTFACTADDRESSTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) FactAddressType */
        try {
/*@egen*/
	t=<FACT_ADDRESS_TYPE>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		jjtn000.jjtSetValue(t.image);
		return jjtn000;
	}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


/**
*		False
**/

SimpleNode False() :
{/*@bgen(jjtree) False */
  SFPFalse jjtn000 = new SFPFalse(this, JJTFALSE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) False */
        try {
/*@egen*/
	t=<FALSE>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		jjtn000.jjtSetValue(t.image);
		return jjtn000;
	}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


/**
*		Lexeme
**/

void Lexeme()       :
{}
{
	(	String()
	|	Symbol()
	)
}



/**
*		Constant
**/

SimpleNode Constant() :
{/*@bgen(jjtree) Constant */
  SFPConstant jjtn000 = new SFPConstant(this, JJTCONSTANT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Constant */
        try {
/*@egen*/
	(
		Nil()
	|	DateTime()
	|   Symbol()
	|	String()
	|	Integer()
	|	Float()
	|	BooleanSymbol()
	)/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/

    { return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}



/**
*		Construct Description
**/

SimpleNode ConstructDescription() :
{/*@bgen(jjtree) ConstructDescription */
  SFPConstructDescription jjtn000 = new SFPConstructDescription(this, JJTCONSTRUCTDESCRIPTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ConstructDescription */
    try {
/*@egen*/
    String()/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/

    { return jjtn000; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}


/**
*		Single Variable
**/
// This is used exactly then when only the variables value is needed

SimpleNode SingleVariable() :
{/*@bgen(jjtree) SingleVariable */
  SFPSingleVariable jjtn000 = new SFPSingleVariable(this, JJTSINGLEVARIABLE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) SingleVariable */
        try {
/*@egen*/
	t=<SINGLEVAR>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/

	{ jjtn000.jjtSetValue(t.image); return jjtn000;}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}



/**
*		Global Variable
**/
// This is used exactly then when only the variables value is needed

SimpleNode GlobalVariable() :
{/*@bgen(jjtree) GlobalVariable */
  SFPGlobalVariable jjtn000 = new SFPGlobalVariable(this, JJTGLOBALVARIABLE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) GlobalVariable */
        try {
/*@egen*/
	t=<GLOBALVAR>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ jjtn000.jjtSetValue(t.image); return jjtn000;}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}



/**
*		Multi Variable
**/
// This is used exactly then when only the variables contents are needed

SimpleNode MultiVariable() :
{/*@bgen(jjtree) MultiVariable */
  SFPMultiVariable jjtn000 = new SFPMultiVariable(this, JJTMULTIVARIABLE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) MultiVariable */
        try {
/*@egen*/
	t=<MULTIVAR>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/

	{ jjtn000.jjtSetValue(t.image); return jjtn000;}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}



/**
*		Variable
**/
// This is used exactly then when only the variables value is needed

void Variable()      :
{}
{
	(
		SingleVariable()
	|	MultiVariable()
	|	GlobalVariable()
	)
}



/**
*		Variable Type
**/
// This is used exactly then when only the variables contents are needed

SimpleNode VariableType() :
{/*@bgen(jjtree) VariableType */
  SFPVariableType jjtn000 = new SFPVariableType(this, JJTVARIABLETYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) VariableType */
        try {
/*@egen*/
	t=<VARIABLE_TYPE>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		jjtn000.jjtSetValue(t.image);
		return jjtn000;
	}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}



/**
*		Function Call
**/

// <function-call> ::= (<function-name> <expression>*)

void FunctionCall()      :
{}
{
	<LBRACE>
		(
			AssertFunc()
		|	Modify()
		|	RetractFunc()
		|   FindFactByFactFunc()
		|	IfElseFunc()
		|	WhileFunc()
		|	LoopForCountFunc()
		|	AnyFunction()
		|	SwitchCaseFunc()
		)
	<RBRACE>
}



/**
*		Any Function
**/

SimpleNode AnyFunction() :
{/*@bgen(jjtree) AnyFunction */
  SFPAnyFunction jjtn000 = new SFPAnyFunction(this, JJTANYFUNCTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) AnyFunction */
        try {
/*@egen*/
 	(
 		Symbol()
 		(
 			Expression()
 		)*
 	)/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/

	{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}



/**
*		Expression
**/

SimpleNode Expression() :
{/*@bgen(jjtree) Expression */
  SFPExpression jjtn000 = new SFPExpression(this, JJTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Expression */
        try {
/*@egen*/
	(	LOOKAHEAD(2)
		Constant()
	|	Variable()
	|	FunctionCall()
	)/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}



/****
**		 Special functions which are defined by CLIPS to have
**		a non-standard syntax (e.g. not all parameters are expressions)
****/

/**
*		Assert Function
**/

SimpleNode AssertFunc() :
{/*@bgen(jjtree) AssertFunc */
  SFPAssertFunc jjtn000 = new SFPAssertFunc(this, JJTASSERTFUNC);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) AssertFunc */
        try {
/*@egen*/
	<ASSERT>
	(
		RHSPattern()
	)+/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


/**
*		Modify Function
**/
SimpleNode Modify() :
{/*@bgen(jjtree) Modify */
  SFPModify jjtn000 = new SFPModify(this, JJTMODIFY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Modify */
        try {
/*@egen*/
	<MODIFY>
	ModifyPattern()/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


/**
*		FindFactByFact Function
**/

SimpleNode FindFactByFactFunc() :
{/*@bgen(jjtree) FindFactByFactFunc */
  SFPFindFactByFactFunc jjtn000 = new SFPFindFactByFactFunc(this, JJTFINDFACTBYFACTFUNC);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) FindFactByFactFunc */
        try {
/*@egen*/
	<FIND_FACT_BY_FACT>
	(
		RHSPattern()
	)/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}



/**
*		Retract Function
**/

SimpleNode RetractFunc() :
{/*@bgen(jjtree) RetractFunc */
  SFPRetractFunc jjtn000 = new SFPRetractFunc(this, JJTRETRACTFUNC);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) RetractFunc */
        try {
/*@egen*/
	<RETRACT>
	(
	//	<STAR>	// Retract all
	//|	(
			(Expression())*		// Integers and 'retract-specifiers' see BPG
	//	)
	)/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
//	RHSPattern()+
	{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}



/**
*		If Else Function
**/

SimpleNode IfElseFunc() :
{/*@bgen(jjtree) IfElseFunc */
  SFPIfElseFunc jjtn000 = new SFPIfElseFunc(this, JJTIFELSEFUNC);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) IfElseFunc */
        try {
/*@egen*/
	(
		<IF>
		Expression()
		<THEN>
		ActionList()
		[
		 	<ELSE>
		 	ActionList()
		 ]
	)/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/

	{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}



/**
*		While Function
**/

SimpleNode WhileFunc() :
{/*@bgen(jjtree) WhileFunc */
  SFPWhileFunc jjtn000 = new SFPWhileFunc(this, JJTWHILEFUNC);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) WhileFunc */
        try {
/*@egen*/
	(
		<WHILE>
		Expression()
		[
		 	<DO>
		]
		ActionList()
	)/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/

	{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}



/**
*		Loop For Count Function
**/

SimpleNode LoopForCountFunc() :
{/*@bgen(jjtree) LoopForCountFunc */
  SFPLoopForCountFunc jjtn000 = new SFPLoopForCountFunc(this, JJTLOOPFORCOUNTFUNC);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) LoopForCountFunc */
        try {
/*@egen*/
	(
		<LOOP_FOR_COUNT>
		(
			<LBRACE>
			(
				SingleVariable()
			 	Expression()
			 	[
			 	 	Expression()
			 	]
			 )
			 <RBRACE>
		)
		[
		 	<DO>
		 ]
		 ActionList()
	)/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/

	{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}



/**
*		Case Switch Function
**/

SimpleNode SwitchCaseFunc() :
{/*@bgen(jjtree) SwitchCaseFunc */
  SFPSwitchCaseFunc jjtn000 = new SFPSwitchCaseFunc(this, JJTSWITCHCASEFUNC);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) SwitchCaseFunc */
        try {
/*@egen*/
	(
		<SWITCH>
		Expression()	// Test Expression
		(	LOOKAHEAD(2)
			CaseStatement()
		)*
		[
		<LBRACE>
			SwitchDefaults()
		<RBRACE>
		]
	)/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}



/**
*		Case Statement Function
**/

SimpleNode CaseStatement() :
{/*@bgen(jjtree) CaseStatement */
  SFPCaseStatement jjtn000 = new SFPCaseStatement(this, JJTCASESTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) CaseStatement */
        try {
/*@egen*/
	(
		<LBRACE>
			<CASE>
			Expression()	// Comparison Expression
			<THEN>
			ActionList()
		<RBRACE>
	)/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/

	{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/**
*		Default Statements for SwitchCaseFunc
**/
SimpleNode SwitchDefaults() :
{/*@bgen(jjtree) SwitchDefaults */
  SFPSwitchDefaults jjtn000 = new SFPSwitchDefaults(this, JJTSWITCHDEFAULTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) SwitchDefaults */
        try {
/*@egen*/
	(
		<LBRACE>
			<DEFAULT_ATR>
			ActionList()
		<RBRACE>
	)/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/

	{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/**
*		Construct - Definition Main Handler
**/

void Construct()       : {}
{
	<LBRACE>
		( LOOKAHEAD(2)
			DeftemplateConstruct()
		|	DefglobalConstruct()
		|	DefruleConstruct()
		|	DefrulesConstruct()
		|	DeffunctionConstruct()
		|	DefmoduleConstruct()
		)
	<RBRACE>
}



/**
*		Deftemplate Construct
**/
// <deftemplate-construct> ::= (deftemplate <deftemplate-name> [<comment>] <slot-definition>*)

SimpleNode DeftemplateConstruct() :
{/*@bgen(jjtree) DeftemplateConstruct */
  SFPDeftemplateConstruct jjtn000 = new SFPDeftemplateConstruct(this, JJTDEFTEMPLATECONSTRUCT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) DeftemplateConstruct */
        try {
/*@egen*/
        (
        	<DEFTEMPLATE>
			Symbol()
			[
			 	ConstructDescription()
			]
			(
				SlotDefinition()
			)*
	)/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/

        { return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

SimpleNode Silent() :
{/*@bgen(jjtree) Silent */
  SFPSilent jjtn000 = new SFPSilent(this, JJTSILENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Silent */
        try {
/*@egen*/
	<SILENT>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{return jjtn000;}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


/**
*		Slot Definition
**/
//<slot-definition> ::= <single-slot-definition> | <multislot-definition>

SimpleNode  SlotDefinition() :
{/*@bgen(jjtree) SlotDefinition */
  SFPSlotDefinition jjtn000 = new SFPSlotDefinition(this, JJTSLOTDEFINITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) SlotDefinition */
    try {
/*@egen*/
    (
		<LBRACE>
		(Silent())?
		(
					SingleSlotDefinition()
				| 	MultiSlotDefinition()
			)
		<RBRACE>
    )/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {return jjtn000;}/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}



/**
*		Single Slot Definition
**/
//< single-slot-definition> ::= ( slot <slot-name> <template-attribute>*)

SimpleNode SingleSlotDefinition() :
{/*@bgen(jjtree) SingleSlotDefinition */
  SFPSingleSlotDefinition jjtn000 = new SFPSingleSlotDefinition(this, JJTSINGLESLOTDEFINITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) SingleSlotDefinition */
        try {
/*@egen*/
	<SLOT>
	(
		Symbol()
		(
			TemplateAttribute()
		)*
	)/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}



/**
*		Multi Slot Definition
**/
//<multislot-definition> ::= ( multislot <slot-name> <template-attribute>*)

SimpleNode MultiSlotDefinition() :
{/*@bgen(jjtree) MultiSlotDefinition */
  SFPMultiSlotDefinition jjtn000 = new SFPMultiSlotDefinition(this, JJTMULTISLOTDEFINITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) MultiSlotDefinition */
        try {
/*@egen*/
        <MULTISLOT>
	(
		Symbol()
		(
			TemplateAttribute()
		)*
	)/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}



/**
*		Template Attribute
**/
//<template-attribute> ::= <default-attribute> | <constraint-attribute>

void TemplateAttribute()      :
{}
{
	<LBRACE>
	(	LOOKAHEAD(2)
		DefaultAttribute()
	| 	DynamicAttribute()
	|	ConstraintAttribute()
	)
	<RBRACE>
}



/**
*		Attributes
**/
// A dummy node to have a list of attributes

SimpleNode Attributes() :
{/*@bgen(jjtree) Attributes */
  SFPAttributes jjtn000 = new SFPAttributes(this, JJTATTRIBUTES);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Attributes */
        try {
/*@egen*/
	(	LOOKAHEAD(2)
		Expression()
	)*/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}



/**
*		Default Attribute
**/
//<default-attribute> ::= (default ?DERIVE | ?NONE | <expression>*) | (default-dynamic <expression>*)

SimpleNode DefaultAttribute() :
{/*@bgen(jjtree) DefaultAttribute */
  SFPDefaultAttribute jjtn000 = new SFPDefaultAttribute(this, JJTDEFAULTATTRIBUTE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) DefaultAttribute */
                try {
/*@egen*/
		<DEFAULT_ATR>
		(
			DeriveAttribute()
		|	NoneAttribute()
		|	DefaultAttributes()
		)/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                }
/*@egen*/
		{ return jjtn000; }/*@bgen(jjtree)*/
                } catch (Throwable jjte000) {
                  if (jjtc000) {
                    jjtree.clearNodeScope(jjtn000);
                    jjtc000 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte000 instanceof RuntimeException) {
                    throw (RuntimeException)jjte000;
                  }
                  if (jjte000 instanceof ParseException) {
                    throw (ParseException)jjte000;
                  }
                  throw (Error)jjte000;
                } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                  }
                }
/*@egen*/
}

SimpleNode DefaultAttributes() :
{/*@bgen(jjtree) DefaultAttributes */
  SFPDefaultAttributes jjtn000 = new SFPDefaultAttributes(this, JJTDEFAULTATTRIBUTES);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) DefaultAttributes */
    try {
/*@egen*/
    Attributes()/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/

    { return jjtn000; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}



/**
*		Derive Attribute
**/

SimpleNode DeriveAttribute() :
{/*@bgen(jjtree) DeriveAttribute */
  SFPDeriveAttribute jjtn000 = new SFPDeriveAttribute(this, JJTDERIVEATTRIBUTE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) DeriveAttribute */
        try {
/*@egen*/
	t = <ATR_DERIVE>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		jjtn000.jjtSetValue(t.image);
		return jjtn000;
	}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}



/**
*		None Attribute
**/

SimpleNode NoneAttribute() :
{/*@bgen(jjtree) NoneAttribute */
  SFPNoneAttribute jjtn000 = new SFPNoneAttribute(this, JJTNONEATTRIBUTE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) NoneAttribute */
        try {
/*@egen*/
	t = <ATR_NONE>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		jjtn000.jjtSetValue(t.image);
		return jjtn000;
	}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}



/**
*		Dynamic Attribute
**/

//<default-attribute> ::= (default ?DERIVE | ?NONE | <expression>*) | (default-dynamic <expression>*)

SimpleNode DynamicAttribute() :
{/*@bgen(jjtree) DynamicAttribute */
  SFPDynamicAttribute jjtn000 = new SFPDynamicAttribute(this, JJTDYNAMICATTRIBUTE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) DynamicAttribute */
        try {
/*@egen*/
	<DYNAMIC_ATR>
	(
		Attributes()
	)/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


void ModifyPattern()      :
{}
{
	Expression()
	(
		RHSSlot()
	)+
}

SimpleNode RHSSlot() :
{/*@bgen(jjtree) RHSSlot */
  SFPRHSSlot jjtn000 = new SFPRHSSlot(this, JJTRHSSLOT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) RHSSlot */
        try {
/*@egen*/
	<LBRACE>
		Symbol() // slot name
		(
		    RHSField()
		)*
	<RBRACE>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/

	{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/**
*		Fact Construct
**/


/**
*		Right Hand Site Pattern
**/
// <RHS-pattern> ::= <ordered-RHS-pattern> | <template-RHS-pattern>
// <ordered-RHS-pattern> ::= (<symbol> <RHS-field>+)
// <template-RHS-pattern> ::= (<deftemplate-name> <RHS-slot>*)
// <RHS-slot> ::= <single-field-RHS-slot> | <multifield-RHS-slot>
// <single-field-RHS-slot> ::= (<slot-name> <RHS-field>)
// <multifield-RHS-slot> ::= (<slot-name> <RHS-field>*)
// <RHS-field> ::= <variable> | <constant> | <function-call>
// <RHS-slot> ::= <single-field-RHS-slot> | <multifield-RHS-slot>
// <single-field-RHS-slot> ::= (<slot-name> <RHS-field>)
// <multifield-RHS-slot> ::= (<slot-name> <RHS-field>*)

SimpleNode RHSPattern() :
{/*@bgen(jjtree) RHSPattern */
  SFPRHSPattern jjtn000 = new SFPRHSPattern(this, JJTRHSPATTERN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) RHSPattern */
        try {
/*@egen*/
	<LBRACE>
		Symbol() //Template Name
		[
			LOOKAHEAD(2)
			<LBRACE>
				TemporalValidity()
			<RBRACE>
		]
		(
		    RHSSlot()
		)*
	<RBRACE>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/

	{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


/**
*		Right Hand Site Field
**/

//<RHS-field> ::= <variable> | <constant> | <function-call>

void RHSField()      :
{}
{
    	Variable()
    |   Constant()
    |   FunctionCall()
}



/**
*		Define Rule Construct
**/

/*
<defrule-construct> ::= (defrule <rule-name> [<comment>] [<declaration>] <conditional-element>* => <expression>*)
<rule-property> ::= (salience <integer-expression>) | (auto-focus <boolean-symbol>)
<boolean-symbol> ::= TRUE | FALSE
<conditional-element> ::= <pattern-CE> | <assigned-pattern-CE> | <not-CE> | <and-CE> | <or-CE> |
	<logical-CE> | <test-CE> | <exists-CE> | <forall-CE>
<pattern-CE> ::= <ordered-pattern-CE> | <template-pattern-CE> | <object-pattern-CE>
<assigned-pattern-CE> ::= <single-field-variable> <- <pattern-CE>
<not-CE> ::= (not <conditional-element>)
<and-CE> ::= (and <conditional-element>+)
<or-CE> ::= (or <conditional-element>+)
<logical-CE> ::= (logical <conditional-element>+)
<test-CE> ::= (test <function-call>)
<exists-CE> ::= (exists <conditional-element>+)
<forall-CE> ::= (forall <conditional-element> <conditional-element>+)
<ordered-pattern-CE> ::= (<symbol> <constraint>*)
<template-pattern-CE> ::= (<deftemplate-name> <LHS-slot>*)
<object-pattern-CE> ::= (object <attribute-constraint>*)
<attribute-constraint> ::= (is-a <constraint>) | (name <constraint>) | (<slot-name> <constraint>*)
<LHS-slot> ::= <single-field-LHS-slot> | <multifield-LHS-slot>
<single-field-LHS-slot> ::= (<slot-name> <constraint>)
<multifield-LHS-slot> ::= (<slot-name> <constraint>*)
<constraint> ::= ? | $? | <connected-constraint>
<connected-constraint>::= <single-constraint> | <single-constraint> & <connected-constraint> |
	<single-constraint> | <connected-constraint>
<single-constraint> ::= <term> | ~<term>
<term> ::= <constant> | <single-field-variable> | <multifield-variable> |
	:<function-call> | =<function-call>
*/



/**
*		Define Rule Construct
**/

// <defrule-construct> ::= (defrule <rule-name> [<comment>] [<declaration>] <conditional-element>* => <expression>*)

SimpleNode DefruleConstruct() :
{/*@bgen(jjtree) DefruleConstruct */
  SFPDefruleConstruct jjtn000 = new SFPDefruleConstruct(this, JJTDEFRULECONSTRUCT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) DefruleConstruct */
        try {
/*@egen*/
	(
		<DEFRULE>
		DefruleBody()
	)/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}



// <defrules-construct> ::= (defrules (<rule-name> [<comment>] [<declaration>] <conditional-element>* => <expression>*)+)

SimpleNode DefrulesConstruct() :
{/*@bgen(jjtree) DefrulesConstruct */
  SFPDefrulesConstruct jjtn000 = new SFPDefrulesConstruct(this, JJTDEFRULESCONSTRUCT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) DefrulesConstruct */
        try {
/*@egen*/
	(
		<DEFRULES>
		(
			<LBRACE>
			DefruleBody()
			<RBRACE>
		)+
	)/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


SimpleNode DefruleBody() :
{/*@bgen(jjtree) DefruleBody */
  SFPDefruleBody jjtn000 = new SFPDefruleBody(this, JJTDEFRULEBODY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) DefruleBody */
        try {
/*@egen*/
	(
		Symbol()	//name
		[
			ConstructDescription()
		]
		(
			[
				LOOKAHEAD(3)
				Declaration()
			]
				(
					ConditionalElement()
				)*
		)
		<ARROW>
		ActionList()
	)/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}



/**
*		Action List
**/

// Create Dummy node to have fixed number of children in Defrule

SimpleNode ActionList():{/*@bgen(jjtree) ActionList */
  SFPActionList jjtn000 = new SFPActionList(this, JJTACTIONLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ActionList */
        try {
/*@egen*/
    	(
        	(
        	LOOKAHEAD(2)
    		Expression()
        	)*
	)/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}



/**
*		Declaration
**/

//<declaration> ::= (declare <rule-property>+)

SimpleNode Declaration():
{/*@bgen(jjtree) Declaration */
  SFPDeclaration jjtn000 = new SFPDeclaration(this, JJTDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Declaration */
    try {
/*@egen*/
    <LBRACE>
        <DECLARE>
        (
        	RuleProperty()
        )+
    <RBRACE>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { return jjtn000; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}



/**
*		Rule Property
**/

// <rule-property> ::= (salience <integer-expression>) | (auto-focus <boolean-symbol>)

void RuleProperty()      :
{}
{
    <LBRACE>
     	(
     		Salience()
     	| 	AutoFocus()
     	|   SlowCompile()
     	|	RuleVersion()
     	|   TemporalValidityDeclaration()
	)
	<RBRACE>
}

SimpleNode TemporalValidityDeclaration() :
{/*@bgen(jjtree) TemporalValidityDeclaration */
  SFPTemporalValidityDeclaration jjtn000 = new SFPTemporalValidityDeclaration(this, JJTTEMPORALVALIDITYDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) TemporalValidityDeclaration */
        try {
/*@egen*/
	TemporalValidity()/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ return jjtn000;}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


/**
*		Temporal Validity
**/

SimpleNode TemporalValidity() :
{/*@bgen(jjtree) TemporalValidity */
  SFPTemporalValidity jjtn000 = new SFPTemporalValidity(this, JJTTEMPORALVALIDITY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) TemporalValidity */
        try {
/*@egen*/
	<TEMPORALVALIDITY>
	(
	    LOOKAHEAD(2)
      	TemporalAttribute()
    )+/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/**
*		Temporal Attribute
**/

void TemporalAttribute()      :
{}
{
    <LBRACE>
     	(
     	    TAMillisecond()
     	|	TASecond()
     	| 	TAMinute()
     	|	TAHour()
     	|   TADay()
     	|   TAMonth()
     	|   TAYear()
     	|   TAWeekday()
     	|   TADuration()
	)
	<RBRACE>
}

SimpleNode TAMillisecond():
{/*@bgen(jjtree) TAMillisecond */
  SFPTAMillisecond jjtn000 = new SFPTAMillisecond(this, JJTTAMILLISECOND);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) TAMillisecond */
    try {
/*@egen*/
    <MILLISECOND>
    Expression()/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { return jjtn000; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

SimpleNode TASecond():
{/*@bgen(jjtree) TASecond */
  SFPTASecond jjtn000 = new SFPTASecond(this, JJTTASECOND);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) TASecond */
        try {
/*@egen*/
	<SECOND>
	Expression()/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

SimpleNode TAMinute():
{/*@bgen(jjtree) TAMinute */
  SFPTAMinute jjtn000 = new SFPTAMinute(this, JJTTAMINUTE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) TAMinute */
        try {
/*@egen*/
	<MINUTE>
	Expression()/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

SimpleNode TAHour():
{/*@bgen(jjtree) TAHour */
  SFPTAHour jjtn000 = new SFPTAHour(this, JJTTAHOUR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) TAHour */
        try {
/*@egen*/
	<HOUR>
	Expression()/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

SimpleNode TADay():
{/*@bgen(jjtree) TADay */
  SFPTADay jjtn000 = new SFPTADay(this, JJTTADAY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) TADay */
        try {
/*@egen*/
	<DAY>
	Expression()/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

SimpleNode TAMonth():
{/*@bgen(jjtree) TAMonth */
  SFPTAMonth jjtn000 = new SFPTAMonth(this, JJTTAMONTH);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) TAMonth */
        try {
/*@egen*/
	<MONTH>
	Expression()/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

SimpleNode TAYear():
{/*@bgen(jjtree) TAYear */
  SFPTAYear jjtn000 = new SFPTAYear(this, JJTTAYEAR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) TAYear */
        try {
/*@egen*/
	<YEAR>
	Expression()/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

SimpleNode TAWeekday():
{/*@bgen(jjtree) TAWeekday */
  SFPTAWeekday jjtn000 = new SFPTAWeekday(this, JJTTAWEEKDAY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) TAWeekday */
        try {
/*@egen*/
	<WEEKDAY>
	Expression()/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

SimpleNode TADuration():
{/*@bgen(jjtree) TADuration */
  SFPTADuration jjtn000 = new SFPTADuration(this, JJTTADURATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) TADuration */
        try {
/*@egen*/
	<DURATION>
	Expression()/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}





/**
*		Salience
**/

SimpleNode Salience() :
{/*@bgen(jjtree) Salience */
  SFPSalience jjtn000 = new SFPSalience(this, JJTSALIENCE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Salience */
        try {
/*@egen*/
	<SALIENCE>
	Expression()/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}



/**
*		Auto Focus
**/

SimpleNode AutoFocus():
{/*@bgen(jjtree) AutoFocus */
  SFPAutoFocus jjtn000 = new SFPAutoFocus(this, JJTAUTOFOCUS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) AutoFocus */
        try {
/*@egen*/
	<AUTOFOCUS>
	BooleanSymbol()/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/

	{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/**
*       Slow Compile
**/

SimpleNode SlowCompile():
{/*@bgen(jjtree) SlowCompile */
  SFPSlowCompile jjtn000 = new SFPSlowCompile(this, JJTSLOWCOMPILE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) SlowCompile */
    try {
/*@egen*/
    <SLOWCOMPILE>
    BooleanSymbol()/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/

    { return jjtn000; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}



/**
*		Rule Version
**/

SimpleNode RuleVersion():
{/*@bgen(jjtree) RuleVersion */
  SFPRuleVersion jjtn000 = new SFPRuleVersion(this, JJTRULEVERSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) RuleVersion */
        try {
/*@egen*/
	<RULEVERSION>
	Expression()/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/

	{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}



/**
*		Boolean Symbol
**/

//<boolean-symbol> ::= TRUE | FALSE

void BooleanSymbol()      :
{}
{
    (
    	True()
    |	False()
    )
}


/**
*		Conditional Element
**/

//<conditional-element> ::= <pattern-CE> | <assigned-pattern-CE> | <not-CE> | <and-CE> | <or-CE> |
//                          <logical-CE> | <test-CE> | <exists-CE> | <forall-CE>

void ConditionalElement()      :
{}
{
	(
		(
		   <LBRACE>
				(
						TemplatePatternCE()
					|	BooleanFunction()
					|	LogicalCE()
					|	TestCE()
					|	ExistsCE()
					|	ForallCE()
				)
			<RBRACE>
		)

		|	AssignedPatternCE()
	)
}



/**
*		Boolean Function
**/

void BooleanFunction()      :
{}
{
	(LOOKAHEAD(2)
		NotFunction()
	|	AndFunction()
	|	OrFunction()
	)
}



/**
*		And Function
**/

SimpleNode NotFunction():
{/*@bgen(jjtree) NotFunction */
  SFPNotFunction jjtn000 = new SFPNotFunction(this, JJTNOTFUNCTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) NotFunction */
        try {
/*@egen*/
	<NOT>
		ConditionalElement()/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/

	{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}



/**
*		And Function
**/

SimpleNode AndFunction():
{/*@bgen(jjtree) AndFunction */
  SFPAndFunction jjtn000 = new SFPAndFunction(this, JJTANDFUNCTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) AndFunction */
        try {
/*@egen*/
	<AND>
		(ConditionalElement())+/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/

	{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}



/**
*		Or Function
**/

SimpleNode OrFunction():
{/*@bgen(jjtree) OrFunction */
  SFPOrFunction jjtn000 = new SFPOrFunction(this, JJTORFUNCTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) OrFunction */
        try {
/*@egen*/

	<OR>
		(ConditionalElement())+/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/

	{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


/**
*		Pattern Conditional Element
**/

//<assigned-pattern-CE> ::= <single-field-variable> <- <pattern-CE>
// Create and return conditions

SimpleNode AssignedPatternCE():
{/*@bgen(jjtree) AssignedPatternCE */
  SFPAssignedPatternCE jjtn000 = new SFPAssignedPatternCE(this, JJTASSIGNEDPATTERNCE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) AssignedPatternCE */
        try {
/*@egen*/

	(
		SingleVariable()
		<ASSIGN>

		<LBRACE>

			TemplatePatternCE()

		<RBRACE>
	)/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/

	{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}



/**
*		Logical CE
**/

//<logical-CE> ::= (logical <conditional-element>+)
// Create and return conditions

SimpleNode LogicalCE() :
{/*@bgen(jjtree) LogicalCE */
  SFPLogicalCE jjtn000 = new SFPLogicalCE(this, JJTLOGICALCE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) LogicalCE */
    try {
/*@egen*/
    <LOGICAL>

    (
    	LOOKAHEAD(2)

		ConditionalElement()
    )+/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/

    { return jjtn000; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}



/**
*		Test CE
**/

//<test-CE> ::= (test <function-call>)
// Create and return conditions (initialize the function before execution, to get a node

SimpleNode TestCE() :
{/*@bgen(jjtree) TestCE */
  SFPTestCE jjtn000 = new SFPTestCE(this, JJTTESTCE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) TestCE */
        try {
/*@egen*/
	<TEST>
	FunctionCall()/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/

	{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}



/**
*		Exists CE
**/

//<exists-CE> ::= (exists <conditional-element>+)
// Create and return conditions
SimpleNode ExistsCE() :
{/*@bgen(jjtree) ExistsCE */
  SFPExistsCE jjtn000 = new SFPExistsCE(this, JJTEXISTSCE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ExistsCE */
    try {
/*@egen*/
    <EXISTS>
    (
		LOOKAHEAD(2)

		ConditionalElement()
    )+/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/

    { return jjtn000; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}



/**
*		Forall CE
**/

//<forall-CE> ::= (forall <conditional-element> <conditional-element>+)
// Create and return conditions

SimpleNode ForallCE() :
{/*@bgen(jjtree) ForallCE */
  SFPForallCE jjtn000 = new SFPForallCE(this, JJTFORALLCE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ForallCE */
        try {
/*@egen*/
	<FORALL>
	ConditionalElement()
	(
		LOOKAHEAD(2)

		ConditionalElement()
	)+/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/

	{return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


/**
*		Template Pattern CE
**/

//<template-pattern-CE> ::= (<deftemplate-name> <LHS-slot>*)

SimpleNode TemplatePatternCE():
{/*@bgen(jjtree) TemplatePatternCE */
  SFPTemplatePatternCE jjtn000 = new SFPTemplatePatternCE(this, JJTTEMPLATEPATTERNCE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) TemplatePatternCE */
    try {
/*@egen*/
    (
    	Symbol() //template Name
    	(LOOKAHEAD(2)
    			(UnorderedLHSFactBody())+
	    	|	OrderedLHSFactBody()
		)
    )/*@bgen(jjtree)*/
   {
     jjtree.closeNodeScope(jjtn000, true);
     jjtc000 = false;
   }
/*@egen*/

   { return jjtn000; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}



SimpleNode UnorderedLHSFactBody():
{/*@bgen(jjtree) UnorderedLHSFactBody */
  SFPUnorderedLHSFactBody jjtn000 = new SFPUnorderedLHSFactBody(this, JJTUNORDEREDLHSFACTBODY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) UnorderedLHSFactBody */
        try {
/*@egen*/
	<LBRACE>
	LHSSlot()
	<RBRACE>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/

	{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

SimpleNode OrderedLHSFactBody():
{/*@bgen(jjtree) OrderedLHSFactBody */
  SFPOrderedLHSFactBody jjtn000 = new SFPOrderedLHSFactBody(this, JJTORDEREDLHSFACTBODY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) OrderedLHSFactBody */
        try {
/*@egen*/
	(
			Constraint()
	)*/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


/**
*		LHSSlot
**/

//<LHS-slot> ::= <single-field-LHS-slot> | <multifield-LHS-slot>

SimpleNode LHSSlot():
{/*@bgen(jjtree) LHSSlot */
  SFPLHSSlot jjtn000 = new SFPLHSSlot(this, JJTLHSSLOT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) LHSSlot */
    try {
/*@egen*/
    (
    	Symbol() //slot Name
		Constraint()
    )/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/

    { return jjtn000; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}



/**
*		Constraint
**/

//<constraint> ::= ? | $? | <connected-constraint>

void Constraint()       :
{}
{
		SingleFieldWildcard()
	|	MultiFieldWildcard()
	|	ConnectedConstraint()
}



/**
*		Singlefield Wildcard
**/

SimpleNode SingleFieldWildcard() :
{/*@bgen(jjtree) SingleFieldWildcard */
  SFPSingleFieldWildcard jjtn000 = new SFPSingleFieldWildcard(this, JJTSINGLEFIELDWILDCARD);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) SingleFieldWildcard */
        try {
/*@egen*/
	<SFWILDCARD>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/

    { return jjtn000; }/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}



/**
*		Multifield Wildcard
**/

SimpleNode MultiFieldWildcard() :
{/*@bgen(jjtree) MultiFieldWildcard */
  SFPMultiFieldWildcard jjtn000 = new SFPMultiFieldWildcard(this, JJTMULTIFIELDWILDCARD);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) MultiFieldWildcard */
        try {
/*@egen*/
	<MFWILDCARD>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/

    { return jjtn000; }/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}



/**
*		Connected Constraint
**/

//<connected-constraint>::= <single-constraint> | <single-constraint> & <connected-constraint> |
//	<single-constraint> | <connected-constraint>

SimpleNode ConnectedConstraint():
{/*@bgen(jjtree) ConnectedConstraint */
  SFPConnectedConstraint jjtn000 = new SFPConnectedConstraint(this, JJTCONNECTEDCONSTRAINT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ConnectedConstraint */
    try {
/*@egen*/
    (
		LOOKAHEAD(3)
   		(
	    	SingleVariable()
			<AMPERSAND>
			LineConnectedConstraint()
		)
		|
		LOOKAHEAD( SingleVariable() <RBRACE> )
   		SingleVariable()
   		|
   		LineConnectedConstraint()
    )/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/

    {return jjtn000;}/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}



/**
*		Ampersand Connected Constraint
**/

SimpleNode AmpersandConnectedConstraint():
{/*@bgen(jjtree) AmpersandConnectedConstraint */
  SFPAmpersandConnectedConstraint jjtn000 = new SFPAmpersandConnectedConstraint(this, JJTAMPERSANDCONNECTEDCONSTRAINT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) AmpersandConnectedConstraint */
    try {
/*@egen*/
    (
    	Term()
    	(
			<AMPERSAND>
			Term()
		)*
    )/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/

    { return jjtn000; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}



/**
*		Line Connected Constraint
**/

SimpleNode LineConnectedConstraint():
{/*@bgen(jjtree) LineConnectedConstraint */
  SFPLineConnectedConstraint jjtn000 = new SFPLineConnectedConstraint(this, JJTLINECONNECTEDCONSTRAINT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) LineConnectedConstraint */
    try {
/*@egen*/
    (
    	AmpersandConnectedConstraint()
		(
			<LINE>
			AmpersandConnectedConstraint()
		)*
    )/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/

	{ return jjtn000; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}



/**
*		Term
**/

//<term> ::= <constant> | <single-field-variable> | <multifield-variable> |
//	:<function-call> | =<function-call>

SimpleNode Term()  :
{/*@bgen(jjtree) Term */
  SFPTerm jjtn000 = new SFPTerm(this, JJTTERM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Term */
    try {
/*@egen*/
    (
    	[
		Negation()
	]
    ( LOOKAHEAD(3)
    	Constant()
    |	SingleVariable()
    |	MultiVariable()
    |	Colon()
    |	Equals()
    )
    )/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/

    {return jjtn000;}/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}



/**
*		Negation
**/

SimpleNode Negation() :
{/*@bgen(jjtree) Negation */
  SFPNegation jjtn000 = new SFPNegation(this, JJTNEGATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Negation */
        try {
/*@egen*/
	<TILDE>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/

	{ return jjtn000; }/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}



/**
*		Colon
**/

SimpleNode Colon() :
{/*@bgen(jjtree) Colon */
  SFPColon jjtn000 = new SFPColon(this, JJTCOLON);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Colon */
        try {
/*@egen*/
	<COLON>
	FunctionCall()/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}



/**
*		Equals
**/

SimpleNode Equals() :
{/*@bgen(jjtree) Equals */
  SFPEquals jjtn000 = new SFPEquals(this, JJTEQUALS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Equals */
        try {
/*@egen*/
	<EQUALS>
	FunctionCall()/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}



/**
*		Defglobal Construct
**/

//<defglobal-construct> ::= (defglobal [<defmodule-name>] <global-assignment>*)

SimpleNode DefglobalConstruct()  :
{/*@bgen(jjtree) DefglobalConstruct */
  SFPDefglobalConstruct jjtn000 = new SFPDefglobalConstruct(this, JJTDEFGLOBALCONSTRUCT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) DefglobalConstruct */
    try {
/*@egen*/
    (
    	<DEFGLOBAL>
        [
         	Symbol()//defmodule-name
        ]
        (
        	GlobalAssignment()
        )*
    )/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/

    { return jjtn000; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}



/**
*		Global Assignment
**/

//<global-assignment> ::= <global-variable> = <expression>

SimpleNode GlobalAssignment()  :
{/*@bgen(jjtree) GlobalAssignment */
  SFPGlobalAssignment jjtn000 = new SFPGlobalAssignment(this, JJTGLOBALASSIGNMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) GlobalAssignment */
    try {
/*@egen*/
    (
        GlobalVariable()
        <EQUALS>
        Expression()
    )/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/

    { return jjtn000; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}



/**
*		Deffunction Construct
**/

//<deffunction-construct>
//	::= (deffunction <name> [(functiongroup <groupname>)] [<comment>] (<regular-parameter>* [<wildcard-parameter>]) <expression>*)

SimpleNode DeffunctionConstruct()  :
{/*@bgen(jjtree) DeffunctionConstruct */
  SFPDeffunctionConstruct jjtn000 = new SFPDeffunctionConstruct(this, JJTDEFFUNCTIONCONSTRUCT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) DeffunctionConstruct */
    try {
/*@egen*/
    (
    	<DEFFUNCTION>
        Symbol()	//name
        [
         	ConstructDescription()
        ]
        (<LBRACE>
        [
         	FunctionGroup()
         	<RBRACE>
         	<LBRACE>
        ]

        	(
        		SingleVariable()
        	)*
        	(
             	MultiVariable()
            )*
        <RBRACE>
        )
        ActionList()

    )/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/

    { return jjtn000; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}


/**
*		Function Group
**/

SimpleNode FunctionGroup() :
{/*@bgen(jjtree) FunctionGroup */
  SFPFunctionGroup jjtn000 = new SFPFunctionGroup(this, JJTFUNCTIONGROUP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) FunctionGroup */
                try {
/*@egen*/
		<FUNCTIONGROUP>
		Lexeme()/*@bgen(jjtree)*/
         {
           jjtree.closeNodeScope(jjtn000, true);
           jjtc000 = false;
         }
/*@egen*/

	 { return jjtn000; }/*@bgen(jjtree)*/
                } catch (Throwable jjte000) {
                  if (jjtc000) {
                    jjtree.clearNodeScope(jjtn000);
                    jjtc000 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte000 instanceof RuntimeException) {
                    throw (RuntimeException)jjte000;
                  }
                  if (jjte000 instanceof ParseException) {
                    throw (ParseException)jjte000;
                  }
                  throw (Error)jjte000;
                } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                  }
                }
/*@egen*/
}

/**
*		Defgeneric Construct
**/

//	<defgeneric-construct> ::= (defgeneric <name> [<comment>])

SimpleNode DefgenericConstruct() :
{/*@bgen(jjtree) DefgenericConstruct */
  SFPDefgenericConstruct jjtn000 = new SFPDefgenericConstruct(this, JJTDEFGENERICCONSTRUCT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) DefgenericConstruct */
     try {
/*@egen*/
     (
    	<DEFGENERIC>
        Symbol()	//name
        [
         	ConstructDescription()
        ]
     )/*@bgen(jjtree)*/
     {
       jjtree.closeNodeScope(jjtn000, true);
       jjtc000 = false;
     }
/*@egen*/

     { return jjtn000; }/*@bgen(jjtree)*/
     } catch (Throwable jjte000) {
       if (jjtc000) {
         jjtree.clearNodeScope(jjtn000);
         jjtc000 = false;
       } else {
         jjtree.popNode();
       }
       if (jjte000 instanceof RuntimeException) {
         throw (RuntimeException)jjte000;
       }
       if (jjte000 instanceof ParseException) {
         throw (ParseException)jjte000;
       }
       throw (Error)jjte000;
     } finally {
       if (jjtc000) {
         jjtree.closeNodeScope(jjtn000, true);
       }
     }
/*@egen*/
}



/**
*		Parameter Restriction
**/

//<parameter-restriction> ::= <single-field-variable> | (<single-field-variable> <type>* [<query>])

SimpleNode ParameterRestriction() : {/*@bgen(jjtree) ParameterRestriction */
  SFPParameterRestriction jjtn000 = new SFPParameterRestriction(this, JJTPARAMETERRESTRICTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ParameterRestriction */
        try {
/*@egen*/
	( LOOKAHEAD(2)
		SingleVariable()
	|	(
			<LBRACE>
				SingleVariable()
				(
					AllowedType()
				)*
				[
				 	Query()
				 ]
			<RBRACE>
		)
	)/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/

	{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}



/**
*		Wildcard Parameter Restriction
**/

//<wildcard-parameter-restriction> ::= <multifield-variable> | (<multifield-variable> <type>* [<query>])

SimpleNode WildcardParameterRestriction() : {/*@bgen(jjtree) WildcardParameterRestriction */
  SFPWildcardParameterRestriction jjtn000 = new SFPWildcardParameterRestriction(this, JJTWILDCARDPARAMETERRESTRICTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) WildcardParameterRestriction */
        try {
/*@egen*/
	( LOOKAHEAD(2)
		MultiVariable()
	|
		(
			<LBRACE>
				MultiVariable()
				(
					AllowedType()
				)*
				[
				 	Query()
				 ]
			<RBRACE>
		)
	)/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/

	{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}



/**
*		Query
**/

//<query> ::= <global-variable> | <function-call>

void Query() : {/*@bgen(jjtree) Query */
                 SFPQuery jjtn000 = new SFPQuery(this, JJTQUERY);
                 boolean jjtc000 = true;
                 jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) Query */
                try {
/*@egen*/
		GlobalVariable()
	|	FunctionCall()/*@bgen(jjtree)*/
                } catch (Throwable jjte000) {
                  if (jjtc000) {
                    jjtree.clearNodeScope(jjtn000);
                    jjtc000 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte000 instanceof RuntimeException) {
                    throw (RuntimeException)jjte000;
                  }
                  if (jjte000 instanceof ParseException) {
                    throw (ParseException)jjte000;
                  }
                  throw (Error)jjte000;
                } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                  }
                }
/*@egen*/
}



/**
*		Constraint Attribute
**/

//<constraint-attribute> ::= <type-attribute> | <allowed-constant-attribute> |
//	<range-attribute> | <cardinality-attribute>

void ConstraintAttribute()       : { }
{
	( LOOKAHEAD(2)
		TypeAttribute()
	|	AllowedConstantAttribute()
	|	RangeAttribute()
	|	CardinalityAttribute()
	)
}



/**
*		Type Attribute
**/

//<type-attribute> ::= (type <type-specification>)

SimpleNode TypeAttribute() :
{/*@bgen(jjtree) TypeAttribute */
  SFPTypeAttribute jjtn000 = new SFPTypeAttribute(this, JJTTYPEATTRIBUTE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) TypeAttribute */
        try {
/*@egen*/
	<TYPE>
	TypeSpecification()/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/

	{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}



/**
*		Type Specification
**/

//<type-specification> ::= <allowed-type>+ | ?VARIABLE

SimpleNode TypeSpecification() :
{/*@bgen(jjtree) TypeSpecification */
  SFPTypeSpecification jjtn000 = new SFPTypeSpecification(this, JJTTYPESPECIFICATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) TypeSpecification */
        try {
/*@egen*/	(
		(
			AllowedType()
		)+
		| 	VariableType()
	)/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}



/**
*		Allowed Type
**/

//<allowed-type> ::= SYMBOL | STRING | LEXEME | INTEGER | FLOAT | NUMBER |
// EXTERNAL-ADDRESS | FACT-ADDRESS | DATETIME

void AllowedType()       :
{}
{
	(		SymbolType()
		|	StringType()
		|	DateTimeType()
		|	LexemeType()
		|	IntegerType()
		|	FloatType()
		|	NumberType()
		|	BooleanType()
		|	FactAddressType()
	)
}



/**
*		Allowed Constant Atrributes
**/

// <allowed-constant-attribute> ::= (allowed-symbols <symbol-list>) | (allowed-strings <string-list>) |
//	(allowed-lexemes <lexeme-list> | (allowed-integers <integer-list>) | (allowed-floats <float-list>) |
//	(allowed-numbers <number-list>) | (allowed-values <value-list>)

SimpleNode AllowedConstantAttribute() :
{/*@bgen(jjtree) AllowedConstantAttribute */
  SFPAllowedConstantAttribute jjtn000 = new SFPAllowedConstantAttribute(this, JJTALLOWEDCONSTANTATTRIBUTE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) AllowedConstantAttribute */
        try {
/*@egen*/
	(
			t = <ALLOWED_SYMBOLS> SymbolList()
		|	t = <ALLOWED_STRINGS> StringList()
		|	t = <ALLOWED_LEXEMES> LexemeList()
		|	t = <ALLOWED_INTEGERS> IntegerList()
		|	t = <ALLOWED_FLOATS> FloatList()
		|	t = <ALLOWED_NUMBERS> NumberList()
		|	t = <ALLOWED_VALUES> ValueList()
	)/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/

	{
		jjtn000.jjtSetValue(t.image);
		return jjtn000;
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}



/**
*		Symbol List
**/

//<symbol-list> ::= <symbol>+ | ?VARIABLE

SimpleNode SymbolList() : {/*@bgen(jjtree) SymbolList */
  SFPSymbolList jjtn000 = new SFPSymbolList(this, JJTSYMBOLLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) SymbolList */
    try {
/*@egen*/
    (
    		( <SYMBOL> )+
	|	VariableType()
    )/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/

    { return jjtn000; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}



/**
*		String List
**/

//<string-list> ::= <string>+ | ?VARIABLE

SimpleNode StringList() :
{/*@bgen(jjtree) StringList */
  SFPStringList jjtn000 = new SFPStringList(this, JJTSTRINGLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) StringList */
    try {
/*@egen*/
    (
    		( <STRING> )+
	|	VariableType()
    )/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/

    { return jjtn000; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}



/**
*		Lexeme List
**/

//<lexeme-list> ::= <lexeme>+ | ?VARIABLE

SimpleNode LexemeList() :
{/*@bgen(jjtree) LexemeList */
  SFPLexemeList jjtn000 = new SFPLexemeList(this, JJTLEXEMELIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) LexemeList */
    try {
/*@egen*/
    (
    		( Lexeme() )+
	|	VariableType()
    )/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/

    { return jjtn000; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}



/**
*		Integer List
**/

//<integer-list> ::= <integer>+ | ?VARIABLE

SimpleNode IntegerList() :
{/*@bgen(jjtree) IntegerList */
  SFPIntegerList jjtn000 = new SFPIntegerList(this, JJTINTEGERLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) IntegerList */
    try {
/*@egen*/
    (
    		( <INTEGER> )+
	| 	VariableType()
    )/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/

    { return jjtn000; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/**
*		Float List
**/

//<float-list> ::= <float>+ | ?VARIABLE

SimpleNode FloatList() :
{/*@bgen(jjtree) FloatList */
  SFPFloatList jjtn000 = new SFPFloatList(this, JJTFLOATLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) FloatList */
    try {
/*@egen*/
    (
    		( <FLOAT> )+
	|	VariableType()
    )/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/

    { return jjtn000; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}



/**
*		Number List
**/

//<number-list> ::= <number>+ | ?VARIABLE

SimpleNode NumberList() :
{/*@bgen(jjtree) NumberList */
  SFPNumberList jjtn000 = new SFPNumberList(this, JJTNUMBERLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) NumberList */
    try {
/*@egen*/
    (
    		( Number() )+
	| 	VariableType()
    )/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/

    { return jjtn000; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}



/**
*		Value List
**/

//<value-list> ::= <constant>+ | ?VARIABLE

SimpleNode ValueList() :
{/*@bgen(jjtree) ValueList */
  SFPValueList jjtn000 = new SFPValueList(this, JJTVALUELIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ValueList */
    try {
/*@egen*/
    (
    		( Constant() )+
	|	VariableType()
    )/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/

    { return jjtn000; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}



/**
*		Range Attribute
**/

//<range-attribute> ::= (range <range-specification> <range-specification>)

SimpleNode RangeAttribute() :
{/*@bgen(jjtree) RangeAttribute */
  SFPRangeAttribute jjtn000 = new SFPRangeAttribute(this, JJTRANGEATTRIBUTE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) RangeAttribute */
    try {
/*@egen*/
    (
    	<RANGE>

	RangeSpecification()

	RangeSpecification()
   )/*@bgen(jjtree)*/
   {
     jjtree.closeNodeScope(jjtn000, true);
     jjtc000 = false;
   }
/*@egen*/

   { return jjtn000; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}


/**
*		Range Specification
**/

//<range-specification> ::= <number> | ?VARIABLE

SimpleNode RangeSpecification()  :
{/*@bgen(jjtree) RangeSpecification */
  SFPRangeSpecification jjtn000 = new SFPRangeSpecification(this, JJTRANGESPECIFICATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) RangeSpecification */
    try {
/*@egen*/
    (
    		Number()
	| 	VariableType()
    )/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/

    { return jjtn000; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}


//<cardinality-attribute> ::= (cardinality <cardinality-specification> <cardinality-specification>)
SimpleNode CardinalityAttribute()  :
{/*@bgen(jjtree) CardinalityAttribute */
  SFPCardinalityAttribute jjtn000 = new SFPCardinalityAttribute(this, JJTCARDINALITYATTRIBUTE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) CardinalityAttribute */
    try {
/*@egen*/
    (
    	<CARDINALITY>

	CardinalitySpecification()

	CardinalitySpecification()
    )/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/

    { return jjtn000; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}



/**
*		Cardinality Specification
**/

//<cardinality-specification> ::= <integer> | ?VARIABLE

SimpleNode CardinalitySpecification() :
{/*@bgen(jjtree) CardinalitySpecification */
  SFPCardinalitySpecification jjtn000 = new SFPCardinalitySpecification(this, JJTCARDINALITYSPECIFICATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) CardinalitySpecification */
    try {
/*@egen*/
    (
    		Integer()
	| 	VariableType()
    )/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/

    { return jjtn000; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}



/**
*		Defmodule Construct
**/

//	<defmodule-construct> ::= (defmodule <module-name> [<comment>] )

SimpleNode DefmoduleConstruct() :
{/*@bgen(jjtree) DefmoduleConstruct */
  SFPDefmoduleConstruct jjtn000 = new SFPDefmoduleConstruct(this, JJTDEFMODULECONSTRUCT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) DefmoduleConstruct */
    try {
/*@egen*/
    (
    	<DEFMODULE>
	Symbol()
	[
		ConstructDescription()
	]
    )/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/

    { return jjtn000; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}